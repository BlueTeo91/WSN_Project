###############################################################################
#                                                                             #
#                                                       12/Oct/2015  10:21:26 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Application\Configure\GlobalVars #
#                    .c                                                       #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Configure\GlobalVars #
#                    .c" -D gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0   #
#                    -D gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess  #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Debug\List\" -lC "C:\Documents   #
#                    and Settings\Administrator\Desktop\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\MyWirelessApp Demo Non Beacon    #
#                    (End Device)\Debug\List\" -lB "C:\Documents and          #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\MacPhy\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Init\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Interface\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Configure\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\UartUtil\" -I        #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Source\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Source\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Interface\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Interface\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\LibInterface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Display\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Keyboard\" -I         #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\NVM\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\TMR\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\UART\" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 5.4     #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\List\GlobalVars.lst        #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\Obj\GlobalVars.o           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\Application\Configure\GlobalVars.c
      1          /************************************************************************************
      2          * This module implements the memory allocation, list, and message modules. The memory 
      3          * allocation is build around N (1-4) pools with various memory allocation unit (block)
      4          * sizes. Each pool consists of an anchor with head and tail pointers. The memory blocks
      5          * are all linked to the anchor using a single chained list. Thus each block has a next
      6          * pointer. The user of the functions in this module never has to be concerned with the
      7          * list overhead since this is handled transparently. The block pointer which the user
      8          * receives when allocating memory is pointing to the address after the next-pointer.
      9          *
     10          * FIFO Queues are implemented using the same list functions as used by the memory
     11          * (de)allocation functions. The queue data object is simply an anchor (anchor_t).
     12          * List_AddTail is used for putting allocated blocks on the queue, and List_RemoveHead
     13          * will detach the block from the queue. Before using a queue anchor it must have been
     14          * initialized with List_ClearAnchor. No extra header is required in order to put a
     15          * block in a queue. However, messages should contain type information beside the
     16          * message data so that the message handler at the receiver can reckognize the message.
     17          *
     18          * Messages are sent by allocating a block using MSG_Alloc, and using the MSG_Send macro
     19          * to call the Service Access Point (SAP) of the receiver. If the SAP handles specific
     20          * messages synchronously (returns with result immideately) then the block may be
     21          * allocated on the stack of the calling function. The message types which allows this
     22          * are specified in the design documents.
     23          *
     24          * Copyright (c) 2007, Freescale, Inc. All rights reserved.
     25          *
     26          *
     27          * No part of this document must be reproduced in any form - including copied,
     28          * transcribed, printed or by any electronic means - without specific written
     29          * permission from Freescale Semiconductor.
     30          *
     31          *****************************************************************************/
     32          
     33          #include "MsgSystem.h"
     34          
     35          /* Implemented in getSP.s*/
     36          uint32_t getSP();
     37          /************************************************************************************
     38          *************************************************************************************
     39          * Private memory declarations
     40          *************************************************************************************
     41          ************************************************************************************/
     42          
     43            // The heap for MAC, NWK and application memory blocks.

   \                                 In section .bss, align 4
     44          uint8_t maMacHeap[mMmTotalPoolSize_c];
   \                     maMacHeap:
   \   00000000                      DS8 1120
     45          
     46            // Memory pool info and anchors.

   \                                 In section .bss, align 4
     47          pools_t maMmPools[gMmNumPools_c];
   \                     maMmPools:
   \   00000000                      DS8 36
     48          
     49            // Const array used during initialization. Describes the memory layout.
     50            // Pools must occur in the table in ascending order according to their size.
     51            // If coordinator capability is required, then there must always exist an
     52            // extra MAC pool for receiving data frames. This pool is private to the MAC.
     53            // An example of a memory layout for coordinators/routers:
     54            // Pool3]:
     55            //   SmallMessages[M], // Command messages of each ~22 bytes
     56            //   BigMessages[N-1], // Data messages of each ~134 bytes
     57            //   BigMessages[1],   // One data message of ~134 bytes, MAC private.
     58            // MSG_Alloc ensures that only the MAC has access to the private pool.
     59          
     60            // An example of a memory layout for devices:
     61            // Pool2]:
     62            //   SmallMessages[M], // Command messages of each ~22 bytes
     63            //   BigMessages[N],   // Data messages of each ~134 bytes
     64            //

   \                                 In section .data, align 4
     65          poolInfo_t poolInfo[gMmNumPools_c] = {
   \                     poolInfo:
   \   00000000   051898000598       DC8 5, 24, 152, 0, 5, 152, 152, 0, 1, 152, 0, 0
   \              980001980000
     66            gMmPoolSize0_c, mMmBlockSize0_c, mMmBlockSize1_c, 0,
     67          #if gMmNumPools_c > 1
     68            gMmPoolSize1_c, mMmBlockSize1_c, mMmBlockSize2_c, 0,
     69          #if gMmNumPools_c > 2
     70            gMmPoolSize2_c, mMmBlockSize2_c, 0, 0,
     71          #if gMmNumPools_c > 3
     72            gMmPoolSize3_c, mMmBlockSize3_c, 0, 0
     73          #endif // gMmNumPools_c > 3
     74          #endif // gMmNumPools_c > 2
     75          #endif // gMmNumPools_c > 1
     76          };
     77          

   \                                 In section .data, align 4
     78          pools_t *pLastPool = &maMmPools[mMmLastPoolIdx_c];
   \                     pLastPool:
   \   00000000   ........           DC32 maMmPools + 18H
     79          #if gBigMsgsMacOnly_d

   \                                 In section .data, align 4
     80            pools_t *pSecondLastPool = &maMmPools[mMmLastPoolIdx_c-1];
   \                     pSecondLastPool:
   \   00000000   ........           DC32 maMmPools + 0CH
     81          #endif
     82          
     83          #ifndef gMAC2006_d
     84            // Application allocated space for MAC PIB ACL Entry descriptors.
     85          #if gNumAclEntryDescriptors_c > 0

   \                                 In section .bss, align 4
     86            aclEntryDescriptor_t gPIBaclEntryDescriptorSet[gNumAclEntryDescriptors_c];
   \                     gPIBaclEntryDescriptorSet:
   \   00000000                      DS8 160
     87          
     88              // Set number of ACL entries. Used by the MAC.

   \                                 In section .data, align 1
     89            uint8_t gNumAclEntryDescriptors = gNumAclEntryDescriptors_c;
   \                     gNumAclEntryDescriptors:
   \   00000000   04                 DC8 4
     90            #endif // gNumAclEntryDescriptors_c
     91          #else
     92            
     93            #if gNumKeyTableEntries_c > 0
     94              KeyDescriptor_t gPIBKeyTable[gNumKeyTableEntries_c];
     95              const uint8_t gNumKeyTableEntries = gNumKeyTableEntries_c;
     96              
     97              /* Allocate KeyIdLookupDescriptor_t, KeyDeviceDescriptor_t, KeyUsageDescriptor_t */ 
     98              /* These arrays are part of KeyDescriptor_t structure */
     99              /* Allocate a continuous space for each array based on the gNumKeyTableEntries_c */
    100              /* The MAC PIB will initialize the pointers accordingly */
    101              
    102              #if gNumKeyIdLookupEntries_c > 0
    103                 KeyIdLookupDescriptor_t gPIBKeyIdLookupDescriptorTable[gNumKeyIdLookupEntries_c * gNumKeyTableEntries_c];
    104                 const uint8_t gNumKeyIdLookupEntries = gNumKeyIdLookupEntries_c; /* The number of elements in each virtual array inside the gPIBKeyIdLookupDescriptorTable */
    105              #endif //gNumKeyIdLookupEntries_c
    106              
    107              #if gNumKeyDeviceListEntries_c > 0
    108                 KeyDeviceDescriptor_t  gPIBKeyDeviceDescriptorTable[gNumKeyDeviceListEntries_c * gNumKeyTableEntries_c];
    109                 const uint8_t gNumKeyDeviceListEntries = gNumKeyDeviceListEntries_c; /* The number of elements for each virtual array inside the gPIBKeyDeviceDescriptorTable */
    110              #endif //gNumKeyDeviceListEntries_c
    111              
    112              #if gNumKeyUsageListEntries_c > 0
    113                 KeyUsageDescriptor_t  gPIBKeyUsageDescriptorTable[gNumKeyUsageListEntries_c * gNumKeyTableEntries_c];
    114                 const uint8_t gNumKeyUsageListEntries = gNumKeyUsageListEntries_c; /* The number of elements for each virtual array inside the gPIBKeyDeviceDescriptorTable */
    115              #endif //gNumKeyUsageListEntries_c
    116            #endif //gNumKeyTableEntries_c
    117            
    118            #if gNumDeviceTableEntries_c > 0
    119              DeviceDescriptor_t gPIBDeviceTable[gNumDeviceTableEntries_c];
    120              const uint8_t gNumDeviceTableEntries = gNumDeviceTableEntries_c;    
    121            #endif //gNumDeviceTableEntries_c
    122          
    123            #if gNumSecurityLevelTableEntries_c > 0
    124              SecurityLevelDescriptor_t gPIBSecurityLevelTable[gNumSecurityLevelTableEntries_c];
    125              const uint8_t gNumSecurityLevelTableEntries = gNumSecurityLevelTableEntries_c;    
    126            #endif //gNumKeyTableEntries_d
    127          
    128          
    129          #endif  //gMAC2006_d
    130          #if MsgTracking_d

   \                                 In section .rodata, align 1
    131          const uint8_t TotalNoOfMsgs_c = (gTotalBigMsgs_d + gTotalSmallMsgs_d);
   \                     TotalNoOfMsgs_c:
   \   00000000   0B                 DC8 11
    132          

   \                                 In section .bss, align 4
    133          MsgTracking_t MsgTrackingArray[(gTotalBigMsgs_d + gTotalSmallMsgs_d)] = 0;
   \                     MsgTrackingArray:
   \   00000000                      DS8 188

   \                                 In section .bss, align 1
    134          uint8_t NoOfWrongAddrs = 0;
   \                     NoOfWrongAddrs:
   \   00000000                      DS8 1
    135          
    136          extern uint32_t MM_GetLinkRegister(void);
    137          
    138          #endif
    139          
    140          /************************************************************************************
    141          *************************************************************************************
    142          * Private prototypes
    143          *************************************************************************************
    144          ************************************************************************************/
    145          
    146          /************************************************************************************
    147          *************************************************************************************
    148          * Public functions
    149          *************************************************************************************
    150          ************************************************************************************/
    151          /************************************************************************************
    152          * Initialize Msg tracking array. It is called by the Msg system when the MAC is reset
    153          *
    154          * Interface assumptions:
    155          *   None
    156          *   
    157          * Return value:
    158          *   None.
    159          * 
    160          ************************************************************************************/
    161          

   \                                 In section .text, align 2, keep-with-next
    162          void MM_InitMsgTracking(void) {
   \                     MM_InitMsgTracking:
   \   00000000   80B5               PUSH     {R7,LR}
    163          #if MsgTracking_d
    164             FLib_MemSet((uint8_t* )&MsgTrackingArray[0],0,(sizeof(MsgTracking_t)/sizeof(uint8_t)) * TotalNoOfMsgs_c);
   \   00000002   ....               LDR      R0,??DataTable3
   \   00000004   0278               LDRB     R2,[R0, #+0]
   \   00000006   1120               MOVS     R0,#+17
   \   00000008   4243               MULS     R2,R0,R2
   \   0000000A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000000C   120C               LSRS     R2,R2,#+16
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   ....               LDR      R0,??DataTable3_1
   \   00000012   ........           BL       FLib_MemSet
    165             NoOfWrongAddrs = 0;
   \   00000016   ....               LDR      R0,??DataTable3_2
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   0170               STRB     R1,[R0, #+0]
    166          #endif   
    167          }
   \   0000001C   09BC               POP      {R0,R3}
   \   0000001E   1847               BX       R3               ;; return
    168          /************************************************************************************
    169          * Initialize Msg tracking array a current index with a Msg address.
    170          * This functions is called for once for every Msg when the MAC is reset.
    171          *
    172          * Interface assumptions:
    173          *   None
    174          *   
    175          * Return value:
    176          *   None.
    177          * 
    178          ************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    179          void   MM_AddMsgToTrackingArray(uint8_t Index, uint32_t Addr) {
   \                     MM_AddMsgToTrackingArray:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    180          #if MsgTracking_d
    181                MsgTrackingArray[Index].MsgAddr = Addr;  
   \   00000006   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000008   240E               LSRS     R4,R4,#+24
   \   0000000A   1120               MOVS     R0,#+17
   \   0000000C   6043               MULS     R0,R4,R0
   \   0000000E   ....               LDR      R1,??DataTable3_1
   \   00000010   0918               ADDS     R1,R1,R0
   \   00000012   2800               MOVS     R0,R5
   \   00000014   ........           BL       __aeabi_uwrite4
    182          #else
    183            /*To prevent compiler warinngs:*/
    184            (void) Index;
    185            (void) Addr;  
    186          #endif      
    187          }
   \   00000018   30BC               POP      {R4,R5}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    188          /************************************************************************************
    189          * This function finds the index of a Msg in the Tracking array
    190          * -1 is returned if Msg not found and the NoOfWrongAddrs is incremented.
    191          *
    192          * Interface assumptions:
    193          *   None
    194          *   
    195          * Return value:
    196          *   Index of message in tracking array
    197          * 
    198          ************************************************************************************/  

   \                                 In section .text, align 2, keep-with-next
    199          int8_t MM_GetMsgIndex(const uint32_t MsgAddr)
    200          {
   \                     MM_GetMsgIndex:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    201          #if MsgTracking_d
    202            uint8_t i;    
    203            /*Search through the Tracking array*/ 
    204            for (i = 0; i < TotalNoOfMsgs_c; i++) 
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0500               MOVS     R5,R0
   \                     ??MM_GetMsgIndex_0:
   \   00000008   ....               LDR      R0,??DataTable3
   \   0000000A   0078               LDRB     R0,[R0, #+0]
   \   0000000C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000000E   2D0E               LSRS     R5,R5,#+24
   \   00000010   8542               CMP      R5,R0
   \   00000012   0FD2               BCS      ??MM_GetMsgIndex_1
    205            {      
    206              /*If Msg Addr found then exit with Index*/
    207              if (MsgAddr == MsgTrackingArray[i].MsgAddr)
   \   00000014   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000016   2D0E               LSRS     R5,R5,#+24
   \   00000018   1120               MOVS     R0,#+17
   \   0000001A   6843               MULS     R0,R5,R0
   \   0000001C   ....               LDR      R1,??DataTable3_1
   \   0000001E   0818               ADDS     R0,R1,R0
   \   00000020   ........           BL       __aeabi_uread4
   \   00000024   8442               CMP      R4,R0
   \   00000026   03D1               BNE      ??MM_GetMsgIndex_2
    208                return i;
   \   00000028   2800               MOVS     R0,R5
   \   0000002A   0006               LSLS     R0,R0,#+24       ;; SignExtS R0,R0,#+24,#+24
   \   0000002C   0016               ASRS     R0,R0,#+24
   \   0000002E   08E0               B        ??MM_GetMsgIndex_3
    209            }
   \                     ??MM_GetMsgIndex_2:
   \   00000030   6D1C               ADDS     R5,R5,#+1
   \   00000032   E9E7               B        ??MM_GetMsgIndex_0
    210            /*Msg addr not found, increment error counter and return*/  
    211            NoOfWrongAddrs++;
   \                     ??MM_GetMsgIndex_1:
   \   00000034   ....               LDR      R0,??DataTable3_2
   \   00000036   0078               LDRB     R0,[R0, #+0]
   \   00000038   401C               ADDS     R0,R0,#+1
   \   0000003A   ....               LDR      R1,??DataTable3_2
   \   0000003C   0870               STRB     R0,[R1, #+0]
    212            return -1;
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   C043               MVNS     R0,R0            ;; #-1
   \                     ??MM_GetMsgIndex_3:
   \   00000042   30BC               POP      {R4,R5}
   \   00000044   08BC               POP      {R3}
   \   00000046   1847               BX       R3               ;; return
    213          #else  
    214            /*To prevent compiler warinngs:*/
    215           (void) MsgAddr;
    216           return -1;
    217          #endif 
    218          }
    219          
    220          /************************************************************************************
    221          * This function is called when ever a Msg is freed or allocated and updates
    222          * the tracking information for that particular Msg
    223          * 
    224          *
    225          * Interface assumptions:
    226          *   None
    227          *   
    228          * Return value:
    229          *   Success status
    230          * 
    231          ************************************************************************************/  

   \                                 In section .text, align 2, keep-with-next
    232          bool_t MM_UpdateMsgTracking(const void *pBlock, const bool_t Alloc)
    233          {
   \                     MM_UpdateMsgTracking:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
    234          #if MsgTracking_d
    235            int8_t index = MM_GetMsgIndex((uint32_t)pBlock);
   \   00000006   3000               MOVS     R0,R6
   \   00000008   ........           BL       MM_GetMsgIndex
   \   0000000C   0400               MOVS     R4,R0
    236            if (index >= 0)
   \   0000000E   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   00000010   2416               ASRS     R4,R4,#+24
   \   00000012   002C               CMP      R4,#+0
   \   00000014   5AD4               BMI      ??MM_UpdateMsgTracking_0
    237            {          
    238              
    239              if (MsgTrackingArray[index].AllocStatus == Alloc)
   \   00000016   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   00000018   2416               ASRS     R4,R4,#+24
   \   0000001A   1120               MOVS     R0,#+17
   \   0000001C   6043               MULS     R0,R4,R0
   \   0000001E   ....               LDR      R1,??DataTable3_1
   \   00000020   0818               ADDS     R0,R1,R0
   \   00000022   007C               LDRB     R0,[R0, #+16]
   \   00000024   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000026   2D0E               LSRS     R5,R5,#+24
   \   00000028   A842               CMP      R0,R5
   \   0000002A   01D1               BNE      ??MM_UpdateMsgTracking_1
    240              {      
    241               return FALSE;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   4EE0               B        ??MM_UpdateMsgTracking_2
    242              } 
    243                  
    244              MsgTrackingArray[index].AllocStatus = Alloc;
   \                     ??MM_UpdateMsgTracking_1:
   \   00000030   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   00000032   2416               ASRS     R4,R4,#+24
   \   00000034   1120               MOVS     R0,#+17
   \   00000036   6043               MULS     R0,R4,R0
   \   00000038   ....               LDR      R1,??DataTable3_1
   \   0000003A   0818               ADDS     R0,R1,R0
   \   0000003C   0574               STRB     R5,[R0, #+16]
    245           
    246              /*Update MsgTracking array counters and return address of alloc or free */  
    247              if (Alloc) {
   \   0000003E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000040   2D0E               LSRS     R5,R5,#+24
   \   00000042   002D               CMP      R5,#+0
   \   00000044   20D0               BEQ      ??MM_UpdateMsgTracking_3
    248                MsgTrackingArray[index].AllocCounter++;
   \   00000046   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   00000048   2416               ASRS     R4,R4,#+24
   \   0000004A   1120               MOVS     R0,#+17
   \   0000004C   6043               MULS     R0,R4,R0
   \   0000004E   ....               LDR      R1,??DataTable3_1
   \   00000050   0918               ADDS     R1,R1,R0
   \   00000052   087B               LDRB     R0,[R1, #+12]
   \   00000054   4A7B               LDRB     R2,[R1, #+13]
   \   00000056   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+16
   \   00000058   120C               LSRS     R2,R2,#+16
   \   0000005A   1043               ORRS     R0,R0,R2
   \   0000005C   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   0000005E   2416               ASRS     R4,R4,#+24
   \   00000060   1121               MOVS     R1,#+17
   \   00000062   6143               MULS     R1,R4,R1
   \   00000064   ....               LDR      R2,??DataTable3_1
   \   00000066   5118               ADDS     R1,R2,R1
   \   00000068   401C               ADDS     R0,R0,#+1
   \   0000006A   0873               STRB     R0,[R1, #+12]
   \   0000006C   000A               LSRS     R0,R0,#+8
   \   0000006E   4873               STRB     R0,[R1, #+13]
    249                MsgTrackingArray[index].AllocAddr = MM_GetLinkRegister();
   \   00000070   ........           BL       MM_GetLinkRegister
   \   00000074   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   00000076   2416               ASRS     R4,R4,#+24
   \   00000078   1121               MOVS     R1,#+17
   \   0000007A   6143               MULS     R1,R4,R1
   \   0000007C   ....               LDR      R2,??DataTable3_1
   \   0000007E   5118               ADDS     R1,R2,R1
   \   00000080   091D               ADDS     R1,R1,#+4
   \   00000082   ........           BL       __aeabi_uwrite4
   \   00000086   1FE0               B        ??MM_UpdateMsgTracking_4
    250              }
    251              else {
    252                MsgTrackingArray[index].FreeCounter++;        
   \                     ??MM_UpdateMsgTracking_3:
   \   00000088   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   0000008A   2416               ASRS     R4,R4,#+24
   \   0000008C   1120               MOVS     R0,#+17
   \   0000008E   6043               MULS     R0,R4,R0
   \   00000090   ....               LDR      R1,??DataTable3_1
   \   00000092   0918               ADDS     R1,R1,R0
   \   00000094   887B               LDRB     R0,[R1, #+14]
   \   00000096   CA7B               LDRB     R2,[R1, #+15]
   \   00000098   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+16
   \   0000009A   120C               LSRS     R2,R2,#+16
   \   0000009C   1043               ORRS     R0,R0,R2
   \   0000009E   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   000000A0   2416               ASRS     R4,R4,#+24
   \   000000A2   1121               MOVS     R1,#+17
   \   000000A4   6143               MULS     R1,R4,R1
   \   000000A6   ....               LDR      R2,??DataTable3_1
   \   000000A8   5118               ADDS     R1,R2,R1
   \   000000AA   401C               ADDS     R0,R0,#+1
   \   000000AC   8873               STRB     R0,[R1, #+14]
   \   000000AE   000A               LSRS     R0,R0,#+8
   \   000000B0   C873               STRB     R0,[R1, #+15]
    253                MsgTrackingArray[index].FreeAddr = MM_GetLinkRegister();
   \   000000B2   ........           BL       MM_GetLinkRegister
   \   000000B6   2406               LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
   \   000000B8   2416               ASRS     R4,R4,#+24
   \   000000BA   1121               MOVS     R1,#+17
   \   000000BC   6143               MULS     R1,R4,R1
   \   000000BE   ....               LDR      R2,??DataTable3_1
   \   000000C0   5118               ADDS     R1,R2,R1
   \   000000C2   0831               ADDS     R1,R1,#+8
   \   000000C4   ........           BL       __aeabi_uwrite4
    254              }
    255              return TRUE;
   \                     ??MM_UpdateMsgTracking_4:
   \   000000C8   0120               MOVS     R0,#+1
   \   000000CA   00E0               B        ??MM_UpdateMsgTracking_2
    256                
    257            }      
    258            else  
    259              return FALSE;
   \                     ??MM_UpdateMsgTracking_0:
   \   000000CC   0020               MOVS     R0,#+0
   \                     ??MM_UpdateMsgTracking_2:
   \   000000CE   70BC               POP      {R4-R6}
   \   000000D0   08BC               POP      {R3}
   \   000000D2   1847               BX       R3               ;; return
    260          #else
    261            /*To prevent compiler warinngs:*/
    262            (void) pBlock;
    263            (void) Alloc;  
    264            return TRUE;
    265          #endif  
    266          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     TotalNoOfMsgs_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     MsgTrackingArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     NoOfWrongAddrs
    267          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     MM_AddMsgToTrackingArray     12
     MM_GetMsgIndex               12
     MM_InitMsgTracking            8
     MM_UpdateMsgTracking         16


   Section sizes:

     Function/Label            Bytes
     --------------            -----
     maMacHeap                 1120
     maMmPools                   36
     poolInfo                    12
     pLastPool                    4
     pSecondLastPool              4
     gPIBaclEntryDescriptorSet  160
     gNumAclEntryDescriptors      1
     TotalNoOfMsgs_c              1
     MsgTrackingArray           188
     NoOfWrongAddrs               1
     MM_InitMsgTracking          32
     MM_AddMsgToTrackingArray    30
     MM_GetMsgIndex              72
     MM_UpdateMsgTracking       212
     ??DataTable3                 4
     ??DataTable3_1               4
     ??DataTable3_2               4

 
 1 505 bytes in section .bss
    21 bytes in section .data
     1 byte  in section .rodata
   358 bytes in section .text
 
   358 bytes of CODE  memory
     1 byte  of CONST memory
 1 526 bytes of DATA  memory

Errors: none
Warnings: none
