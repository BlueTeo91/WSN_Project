###############################################################################
#                                                                             #
#                                                       08/Dec/2015  00:24:11 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Application\Source\MApp.c                        #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Application\Source\MApp.c" -D                    #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Debug\List\" -lC "C:\Documents and               #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Debug\List\" -lB    #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Debug\Obj\"         #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=ARM7TDMI-S --fpu=None              #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4 Evaluation\arm\INC\DLib_Config_Normal.h"   #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\MacPhy\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Application\Init\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\Application\Interface\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\Configure\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\UartUtil\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\Source\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\SSM\TS\Interface\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\SSM\TS\Source\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and         #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\SSM\ZTC\Source\"    #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Interface\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\LibInterface\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Source\Display\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\PLM\Source\Keyboard\" -I "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\Source\NVM\"    #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Source\TMR\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\Source\UART\"   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench 5.4  #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Debug\List\MApp.lst                              #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Debug\Obj\MApp.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWirelessApp Demo Non Beacon (End Device)\Application\Source\MApp.c
      1          /*****************************************************************************
      2          * MyWirelessApp Demo Non Beacon End Device application.
      3          *
      4          * (c) Copyright 2008, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          
     13          #include "MApp.h"
     14          #include "NVM_Interface.h"
     15          
     16          /************************************************************************************
     17          *************************************************************************************
     18          * Private macros
     19          *************************************************************************************
     20          ************************************************************************************/
     21          
     22          /* If there are too many pending packets to be send over the air, */
     23          /* receive mMaxKeysToReceive_c chars. */
     24          /* The chars will be send over the air when there are no pending packets*/
     25          #define mMaxKeysToReceive_c 32
     26          
     27          /************************************************************************************
     28          *************************************************************************************
     29          * Private prototypes
     30          *************************************************************************************
     31          ************************************************************************************/
     32          
     33          /* Forward declarations of helper functions */
     34          static void    UartRxCallBack(void);
     35          static uint8_t App_StartScan(uint8_t scanType);
     36          static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
     37          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
     38          static uint8_t App_SendAssociateRequest(void);
     39          static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
     40          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
     41          static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
     42          static void    App_TransmitUartData(void);
     43          static void    App_TransmitUart2Data(uint8_t);
     44          static void    AppPollWaitTimeout(uint8_t tmr);
     45          static void    App_HandleKeys( key_event_t events );
     46          
     47          /************************************************************************************
     48          *************************************************************************************
     49          * Private type definitions
     50          *************************************************************************************
     51          ************************************************************************************/
     52          
     53          
     54          /************************************************************************************
     55          *************************************************************************************
     56          * Private memory declarations
     57          *************************************************************************************
     58          ************************************************************************************/
     59          
     60          /* Information about the PAN we are part of */

   \                                 In section .bss, align 4
     61          static panDescriptor_t mCoordInfo;
   \                     mCoordInfo:
   \   00000000                      DS8 24
     62          
     63          /* This is either the short address assigned by the PAN coordinator
     64             during association, or our own extended MAC address. */

   \                                 In section .bss, align 4
     65          static uint8_t maMyAddress[8];
   \                     maMyAddress:
   \   00000000                      DS8 8
     66          /* The devices address mode. If 2, then maMyAddress contains the short
     67             address assigned by the PAN coordinator. If 3, then maMyAddress is
     68             equal to the extended address. */

   \                                 In section .bss, align 1
     69          static uint8_t mAddrMode;
   \                     mAddrMode:
   \   00000000                      DS8 1
     70          
     71          /* Data request packet for sending UART input to the coordinator */

   \                                 In section .bss, align 4
     72          static nwkToMcpsMessage_t *mpPacket;
   \                     mpPacket:
   \   00000000                      DS8 4
     73          
     74          /* The MSDU handle is a unique data packet identifier */

   \                                 In section .bss, align 1
     75          static uint8_t mMsduHandle;
   \                     mMsduHandle:
   \   00000000                      DS8 1
     76          
     77          /* Number of pending data packets */

   \                                 In section .bss, align 1
     78          static uint8_t mcPendingPackets;
   \                     mcPendingPackets:
   \   00000000                      DS8 1
     79          
     80          
     81          
     82          /* Signals that an MLME-Poll request is pending, and that we must wait for 
     83             the MLME-Poll confirm message before sending the next poll request. */

   \                                 In section .bss, align 1
     84          static bool_t mWaitPollConfirm;
   \                     mWaitPollConfirm:
   \   00000000                      DS8 1
     85          
     86          /* Time between MLME-Poll requests */

   \                                 In section .bss, align 2
     87          static uint16_t mPollInterval;
   \                     mPollInterval:
   \   00000000                      DS8 2
     88          
     89            
     90                
     91          //value uart2

   \                                 In section .bss, align 1
     92          uint8_t val;
   \                     val:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     93          unsigned char valc;
   \                     valc:
   \   00000000                      DS8 1
     94          
     95          /* Application input queues */

   \                                 In section .bss, align 4
     96          static anchor_t mMlmeNwkInputQueue;
   \                     mMlmeNwkInputQueue:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     97          static anchor_t mMcpsNwkInputQueue;
   \                     mMcpsNwkInputQueue:
   \   00000000                      DS8 8
     98          

   \                                 In section .data, align 1
     99          static tmrTimerID_t mTimer_c = gTmrInvalidTimerID_c;
   \                     mTimer_c:
   \   00000000   FF                 DC8 255
    100          
    101          /************************************************************************************
    102          *************************************************************************************
    103          * Public memory declarations
    104          *************************************************************************************
    105          ************************************************************************************/
    106          
    107          /* The current state of the applications state machine */

   \                                 In section .bss, align 1
    108          uint8_t gState;
   \                     gState:
   \   00000000                      DS8 1
    109          
    110          /* This data set contains application variables to be preserved across resets */

   \                                 In section .rodata, align 4
    111          NvDataItemDescription_t const gaNvAppDataSet[] = {
   \                     gaNvAppDataSet:
   \   00000000   00000000           DC32 0H
   \   00000004   0000               DC16 0
   \   00000006   0000               DC8 0, 0
    112            {NULL, 0}       /* Required end-of-table marker. */
    113          };
    114          
    115          /************************************************************************************
    116          *************************************************************************************
    117          * Public functions
    118          *************************************************************************************
    119          ************************************************************************************/
    120          
    121          void DeepSleepWakeupStackProc(void);
    122          
    123          /*****************************************************************************
    124          * Initialization function for the App Task. This is called during
    125          * initialization and should contain any application specific initialization
    126          * (ie. hardware initialization/setup, table initialization, power up
    127          * notificaiton.
    128          *
    129          * Interface assumptions: None
    130          *
    131          * Return value: None
    132          *
    133          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          void MApp_init(void)
    135          { 
   \                     MApp_init:
   \   00000000   80B5               PUSH     {R7,LR}
    136            
    137            /* The initial application state */
    138            gState = stateInit;  
   \   00000002   ....               LDR      R0,??DataTable0
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
    139            /* Reset number of pending packets */
    140            mcPendingPackets = 0;
   \   00000008   ....               LDR      R0,??DataTable0_1
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0170               STRB     R1,[R0, #+0]
    141            
    142            /* Allow sending a poll request */  
    143            mWaitPollConfirm = FALSE;    
   \   0000000E   ....               LDR      R0,??DataTable0_2
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0170               STRB     R1,[R0, #+0]
    144            
    145            /* Initialize the poll interval */
    146            mPollInterval = mDefaultValueOfPollIntervalSlow_c;
   \   00000014   ....               LDR      R0,??DataTable0_3
   \   00000016   CD21               MOVS     R1,#+205
   \   00000018   8900               LSLS     R1,R1,#+2        ;; #+820
   \   0000001A   0180               STRH     R1,[R0, #+0]
    147          
    148            /* Initialize the MAC 802.15.4 extended address */
    149            Init_MacExtendedAddress();
   \   0000001C   ........           BL       Init_MacExtendedAddress
    150            mTimer_c = TMR_AllocateTimer();
   \   00000020   ........           BL       TMR_AllocateTimer
   \   00000024   ....               LDR      R1,??DataTable0_4
   \   00000026   0870               STRB     R0,[R1, #+0]
    151            /* register keyboard callback function */
    152            KBD_Init(App_HandleKeys);
   \   00000028   ....               LDR      R0,??DataTable0_5
   \   0000002A   ........           BL       KBD_Init
    153            /* initialize LCD Module */
    154            LCD_Init();
    155            /* initialize LED Module */
    156            LED_Init();
   \   0000002E   ........           BL       LED_Init
    157            /* Initialize the UART so that we can print out status messages */
    158            /*Uart1_SetBaud(gUartDefaultBaud_c);
    159            Uart1_SetRxCallBack(UartRxCallBack);
    160            Uart2_SetBaud(gUartDefaultBaud_c);
    161            Uart2_SetRxCallBack(UartRxCallBack);*/
    162            
    163            UartX_SetBaud(gUartDefaultBaud_c);
   \   00000032   9620               MOVS     R0,#+150
   \   00000034   C001               LSLS     R0,R0,#+7        ;; #+19200
   \   00000036   ........           BL       Uart2_SetBaud
    164            UartX_SetRxCallBack(UartRxCallBack);
   \   0000003A   ....               LDR      R0,??DataTable0_6
   \   0000003C   ........           BL       Uart2_SetRxCallBack
    165            /* Prepare input queues.*/
    166            MSG_InitQueue(&mMlmeNwkInputQueue); 
   \   00000040   ....               LDR      R0,??DataTable0_7
   \   00000042   ........           BL       List_ClearAnchor
    167            MSG_InitQueue(&mMcpsNwkInputQueue);
   \   00000046   ....               LDR      R0,??DataTable0_8
   \   00000048   ........           BL       List_ClearAnchor
    168            /* Enable MCU interrupts */
    169            IntEnableAll();
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   ........           BL       IntRestoreAll
    170            /*signal app ready*/  
    171            Led1Flashing();
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   ........           BL       LED_StartFlash
    172            Led2Flashing();
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   ........           BL       LED_StartFlash
    173            Led3Flashing();
   \   0000005E   0420               MOVS     R0,#+4
   \   00000060   ........           BL       LED_StartFlash
    174            Led4Flashing();
   \   00000064   0820               MOVS     R0,#+8
   \   00000066   ........           BL       LED_StartFlash
    175              
    176            UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
   \   0000006A   0121               MOVS     R1,#+1
   \   0000006C   ....               LDR      R0,??DataTable0_9
   \   0000006E   ........           BL       UartUtil_Print
    177            LCD_ClearDisplay();
    178            LCD_WriteString(1,"Press any key");
   \   00000072   ....               LDR      R0,??DataTable0_10
    179            LCD_WriteString(2,"to start.");
   \   00000074   ....               LDR      R0,??DataTable1
    180          }
   \   00000076   09BC               POP      {R0,R3}
   \   00000078   1847               BX       R3               ;; return
    181          
    182          /*****************************************************************************
    183          *Mac Application Task event processor.  This function is called to
    184          * process all events for the task. Events include timers, messages and any
    185          * other user defined events
    186          *
    187          * Interface assumptions: None
    188          *
    189          * Return value: None
    190          *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    191          void AppTask(event_t events) 
    192          { 
   \                     AppTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    193          
    194            /* Pointer for storing the messages from MLME, MCPS, and ASP. */
    195            void *pMsgIn;
    196            /* Stores the status code returned by some functions. */
    197            uint8_t rc;  
    198            pMsgIn = NULL;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
    199            
    200            /* Dequeue the MLME message */
    201            if (events & gAppEvtMessageFromMLME_c)
   \   00000008   7007               LSLS     R0,R6,#+29
   \   0000000A   1DD5               BPL      ??AppTask_0
    202            {
    203              /* Get the message from MLME */
    204              pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
   \   0000000C   ....               LDR      R0,??DataTable2
   \   0000000E   ........           BL       List_RemoveHead
   \   00000012   0400               MOVS     R4,R0
    205              
    206              /* Any time a beacon might arrive. Always handle the beacon frame first */
    207              if (pMsgIn)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   17D0               BEQ      ??AppTask_0
    208              {               
    209                rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
   \   00000018   0421               MOVS     R1,#+4
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       App_WaitMsg
   \   00000020   0500               MOVS     R5,R0
    210                if(rc == errorNoError)
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   002D               CMP      R5,#+0
   \   00000028   0ED1               BNE      ??AppTask_0
    211                {
    212                  /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
    213                  /* ALSO the application can use the beacon payload.*/
    214                  MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   1030               ADDS     R0,R0,#+16
   \   0000002E   ........           BL       __aeabi_uread4
   \   00000032   ........           BL       MM_Free
   \   00000036   2100               MOVS     R1,R4
   \   00000038   1031               ADDS     R1,R1,#+16
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   ........           BL       __aeabi_uwrite4
    215                  UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ....               LDR      R0,??DataTable2_1
   \   00000044   ........           BL       UartUtil_Print
    216                }
    217              }
    218            }
    219            
    220            /* The application state machine */
    221            switch(gState)
   \                     ??AppTask_0:
   \   00000048   ....               LDR      R0,??DataTable1_1
   \   0000004A   0078               LDRB     R0,[R0, #+0]
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   0BD0               BEQ      ??AppTask_1
   \   00000050   0228               CMP      R0,#+2
   \   00000052   29D0               BEQ      ??AppTask_2
   \   00000054   15D3               BCC      ??AppTask_3
   \   00000056   0428               CMP      R0,#+4
   \   00000058   00D1               BNE      .+4
   \   0000005A   A9E0               B        ??AppTask_4
   \   0000005C   00D2               BCS      .+4
   \   0000005E   90E0               B        ??AppTask_5
   \   00000060   0528               CMP      R0,#+5
   \   00000062   00D1               BNE      .+4
   \   00000064   F8E0               B        ??AppTask_6
   \   00000066   13E1               B        ??AppTask_7
    222            {
    223            case stateInit:    
    224              /* Print a welcome message to the UART */
    225              UartUtil_Print("MyWirelessApp Demo Non Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);
   \                     ??AppTask_1:
   \   00000068   0121               MOVS     R1,#+1
   \   0000006A   ....               LDR      R0,??DataTable2_2
   \   0000006C   ........           BL       UartUtil_Print
    226              /* Goto Active Scan state. */
    227              gState = stateScanActiveStart;
   \   00000070   ....               LDR      R0,??DataTable1_1
   \   00000072   0121               MOVS     R1,#+1
   \   00000074   0170               STRB     R1,[R0, #+0]
    228              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
   \   00000076   0121               MOVS     R1,#+1
   \   00000078   ....               LDR      R0,??DataTable3
   \   0000007A   0078               LDRB     R0,[R0, #+0]
   \   0000007C   ........           BL       TS_SendEvent
   \   00000080   06E1               B        ??AppTask_7
    229              break;
    230              
    231            case stateScanActiveStart:
    232              /* Start the Active scan, and goto wait for confirm state. */
    233              UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
   \                     ??AppTask_3:
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   7148               LDR      R0,??AppTask_8
   \   00000086   ........           BL       UartUtil_Print
    234              /*print a message on the LCD also*/
    235              LCD_ClearDisplay();
    236              LCD_WriteString(1,"Start scanning");
   \   0000008A   7148               LDR      R0,??AppTask_8+0x4
    237              LCD_WriteString(2,"for coordinator");  
   \   0000008C   7148               LDR      R0,??AppTask_8+0x8
    238              rc = App_StartScan(gScanModeActive_c);
   \   0000008E   0120               MOVS     R0,#+1
   \   00000090   ........           BL       App_StartScan
   \   00000094   0500               MOVS     R5,R0
    239              if(rc == errorNoError)
   \   00000096   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000098   2D0E               LSRS     R5,R5,#+24
   \   0000009A   002D               CMP      R5,#+0
   \   0000009C   00D0               BEQ      .+4
   \   0000009E   F7E0               B        ??AppTask_7
    240              {
    241                gState = stateScanActiveWaitConfirm;
   \   000000A0   ....               LDR      R0,??DataTable1_1
   \   000000A2   0221               MOVS     R1,#+2
   \   000000A4   0170               STRB     R1,[R0, #+0]
   \   000000A6   F3E0               B        ??AppTask_7
    242              }
    243              break;
    244              
    245            case stateScanActiveWaitConfirm:
    246              /* Stay in this state until the Scan confirm message
    247                 arrives, and then goto the associate state. */
    248              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_2:
   \   000000A8   7007               LSLS     R0,R6,#+29
   \   000000AA   00D4               BMI      .+4
   \   000000AC   F0E0               B        ??AppTask_7
    249              {
    250                if (pMsgIn)
   \   000000AE   002C               CMP      R4,#+0
   \   000000B0   00D1               BNE      .+4
   \   000000B2   EDE0               B        ??AppTask_7
    251                {                     
    252                  rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
   \   000000B4   0B21               MOVS     R1,#+11
   \   000000B6   2000               MOVS     R0,R4
   \   000000B8   ........           BL       App_WaitMsg
   \   000000BC   0500               MOVS     R5,R0
    253                  if(rc == errorNoError)
   \   000000BE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000C0   2D0E               LSRS     R5,R5,#+24
   \   000000C2   002D               CMP      R5,#+0
   \   000000C4   00D0               BEQ      .+4
   \   000000C6   E3E0               B        ??AppTask_7
    254                  {
    255                    rc = App_HandleScanActiveConfirm(pMsgIn);
   \   000000C8   2000               MOVS     R0,R4
   \   000000CA   ........           BL       App_HandleScanActiveConfirm
   \   000000CE   0500               MOVS     R5,R0
    256                    if(rc == errorNoError)
   \   000000D0   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000D2   2D0E               LSRS     R5,R5,#+24
   \   000000D4   002D               CMP      R5,#+0
   \   000000D6   4DD1               BNE      ??AppTask_9
    257                    {
    258                      UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
   \   000000D8   0121               MOVS     R1,#+1
   \   000000DA   ....               LDR      R0,??DataTable1_2
   \   000000DC   ........           BL       UartUtil_Print
    259                      UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
   \   000000E0   0121               MOVS     R1,#+1
   \   000000E2   ....               LDR      R0,??DataTable2_3
   \   000000E4   ........           BL       UartUtil_Print
    260                      UartUtil_Print("\n\rAddress...........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
   \   000000E8   0121               MOVS     R1,#+1
   \   000000EA   ....               LDR      R0,??DataTable2_4
   \   000000EC   ........           BL       UartUtil_Print
   \   000000F0   ....               LDR      R0,??DataTable2_5
   \   000000F2   807A               LDRB     R0,[R0, #+10]
   \   000000F4   0228               CMP      R0,#+2
   \   000000F6   01D1               BNE      ??AppTask_10
   \   000000F8   0221               MOVS     R1,#+2
   \   000000FA   00E0               B        ??AppTask_11
   \                     ??AppTask_10:
   \   000000FC   0821               MOVS     R1,#+8
   \                     ??AppTask_11:
   \   000000FE   0022               MOVS     R2,#+0
   \   00000100   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000102   090E               LSRS     R1,R1,#+24
   \   00000104   ....               LDR      R0,??DataTable2_5
   \   00000106   ........           BL       UartUtil_PrintHex
    261                      UartUtil_Print("\n\rPAN ID............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
   \   0000010A   0121               MOVS     R1,#+1
   \   0000010C   ....               LDR      R0,??DataTable2_6
   \   0000010E   ........           BL       UartUtil_Print
   \   00000112   0022               MOVS     R2,#+0
   \   00000114   0221               MOVS     R1,#+2
   \   00000116   ....               LDR      R0,??DataTable2_5
   \   00000118   0830               ADDS     R0,R0,#+8
   \   0000011A   ........           BL       UartUtil_PrintHex
    262                      UartUtil_Print("\n\rLogical Channel...0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
   \   0000011E   0121               MOVS     R1,#+1
   \   00000120   ....               LDR      R0,??DataTable2_7
   \   00000122   ........           BL       UartUtil_Print
   \   00000126   0022               MOVS     R2,#+0
   \   00000128   0121               MOVS     R1,#+1
   \   0000012A   ....               LDR      R0,??DataTable2_5
   \   0000012C   0B30               ADDS     R0,R0,#+11
   \   0000012E   ........           BL       UartUtil_PrintHex
    263                      UartUtil_Print("\n\rBeacon Spec.......0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
   \   00000132   0121               MOVS     R1,#+1
   \   00000134   ....               LDR      R0,??DataTable2_8
   \   00000136   ........           BL       UartUtil_Print
   \   0000013A   0022               MOVS     R2,#+0
   \   0000013C   0221               MOVS     R1,#+2
   \   0000013E   ....               LDR      R0,??DataTable2_5
   \   00000140   0F30               ADDS     R0,R0,#+15
   \   00000142   ........           BL       UartUtil_PrintHex
    264                      UartUtil_Print("\n\rLink Quality......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
   \   00000146   0121               MOVS     R1,#+1
   \   00000148   ....               LDR      R0,??DataTable3_1
   \   0000014A   ........           BL       UartUtil_Print
   \   0000014E   0022               MOVS     R2,#+0
   \   00000150   0121               MOVS     R1,#+1
   \   00000152   ....               LDR      R0,??DataTable2_5
   \   00000154   1230               ADDS     R0,R0,#+18
   \   00000156   ........           BL       UartUtil_PrintHex
    265                      UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
   \   0000015A   0121               MOVS     R1,#+1
   \   0000015C   ....               LDR      R0,??DataTable3_2
   \   0000015E   ........           BL       UartUtil_Print
    266          
    267                      gState = stateAssociate;
   \   00000162   ....               LDR      R0,??DataTable1_1
   \   00000164   0321               MOVS     R1,#+3
   \   00000166   0170               STRB     R1,[R0, #+0]
    268                      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   00000168   0121               MOVS     R1,#+1
   \   0000016A   ....               LDR      R0,??DataTable3
   \   0000016C   0078               LDRB     R0,[R0, #+0]
   \   0000016E   ........           BL       TS_SendEvent
   \   00000172   8DE0               B        ??AppTask_7
    269                    }
    270                    else
    271          		      {
    272                      UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
   \                     ??AppTask_9:
   \   00000174   0121               MOVS     R1,#+1
   \   00000176   ....               LDR      R0,??DataTable3_3
   \   00000178   ........           BL       UartUtil_Print
    273                      /*print a message on the LCD also*/
    274                      LCD_ClearDisplay();
    275                      LCD_WriteString(1,"No coordinator");
   \   0000017C   ....               LDR      R0,??DataTable3_4
    276                      LCD_WriteString(2,"found.");
   \   0000017E   ....               LDR      R0,??DataTable3_5
   \   00000180   86E0               B        ??AppTask_7
    277          		      }
    278          		    }
    279                }
    280              }
    281              break;
    282          
    283            case stateAssociate:
    284              /* Associate to the PAN coordinator */
    285              UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
   \                     ??AppTask_5:
   \   00000182   0121               MOVS     R1,#+1
   \   00000184   ....               LDR      R0,??DataTable3_6
   \   00000186   ........           BL       UartUtil_Print
    286              UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
   \   0000018A   0222               MOVS     R2,#+2
   \   0000018C   0121               MOVS     R1,#+1
   \   0000018E   ....               LDR      R0,??DataTable2_5
   \   00000190   0B30               ADDS     R0,R0,#+11
   \   00000192   ........           BL       UartUtil_PrintHex
    287              /*print a message on the LCD also*/
    288              LCD_ClearDisplay();
    289              LCD_WriteString(1,"Associating to ");
   \   00000196   ....               LDR      R0,??DataTable3_7
    290              LCD_WriteString(2,"PAN coordinator");  
   \   00000198   ....               LDR      R0,??DataTable3_8
    291              rc = App_SendAssociateRequest();
   \   0000019A   ........           BL       App_SendAssociateRequest
   \   0000019E   0500               MOVS     R5,R0
    292              if(rc == errorNoError)
   \   000001A0   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001A2   2D0E               LSRS     R5,R5,#+24
   \   000001A4   002D               CMP      R5,#+0
   \   000001A6   73D1               BNE      ??AppTask_7
    293                gState = stateAssociateWaitConfirm;
   \   000001A8   ....               LDR      R0,??DataTable1_1
   \   000001AA   0421               MOVS     R1,#+4
   \   000001AC   0170               STRB     R1,[R0, #+0]
   \   000001AE   6FE0               B        ??AppTask_7
    294              break; 
    295          
    296            case stateAssociateWaitConfirm:
    297              /* Stay in this state until the Associate confirm message
    298                 arrives, and then goto the Listen state. */
    299              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_4:
   \   000001B0   7007               LSLS     R0,R6,#+29
   \   000001B2   6DD5               BPL      ??AppTask_7
    300              {
    301                if (pMsgIn)
   \   000001B4   002C               CMP      R4,#+0
   \   000001B6   6BD0               BEQ      ??AppTask_7
    302                {   
    303                  rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);
   \   000001B8   0121               MOVS     R1,#+1
   \   000001BA   2000               MOVS     R0,R4
   \   000001BC   ........           BL       App_WaitMsg
   \   000001C0   0500               MOVS     R5,R0
    304                  if(rc == errorNoError)
   \   000001C2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001C4   2D0E               LSRS     R5,R5,#+24
   \   000001C6   002D               CMP      R5,#+0
   \   000001C8   62D1               BNE      ??AppTask_7
    305                  {          
    306                    rc = App_HandleAssociateConfirm(pMsgIn);
   \   000001CA   2000               MOVS     R0,R4
   \   000001CC   ........           BL       App_HandleAssociateConfirm
   \   000001D0   0500               MOVS     R5,R0
    307                    if (rc == errorNoError)
   \   000001D2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001D4   2D0E               LSRS     R5,R5,#+24
   \   000001D6   002D               CMP      R5,#+0
   \   000001D8   2AD1               BNE      ??AppTask_12
    308                    { 
    309          	          UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
   \   000001DA   0121               MOVS     R1,#+1
   \   000001DC   ....               LDR      R0,??DataTable4
   \   000001DE   ........           BL       UartUtil_Print
    310          	          UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
   \   000001E2   0121               MOVS     R1,#+1
   \   000001E4   ....               LDR      R0,??DataTable4_1
   \   000001E6   ........           BL       UartUtil_Print
    311          	          UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
   \   000001EA   ....               LDR      R0,??DataTable4_2
   \   000001EC   0078               LDRB     R0,[R0, #+0]
   \   000001EE   0228               CMP      R0,#+2
   \   000001F0   01D1               BNE      ??AppTask_13
   \   000001F2   0221               MOVS     R1,#+2
   \   000001F4   00E0               B        ??AppTask_14
   \                     ??AppTask_13:
   \   000001F6   0821               MOVS     R1,#+8
   \                     ??AppTask_14:
   \   000001F8   0022               MOVS     R2,#+0
   \   000001FA   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001FC   090E               LSRS     R1,R1,#+24
   \   000001FE   ....               LDR      R0,??DataTable4_3
   \   00000200   ........           BL       UartUtil_PrintHex
    312          	          UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
   \   00000204   0121               MOVS     R1,#+1
   \   00000206   ....               LDR      R0,??DataTable4_4
   \   00000208   ........           BL       UartUtil_Print
    313          	          /*print a message on the LCD also*/
    314          	          LCD_ClearDisplay();
    315          	          LCD_WriteString(1,"Ready to send");
   \   0000020C   ....               LDR      R0,??DataTable4_5
    316          	          LCD_WriteString(2,"and receive data");    
   \   0000020E   ....               LDR      R0,??DataTable4_6
    317          	          /* Startup the timer */
    318          	          TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
   \   00000210   ....               LDR      R2,??DataTable4_7
   \   00000212   ....               LDR      R0,??DataTable4_8
   \   00000214   0188               LDRH     R1,[R0, #+0]
   \   00000216   ....               LDR      R0,??DataTable4_9
   \   00000218   0078               LDRB     R0,[R0, #+0]
   \   0000021A   ........           BL       TMR_StartSingleShotTimer
    319          	          /* Go to the listen state */
    320          	          gState = stateListen;
   \   0000021E   ....               LDR      R0,??DataTable1_1
   \   00000220   0521               MOVS     R1,#+5
   \   00000222   0170               STRB     R1,[R0, #+0]
    321          	          TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c); 
   \   00000224   0121               MOVS     R1,#+1
   \   00000226   ....               LDR      R0,??DataTable3
   \   00000228   0078               LDRB     R0,[R0, #+0]
   \   0000022A   ........           BL       TS_SendEvent
   \   0000022E   2FE0               B        ??AppTask_7
    322                    }        
    323                    else 
    324                    {
    325                    
    326          	          UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
   \                     ??AppTask_12:
   \   00000230   0121               MOVS     R1,#+1
   \   00000232   ....               LDR      R0,??DataTable5
   \   00000234   ........           BL       UartUtil_Print
    327          	          gState = stateScanActiveStart;
   \   00000238   ....               LDR      R0,??DataTable1_1
   \   0000023A   0121               MOVS     R1,#+1
   \   0000023C   0170               STRB     R1,[R0, #+0]
    328                        TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   0000023E   0121               MOVS     R1,#+1
   \   00000240   ....               LDR      R0,??DataTable3
   \   00000242   0078               LDRB     R0,[R0, #+0]
   \   00000244   ........           BL       TS_SendEvent
   \   00000248   22E0               B        ??AppTask_7
   \   0000024A   C046               Nop      
   \                     ??AppTask_8:
   \   0000024C   ........           DC32     `?<Constant "Start scanning for a ...">`
   \   00000250   ........           DC32     `?<Constant "Start scanning">`
   \   00000254   ........           DC32     `?<Constant "for coordinator">`
    329                    }
    330                  }
    331                }
    332              }
    333              break; 
    334              
    335            case stateListen:
    336              /* Transmit to coordinator data received from UART. */
    337              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_6:
   \   00000258   7007               LSLS     R0,R6,#+29
   \   0000025A   05D5               BPL      ??AppTask_15
    338              {  
    339                if (pMsgIn)
   \   0000025C   002C               CMP      R4,#+0
   \   0000025E   03D0               BEQ      ??AppTask_15
    340                {  
    341                  /* Process it */
    342                  rc = App_HandleMlmeInput(pMsgIn);
   \   00000260   2000               MOVS     R0,R4
   \   00000262   ........           BL       App_HandleMlmeInput
   \   00000266   0500               MOVS     R5,R0
    343                }
    344              } 
    345              
    346              if (events & gAppEvtRxFromUart_c)
   \                     ??AppTask_15:
   \   00000268   B007               LSLS     R0,R6,#+30
   \   0000026A   11D5               BPL      ??AppTask_7
    347              {      
    348                /* get byte from UART */
    349                //App_TransmitUartData();
    350                if(gUart2_Enabled_d == TRUE)
    351                {
    352                if(Uart2_GetByteFromRxBuffer((uint8_t*)&val))
   \   0000026C   ....               LDR      R0,??DataTable6
   \   0000026E   ........           BL       Uart2_GetByteFromRxBuffer
   \   00000272   0028               CMP      R0,#+0
   \   00000274   0CD0               BEQ      ??AppTask_7
    353                {
    354                  valc=(unsigned char)(val -'0');
   \   00000276   ....               LDR      R0,??DataTable6
   \   00000278   0078               LDRB     R0,[R0, #+0]
   \   0000027A   3038               SUBS     R0,R0,#+48
   \   0000027C   ....               LDR      R1,??DataTable6_1
   \   0000027E   0870               STRB     R0,[R1, #+0]
    355                  UartUtil_Tx((unsigned char*)&val, sizeof(val));
   \   00000280   0121               MOVS     R1,#+1
   \   00000282   ....               LDR      R0,??DataTable6
   \   00000284   ........           BL       UartUtil_Tx
    356                  App_TransmitUart2Data(val);
   \   00000288   ....               LDR      R0,??DataTable6
   \   0000028A   0078               LDRB     R0,[R0, #+0]
   \   0000028C   ........           BL       App_TransmitUart2Data
    357                }
    358                 //UartUtil_Print("Uart2 is enabled ..\n\r", gAllowToBlock_d);
    359                }
    360                else if(Uart2_GetByteFromRxBuffer == 0)
    361                {
    362                  UartUtil_Print("Not Enabled Uart2 .. buffer is empty\n\r", gAllowToBlock_d);
    363                }
    364                else
    365                {
    366                  UartUtil_Print("Not Enabled Uart2 .. secondo controllo\n\r", gAllowToBlock_d);
    367                }
    368                  
    369                /*
    370                 LCD_ClearDisplay();
    371                 LCD_WriteString(1,"Ready to send");
    372                 LCD_WriteString(2,"and receive data");  */
    373              }  
    374              break;
    375            }
    376            
    377            if (pMsgIn)
   \                     ??AppTask_7:
   \   00000290   002C               CMP      R4,#+0
   \   00000292   04D0               BEQ      ??AppTask_16
    378            {
    379              /* Messages must always be freed. */ 
    380              MSG_Free(pMsgIn);
   \   00000294   2000               MOVS     R0,R4
   \   00000296   ........           BL       MM_Free
   \   0000029A   0020               MOVS     R0,#+0
   \   0000029C   0400               MOVS     R4,R0
    381            }
    382            
    383             /* Handle MCPS confirms and transmit data from UART */
    384            if (events & gAppEvtMessageFromMCPS_c)
   \                     ??AppTask_16:
   \   0000029E   3007               LSLS     R0,R6,#+28
   \   000002A0   0DD5               BPL      ??AppTask_17
    385            {      
    386              /* Get the message from MCPS */
    387              pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
   \   000002A2   ....               LDR      R0,??DataTable7
   \   000002A4   ........           BL       List_RemoveHead
   \   000002A8   0400               MOVS     R4,R0
    388              if (pMsgIn)
   \   000002AA   002C               CMP      R4,#+0
   \   000002AC   07D0               BEQ      ??AppTask_17
    389              {              
    390                /* Process it */
    391                App_HandleMcpsInput(pMsgIn);
   \   000002AE   2000               MOVS     R0,R4
   \   000002B0   ........           BL       App_HandleMcpsInput
    392                /* Messages from the MCPS must always be freed. */
    393                MSG_Free(pMsgIn);
   \   000002B4   2000               MOVS     R0,R4
   \   000002B6   ........           BL       MM_Free
   \   000002BA   0020               MOVS     R0,#+0
   \   000002BC   0400               MOVS     R4,R0
    394              }
    395            }
    396            
    397            /* Check for pending messages in the Queue */ 
    398            if(MSG_Pending(&mMcpsNwkInputQueue))
   \                     ??AppTask_17:
   \   000002BE   ....               LDR      R0,??DataTable7
   \   000002C0   0068               LDR      R0,[R0, #+0]
   \   000002C2   0028               CMP      R0,#+0
   \   000002C4   04D0               BEQ      ??AppTask_18
    399              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   000002C6   0821               MOVS     R1,#+8
   \   000002C8   ....               LDR      R0,??DataTable3
   \   000002CA   0078               LDRB     R0,[R0, #+0]
   \   000002CC   ........           BL       TS_SendEvent
    400            if(MSG_Pending(&mMlmeNwkInputQueue))
   \                     ??AppTask_18:
   \   000002D0   ....               LDR      R0,??DataTable2
   \   000002D2   0068               LDR      R0,[R0, #+0]
   \   000002D4   0028               CMP      R0,#+0
   \   000002D6   04D0               BEQ      ??AppTask_19
    401              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
   \   000002D8   0421               MOVS     R1,#+4
   \   000002DA   ....               LDR      R0,??DataTable3
   \   000002DC   0078               LDRB     R0,[R0, #+0]
   \   000002DE   ........           BL       TS_SendEvent
    402          }
   \                     ??AppTask_19:
   \   000002E2   70BC               POP      {R4-R6}
   \   000002E4   08BC               POP      {R3}
   \   000002E6   1847               BX       R3               ;; return
    403          
    404          /************************************************************************************
    405          *************************************************************************************
    406          * Private functions
    407          *************************************************************************************
    408          ************************************************************************************/
    409          
    410          /*****************************************************************************
    411          * UartRxCallBack
    412          *
    413          * This callback is triggered when a new byte is received over the UART
    414          *
    415          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    416          static void UartRxCallBack(void) 
    417          {
   \                     UartRxCallBack:
   \   00000000   80B5               PUSH     {R7,LR}
    418            uint8_t pressedKey;
    419          	if(stateListen == gState){
   \   00000002   ....               LDR      R0,??DataTable8
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0528               CMP      R0,#+5
   \   00000008   05D1               BNE      ??UartRxCallBack_0
    420              TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   ....               LDR      R0,??DataTable3
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   ........           BL       TS_SendEvent
   \   00000014   02E0               B        ??UartRxCallBack_1
    421            }else{
    422          	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
   \                     ??UartRxCallBack_0:
   \   00000016   6846               MOV      R0,SP
   \   00000018   ........           BL       Uart2_GetByteFromRxBuffer
    423            }
    424          }
   \                     ??UartRxCallBack_1:
   \   0000001C   09BC               POP      {R0,R3}
   \   0000001E   1847               BX       R3               ;; return
    425          
    426          /******************************************************************************
    427          * The App_StartScan(scanType) function will start the scan process of the
    428          * specified type in the MAC. This is accomplished by allocating a MAC message,
    429          * which is then assigned the desired scan parameters and sent to the MLME
    430          * service access point.
    431          * The function may return either of the following values:
    432          *   errorNoError:          The Scan message was sent successfully.
    433          *   errorInvalidParameter: The MLME service access point rejected the
    434          *                          message due to an invalid parameter.
    435          *   errorAllocFailed:      A message buffer could not be allocated.
    436          *
    437          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    438          static uint8_t App_StartScan(uint8_t scanType)
    439          {
   \                     App_StartScan:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    440            mlmeMessage_t *pMsg;
    441            mlmeScanReq_t *pScanReq;
    442          
    443            UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   ....               LDR      R0,??DataTable8_1
   \   00000008   ........           BL       UartUtil_Print
    444          
    445            /* Allocate a message for the MLME (We should check for NULL). */
    446            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000C   0F20               MOVS     R0,#+15
   \   0000000E   ........           BL       MM_Alloc
   \   00000012   0400               MOVS     R4,R0
    447            if(pMsg != NULL)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   20D0               BEQ      ??App_StartScan_0
    448            {
    449              /* This is a MLME-SCAN.req command */
    450              pMsg->msgType = gMlmeScanReq_c;
   \   00000018   0820               MOVS     R0,#+8
   \   0000001A   2070               STRB     R0,[R4, #+0]
    451              /* Create the Scan request message data. */
    452              pScanReq = &pMsg->msgData.scanReq;
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   0500               MOVS     R5,R0
    453              /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
    454              pScanReq->scanType = scanType;
   \   00000022   2E70               STRB     R6,[R5, #+0]
    455              /* ChannelsToScan & 0xFF - LSB, always 0x00 */
    456              pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   6870               STRB     R0,[R5, #+1]
    457              /* ChannelsToScan>>8 & 0xFF  */
    458              pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
   \   00000028   8020               MOVS     R0,#+128
   \   0000002A   A870               STRB     R0,[R5, #+2]
    459              /* ChannelsToScan>>16 & 0xFF  */
    460              pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   E870               STRB     R0,[R5, #+3]
    461              /* ChannelsToScan>>24 & 0xFF - MSB */
    462              pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   2871               STRB     R0,[R5, #+4]
    463              /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
    464                 A scan duration of 3 on 16 channels approximately takes 2 secs. */
    465              pScanReq->scanDuration = 3;
   \   00000034   0320               MOVS     R0,#+3
   \   00000036   6871               STRB     R0,[R5, #+5]
    466          #ifdef gMAC2006_d
    467          	pScanReq->securityLevel = 0;
    468          #endif //gMAC2006_d	
    469              
    470              /* Send the Scan request to the MLME. */
    471              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       NWK_MLME_SapHandler
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   05D1               BNE      ??App_StartScan_1
    472              {
    473                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000042   0121               MOVS     R1,#+1
   \   00000044   ....               LDR      R0,??DataTable8_2
   \   00000046   ........           BL       UartUtil_Print
    474                return errorNoError;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   0AE0               B        ??App_StartScan_2
    475              }
    476              else
    477              {
    478                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_1:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR      R0,??DataTable8_3
   \   00000052   ........           BL       UartUtil_Print
    479                return errorInvalidParameter;
   \   00000056   0520               MOVS     R0,#+5
   \   00000058   04E0               B        ??App_StartScan_2
    480              }
    481            }
    482            else
    483            {
    484              /* Allocation of a message buffer failed. */
    485              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_0:
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR      R0,??DataTable8_4
   \   0000005E   ........           BL       UartUtil_Print
    486              return errorAllocFailed;
   \   00000062   0420               MOVS     R0,#+4
   \                     ??App_StartScan_2:
   \   00000064   70BC               POP      {R4-R6}
   \   00000066   08BC               POP      {R3}
   \   00000068   1847               BX       R3               ;; return
    487            }
    488          }
    489          
    490          /******************************************************************************
    491          * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
    492          * Active Scan confirm message received from the MLME when the Active scan has
    493          * completed. The message contains a list of PAN descriptors. Based on link
    494          * quality inforamtion in the pan descriptors the nearest coordinator is chosen.
    495          * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
    496          *
    497          * The function may return either of the following values:
    498          *   errorNoError:       A suitable pan descriptor was found.
    499          *   errorNoScanResults: No scan results were present in the confirm message.
    500          *
    501          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    502          static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
    503          {
   \                     App_HandleScanActiveConfirm:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    504            void    *pBlock;
    505            uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
   \   00000004   6846               MOV      R0,SP
   \   00000006   0299               LDR      R1,[SP, #+8]
   \   00000008   C978               LDRB     R1,[R1, #+3]
   \   0000000A   4170               STRB     R1,[R0, #+1]
    506            uint8_t rc = errorNoScanResults;
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   0621               MOVS     R1,#+6
   \   00000010   0170               STRB     R1,[R0, #+0]
    507            uint8_t j;
    508            uint8_t bestLinkQuality = 0;  
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   0700               MOVS     R7,R0
    509            panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
   \   00000016   0298               LDR      R0,[SP, #+8]
   \   00000018   0830               ADDS     R0,R0,#+8
   \   0000001A   ........           BL       __aeabi_uread4
   \   0000001E   0600               MOVS     R6,R0
    510            panDescriptor_t *pPanDesc;    
    511            
    512           
    513            /* Check if the scan resulted in any coordinator responses. */  
    514            
    515            if (panDescListSize > 0)
   \   00000020   6846               MOV      R0,SP
   \   00000022   4078               LDRB     R0,[R0, #+1]
   \   00000024   0128               CMP      R0,#+1
   \   00000026   34D3               BCC      ??App_HandleScanActiveConfirm_0
    516            {    
    517              /* Check all PAN descriptors. */
    518              while (NULL != pDescBlock)
   \                     ??App_HandleScanActiveConfirm_1:
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   32D0               BEQ      ??App_HandleScanActiveConfirm_0
    519              {
    520                for (j = 0; j < pDescBlock->descriptorCount; j++)
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0400               MOVS     R4,R0
   \                     ??App_HandleScanActiveConfirm_2:
   \   00000030   6E20               MOVS     R0,#+110
   \   00000032   305C               LDRB     R0,[R6, R0]
   \   00000034   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000036   240E               LSRS     R4,R4,#+24
   \   00000038   8442               CMP      R4,R0
   \   0000003A   1ED2               BCS      ??App_HandleScanActiveConfirm_3
    521                {            
    522                  pPanDesc = &pDescBlock->descriptorList[j];
   \   0000003C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000003E   240E               LSRS     R4,R4,#+24
   \   00000040   1620               MOVS     R0,#+22
   \   00000042   6043               MULS     R0,R4,R0
   \   00000044   3018               ADDS     R0,R6,R0
   \   00000046   0500               MOVS     R5,R0
    523          
    524                  /* Only attempt to associate if the coordinator
    525                     accepts associations and is non-beacon. */
    526                  if( ( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) && 
    527                      ((pPanDesc->superFrameSpec[0] & gSuperFrameSpecLsbBO_c) == 0x0F) )
   \   00000048   287C               LDRB     R0,[R5, #+16]
   \   0000004A   0006               LSLS     R0,R0,#+24
   \   0000004C   13D5               BPL      ??App_HandleScanActiveConfirm_4
   \   0000004E   E87B               LDRB     R0,[R5, #+15]
   \   00000050   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000052   000F               LSRS     R0,R0,#+28
   \   00000054   0F28               CMP      R0,#+15
   \   00000056   0ED1               BNE      ??App_HandleScanActiveConfirm_4
    528                  {        
    529                    
    530                    /* Find the nearest coordinator using the link quality measure. */
    531                    if(pPanDesc->linkQuality > bestLinkQuality)
   \   00000058   A87C               LDRB     R0,[R5, #+18]
   \   0000005A   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000005C   3F0E               LSRS     R7,R7,#+24
   \   0000005E   8742               CMP      R7,R0
   \   00000060   09D2               BCS      ??App_HandleScanActiveConfirm_4
    532                    {
    533                      /* Save the information of the coordinator candidate. If we
    534                         find a better candiate, the information will be replaced. */
    535                      FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
   \   00000062   1622               MOVS     R2,#+22
   \   00000064   2900               MOVS     R1,R5
   \   00000066   ....               LDR      R0,??DataTable10
   \   00000068   ........           BL       FLib_MemCpy
    536                      bestLinkQuality = pPanDesc->linkQuality;
   \   0000006C   A87C               LDRB     R0,[R5, #+18]
   \   0000006E   0700               MOVS     R7,R0
    537                      rc = errorNoError;
   \   00000070   6846               MOV      R0,SP
   \   00000072   0021               MOVS     R1,#+0
   \   00000074   0170               STRB     R1,[R0, #+0]
    538                    }
    539                  }      
    540                }
   \                     ??App_HandleScanActiveConfirm_4:
   \   00000076   641C               ADDS     R4,R4,#+1
   \   00000078   DAE7               B        ??App_HandleScanActiveConfirm_2
    541                
    542                /* Free current block */
    543                pBlock = pDescBlock;
   \                     ??App_HandleScanActiveConfirm_3:
   \   0000007A   0196               STR      R6,[SP, #+4]
    544                pDescBlock = pDescBlock->pNext;              
   \   0000007C   6F36               ADDS     R6,R6,#+111
   \   0000007E   3000               MOVS     R0,R6
   \   00000080   ........           BL       __aeabi_uread4
   \   00000084   0600               MOVS     R6,R0
    545                MSG_Free(pBlock);
   \   00000086   0198               LDR      R0,[SP, #+4]
   \   00000088   ........           BL       MM_Free
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   0190               STR      R0,[SP, #+4]
   \   00000090   CAE7               B        ??App_HandleScanActiveConfirm_1
    546              }
    547            }
    548            
    549            if (pDescBlock)
   \                     ??App_HandleScanActiveConfirm_0:
   \   00000092   002E               CMP      R6,#+0
   \   00000094   04D0               BEQ      ??App_HandleScanActiveConfirm_5
    550                MSG_Free(pDescBlock);
   \   00000096   3000               MOVS     R0,R6
   \   00000098   ........           BL       MM_Free
   \   0000009C   0020               MOVS     R0,#+0
   \   0000009E   0600               MOVS     R6,R0
    551            
    552            return rc;
   \                     ??App_HandleScanActiveConfirm_5:
   \   000000A0   6846               MOV      R0,SP
   \   000000A2   0078               LDRB     R0,[R0, #+0]
   \   000000A4   FEBC               POP      {R1-R7}
   \   000000A6   08BC               POP      {R3}
   \   000000A8   1847               BX       R3               ;; return
    553          }
    554          
    555          /******************************************************************************
    556          * The App_SendAssociateRequest(void) will create an Associate Request message
    557          * and send it to the coordinator it wishes to associate to. The function uses
    558          * information gained about the coordinator during the scan procedure.
    559          *
    560          * The function may return either of the following values:
    561          *   errorNoError:          The Associate Request message was sent successfully.
    562          *   errorInvalidParameter: The MLME service access point rejected the
    563          *                          message due to an invalid parameter.
    564          *   errorAllocFailed:      A message buffer could not be allocated.
    565          *
    566          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    567          static uint8_t App_SendAssociateRequest(void)
    568          {
   \                     App_SendAssociateRequest:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    569            mlmeMessage_t *pMsg;
    570            mlmeAssociateReq_t *pAssocReq;
    571          
    572            UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ....               LDR      R0,??DataTable9
   \   00000006   ........           BL       UartUtil_Print
    573            
    574            /* Allocate a message for the MLME message. */
    575            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000A   0F20               MOVS     R0,#+15
   \   0000000C   ........           BL       MM_Alloc
   \   00000010   0500               MOVS     R5,R0
    576            if(pMsg != NULL)
   \   00000012   002D               CMP      R5,#+0
   \   00000014   2BD0               BEQ      ??App_SendAssociateRequest_0
    577            {
    578              /* This is a MLME-ASSOCIATE.req command. */
    579              pMsg->msgType = gMlmeAssociateReq_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   2870               STRB     R0,[R5, #+0]
    580              
    581              /* Create the Associate request message data. */
    582              pAssocReq = &pMsg->msgData.associateReq;
   \   0000001A   2800               MOVS     R0,R5
   \   0000001C   401C               ADDS     R0,R0,#+1
   \   0000001E   0400               MOVS     R4,R0
    583           
    584              /* Use the coordinator info we got from the Active Scan. */
    585              FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
   \   00000020   0822               MOVS     R2,#+8
   \   00000022   ....               LDR      R1,??DataTable10
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       FLib_MemCpy
    586              FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
   \   0000002A   0222               MOVS     R2,#+2
   \   0000002C   ....               LDR      R1,??DataTable10
   \   0000002E   0831               ADDS     R1,R1,#+8
   \   00000030   2000               MOVS     R0,R4
   \   00000032   0830               ADDS     R0,R0,#+8
   \   00000034   ........           BL       FLib_MemCpy
    587              pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
   \   00000038   ....               LDR      R0,??DataTable10
   \   0000003A   807A               LDRB     R0,[R0, #+10]
   \   0000003C   A072               STRB     R0,[R4, #+10]
    588              pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
   \   0000003E   ....               LDR      R0,??DataTable10
   \   00000040   C07A               LDRB     R0,[R0, #+11]
   \   00000042   E072               STRB     R0,[R4, #+11]
    589          #ifdef gMAC2006_d
    590          	pAssocReq->securityLevel = 0;
    591          #else	
    592              pAssocReq->securityEnable     = FALSE;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   2073               STRB     R0,[R4, #+12]
    593          #endif //gMAC2006_d	
    594              /* We want the coordinator to assign a short address to us. */
    595              pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
   \   00000048   8020               MOVS     R0,#+128
   \   0000004A   6073               STRB     R0,[R4, #+13]
    596                
    597              /* Send the Associate Request to the MLME. */
    598              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   0000004C   2800               MOVS     R0,R5
   \   0000004E   ........           BL       NWK_MLME_SapHandler
   \   00000052   0028               CMP      R0,#+0
   \   00000054   05D1               BNE      ??App_SendAssociateRequest_1
    599              {
    600                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   ....               LDR      R0,??DataTable8_2
   \   0000005A   ........           BL       UartUtil_Print
    601                return errorNoError;
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   0AE0               B        ??App_SendAssociateRequest_2
    602              }
    603              else
    604              {
    605                /* One or more parameters in the message were invalid. */
    606                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateRequest_1:
   \   00000062   0121               MOVS     R1,#+1
   \   00000064   ....               LDR      R0,??DataTable8_3
   \   00000066   ........           BL       UartUtil_Print
    607                return errorInvalidParameter;
   \   0000006A   0520               MOVS     R0,#+5
   \   0000006C   04E0               B        ??App_SendAssociateRequest_2
    608              }
    609            }
    610            else
    611            {
    612              /* Allocation of a message buffer failed. */
    613              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateRequest_0:
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   ....               LDR      R0,??DataTable8_4
   \   00000072   ........           BL       UartUtil_Print
    614              return errorAllocFailed;
   \   00000076   0420               MOVS     R0,#+4
   \                     ??App_SendAssociateRequest_2:
   \   00000078   32BC               POP      {R1,R4,R5}
   \   0000007A   08BC               POP      {R3}
   \   0000007C   1847               BX       R3               ;; return
    615            }
    616          }
    617          
    618          /******************************************************************************
    619          * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
    620          * Associate confirm message received from the MLME when the Association
    621          * procedure has completed. The message contains the short address that the
    622          * coordinator has assigned to us. This address is 0xfffe if we did not specify
    623          * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
    624          * request. The address and address mode are saved in global variables. They
    625          * will be used in the next demo application when sending data.
    626          *
    627          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    628          static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
    629          {
   \                     App_HandleAssociateConfirm:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    630            /* This is our own extended address (MAC address). It cannot be modified. */
    631            extern uint8_t aExtendedAddress[8];
    632            
    633            /* If the coordinator assigns a short address of 0xfffe then,
    634               that means we must use our own extended address in all
    635               communications with the coordinator. Otherwise, we use
    636               the short address assigned to us. */
    637            if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
   \   00000004   E078               LDRB     R0,[R4, #+3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   19D1               BNE      ??App_HandleAssociateConfirm_0
    638            {
    639          
    640          	  if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
    641          	      (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
   \   0000000A   6078               LDRB     R0,[R4, #+1]
   \   0000000C   FE28               CMP      R0,#+254
   \   0000000E   0BD3               BCC      ??App_HandleAssociateConfirm_1
   \   00000010   A078               LDRB     R0,[R4, #+2]
   \   00000012   FF28               CMP      R0,#+255
   \   00000014   08D1               BNE      ??App_HandleAssociateConfirm_1
    642          	  {
    643          	    mAddrMode = gAddrModeLong_c;
   \   00000016   ....               LDR      R0,??DataTable12
   \   00000018   0321               MOVS     R1,#+3
   \   0000001A   0170               STRB     R1,[R0, #+0]
    644          	    FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
   \   0000001C   0822               MOVS     R2,#+8
   \   0000001E   ....               LDR      R1,??DataTable11
   \   00000020   ....               LDR      R0,??DataTable13
   \   00000022   ........           BL       FLib_MemCpy
   \   00000026   08E0               B        ??App_HandleAssociateConfirm_2
    645          	  }
    646          	  else
    647          	  {
    648          	    mAddrMode = gAddrModeShort_c;
   \                     ??App_HandleAssociateConfirm_1:
   \   00000028   ....               LDR      R0,??DataTable12
   \   0000002A   0221               MOVS     R1,#+2
   \   0000002C   0170               STRB     R1,[R0, #+0]
    649          	    FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
   \   0000002E   0222               MOVS     R2,#+2
   \   00000030   2100               MOVS     R1,R4
   \   00000032   491C               ADDS     R1,R1,#+1
   \   00000034   ....               LDR      R0,??DataTable13
   \   00000036   ........           BL       FLib_MemCpy
    650          	  }
    651          	    return gSuccess_c;
   \                     ??App_HandleAssociateConfirm_2:
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   00E0               B        ??App_HandleAssociateConfirm_3
    652            } 
    653            
    654            else 
    655            {
    656          	return pMsg->msgData.associateCnf.status; 
   \                     ??App_HandleAssociateConfirm_0:
   \   0000003E   E078               LDRB     R0,[R4, #+3]
   \                     ??App_HandleAssociateConfirm_3:
   \   00000040   10BC               POP      {R4}
   \   00000042   08BC               POP      {R3}
   \   00000044   1847               BX       R3               ;; return
    657            }
    658          }
    659          /******************************************************************************
    660          * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
    661          * messages from the MLME, e.g. poll confirm.
    662          *
    663          * The function may return either of the following values:
    664          *   errorNoError:   The message was processed.
    665          *   errorNoMessage: The message pointer is NULL.
    666          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    667          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
    668          {
   \                     App_HandleMlmeInput:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
    669            if(pMsg == NULL)
   \   00000004   0029               CMP      R1,#+0
   \   00000006   01D1               BNE      ??App_HandleMlmeInput_0
    670              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   0DE0               B        ??App_HandleMlmeInput_1
    671            
    672            /* Handle the incoming message. The type determines the sort of processing.*/
    673            switch(pMsg->msgType) {
   \                     ??App_HandleMlmeInput_0:
   \   0000000C   0878               LDRB     R0,[R1, #+0]
   \   0000000E   1028               CMP      R0,#+16
   \   00000010   09D1               BNE      ??App_HandleMlmeInput_2
    674            case gNwkPollCnf_c:
    675              if(pMsg->msgData.pollCnf.status != gSuccess_c)
   \   00000012   4878               LDRB     R0,[R1, #+1]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   06D0               BEQ      ??App_HandleMlmeInput_2
    676              {
    677                /* The Poll Confirm status was not successful. Usually this happens if
    678                   no data was available at the coordinator. In this case we start
    679                   polling at a lower rate to conserve power. */
    680                mPollInterval = mDefaultValueOfPollIntervalSlow_c;
   \   00000018   ....               LDR      R0,??DataTable13_1
   \   0000001A   CD22               MOVS     R2,#+205
   \   0000001C   9200               LSLS     R2,R2,#+2        ;; #+820
   \   0000001E   0280               STRH     R2,[R0, #+0]
    681                
    682                /* If we get to this point, then no data was available, and we
    683                   allow a new poll request. Otherwise, we wait for the data
    684                   indication before allowing the next poll request. */
    685                mWaitPollConfirm = FALSE;
   \   00000020   ....               LDR      R0,??DataTable13_2
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   0270               STRB     R2,[R0, #+0]
    686              }
    687              break;
    688            }
    689            return errorNoError;
   \                     ??App_HandleMlmeInput_2:
   \   00000026   0020               MOVS     R0,#+0
   \                     ??App_HandleMlmeInput_1:
   \   00000028   08BC               POP      {R3}
   \   0000002A   1847               BX       R3               ;; return
    690          }
    691          
    692          /******************************************************************************
    693          * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
    694          * messages from the MCPS, e.g. Data Confirm, and Data Indication.
    695          *
    696          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    697          static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
    698          {
   \                     App_HandleMcpsInput:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    699            switch(pMsgIn->msgType)
   \   00000004   2078               LDRB     R0,[R4, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??App_HandleMcpsInput_0
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   0ED0               BEQ      ??App_HandleMcpsInput_1
   \   0000000E   1EE0               B        ??App_HandleMcpsInput_2
    700            {
    701              /* The MCPS-Data confirm is sent by the MAC to the network 
    702                 or application layer when data has been sent. */
    703            case gMcpsDataCnf_c:
    704              if(mcPendingPackets)
   \                     ??App_HandleMcpsInput_0:
   \   00000010   ....               LDR      R0,??DataTable13_3
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   1AD0               BEQ      ??App_HandleMcpsInput_2
    705              {
    706                mcPendingPackets--;
   \   00000018   ....               LDR      R0,??DataTable13_3
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   401E               SUBS     R0,R0,#+1
   \   0000001E   ....               LDR      R1,??DataTable13_3
   \   00000020   0870               STRB     R0,[R1, #+0]
    707                UartUtil_Print("The data packet has been sent to network layer ...\n\r", gAllowToBlock_d);
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   ....               LDR      R0,??DataTable13_4
   \   00000026   ........           BL       UartUtil_Print
   \   0000002A   10E0               B        ??App_HandleMcpsInput_2
    708              }
    709              break;
    710          
    711            case gMcpsDataInd_c:
    712              //DISPLAY DATA ON THE UART
    713              UartUtil_Print("Data indication has come for a data packet\n\r", gAllowToBlock_d);
   \                     ??App_HandleMcpsInput_1:
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   ....               LDR      R0,??DataTable13_5
   \   00000030   ........           BL       UartUtil_Print
    714              /* Copy the received data to the UART. */
    715              UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
   \   00000034   2000               MOVS     R0,R4
   \   00000036   1B30               ADDS     R0,R0,#+27
   \   00000038   ........           BL       __aeabi_uread4
   \   0000003C   E17D               LDRB     R1,[R4, #+23]
   \   0000003E   ........           BL       UartUtil_Tx
    716              /* Since we received data, the coordinator might have more to send. We 
    717                 reduce the polling interval to raise the throughput while data is
    718                 available. */
    719              mPollInterval = mDefaultValueOfPollIntervalFast_c;
   \   00000042   ....               LDR      R0,??DataTable13_1
   \   00000044   5221               MOVS     R1,#+82
   \   00000046   0180               STRH     R1,[R0, #+0]
    720              /* Allow another MLME-Poll request. */
    721              mWaitPollConfirm = FALSE;
   \   00000048   ....               LDR      R0,??DataTable13_2
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0170               STRB     R1,[R0, #+0]
    722              break;
    723            }
    724          }
   \                     ??App_HandleMcpsInput_2:
   \   0000004E   10BC               POP      {R4}
   \   00000050   08BC               POP      {R3}
   \   00000052   1847               BX       R3               ;; return
    725          
    726          /******************************************************************************
    727          * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
    728          * the name implies, wait for a message, thus blocking the execution of the
    729          * state machine. Instead the function analyzes the supplied message to 
    730          * determine whether or not the message is of the expected type.
    731          * The function may return either of the following values:
    732          *   errorNoError: The message was of the expected type.
    733          *   errorNoMessage: The message pointer is NULL.
    734          *   errorWrongConfirm: The message is not of the expected type.
    735          *
    736          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    737          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
    738          {
   \                     App_WaitMsg:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0200               MOVS     R2,R0
    739            /* Do we have a message? If not, the exit with error code */
    740            if(pMsg == NULL)
   \   00000004   002A               CMP      R2,#+0
   \   00000006   01D1               BNE      ??App_WaitMsg_0
    741              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   07E0               B        ??App_WaitMsg_1
    742          
    743            /* Is it the expected message type? If not then exit with error code */
    744            if(pMsg->msgType != msgType)
   \                     ??App_WaitMsg_0:
   \   0000000C   1078               LDRB     R0,[R2, #+0]
   \   0000000E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000010   090E               LSRS     R1,R1,#+24
   \   00000012   8842               CMP      R0,R1
   \   00000014   01D0               BEQ      ??App_WaitMsg_2
    745              return errorWrongConfirm;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   00E0               B        ??App_WaitMsg_1
    746          
    747            /* Found the expected message. Return with success code */
    748            return errorNoError;
   \                     ??App_WaitMsg_2:
   \   0000001A   0020               MOVS     R0,#+0
   \                     ??App_WaitMsg_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
    749          }
    750          
    751          /******************************************************************************
    752          * The App_TransmitUartData() function will perform (single/multi buffered)
    753          * data transmissions of data received by the UART. Data could also come from
    754          * other sources such as sensors etc. This is completely determined by the
    755          * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
    756          * number of packets pending for transmission in the MAC. A global variable
    757          * is incremented each time a data packet is sent to the MCPS, and decremented
    758          * when the corresponding MCPS-Data Confirm message is received. If the counter
    759          * reaches the defined maximum no more data buffers are allocated until the
    760          * counter is decreased below the maximum number of pending packets.
    761          *
    762          * The function uses the coordinator information gained during the Active Scan,
    763          * and the short address assigned to us by coordinator, for building an MCPS-
    764          * Data Request message. The message is sent to the MCPS service access point
    765          * in the MAC.
    766          ******************************************************************************/
    767          static void App_TransmitUartData(void)
    768          {   
    769            static uint8_t keysBuffer[mMaxKeysToReceive_c];
    770            static uint8_t keysReceived = 0;
    771            
    772            /* get data from UART */
    773            if( keysReceived < mMaxKeysToReceive_c ) 
    774            {
    775              if(Uart1_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
    776              {
    777              keysReceived++;
    778              }
    779            }
    780          	/* Use multi buffering for increased TX performance. It does not really
    781               have any effect at a UART baud rate of 19200bps but serves as an
    782               example of how the throughput may be improved in a real-world 
    783               application where the data rate is of concern. */
    784            if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
    785            {
    786              /* If the maximum number of pending data buffes is below maximum limit 
    787                 and we do not have a data buffer already then allocate one. */
    788              mpPacket = MSG_AllocType(nwkToMcpsMessage_t);
    789            }
    790          
    791            if(mpPacket != NULL)
    792            {
    793              /* get data from UART */        
    794                mpPacket->msgData.dataReq.pMsdu = &keysBuffer[0];
    795                /* Data was available in the UART receive buffer. Now create an
    796                   MCPS-Data Request message containing the UART data. */
    797                mpPacket->msgType = gMcpsDataReq_c;
    798                /* Create the header using coordinator information gained during 
    799                   the scan procedure. Also use the short address we were assigned
    800                   by the coordinator during association. */
    801                FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, mCoordInfo.coordAddress, 8);
    802                FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
    803                FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
    804                FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
    805                mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
    806                mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
    807                mpPacket->msgData.dataReq.msduLength = keysReceived;
    808                /* Request MAC level acknowledgement of the data packet */
    809                mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c;
    810                /* Give the data packet a handle. The handle is
    811                   returned in the MCPS-Data Confirm message. */
    812                mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
    813          #ifdef gMAC2006_d
    814          	  /* Don't use security */
    815          	  mpPacket->msgData.dataReq.securityLevel = 0;
    816          #endif //gMAC2006_d      
    817                /* Send the Data Request to the MCPS */
    818                (void)MSG_Send(NWK_MCPS, mpPacket);
    819                /* Prepare for another data buffer */
    820                mpPacket = NULL;
    821                mcPendingPackets++;
    822                /* Receive another pressed keys */
    823                keysReceived = 0;
    824            }
    825                
    826            /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
    827            /* try to send it later   */
    828            if (keysReceived)
    829            {
    830            TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
    831            }
    832          
    833          }
    834          
    835          

   \                                 In section .text, align 2, keep-with-next
    836          static void App_TransmitUart2Data(uint8_t value)
    837          {   
   \                     App_TransmitUart2Data:
   \   00000000   01B5               PUSH     {R0,LR}
    838            static uint8_t keysBuffer[mMaxKeysToReceive_c];
                                  ^
Warning[Pe177]: variable "keysBuffer" was declared but never referenced

  static void App_TransmitUartData(void)
              ^
"C:\Documents and Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWirelessApp Demo Non Beacon (End Device)\Application\Source\MApp.c",767  Warning[Pe177]: 
          function "App_TransmitUartData" was declared but never referenced
    839            static uint8_t keysReceived = 0;
    840            
    841            /* get data from UART 
    842            if( keysReceived < mMaxKeysToReceive_c ) 
    843            {
    844              if(Uart2_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
    845              {
    846                keysReceived++;
    847              }
    848            }*/
    849          	/* Use multi buffering for increased TX performance. It does not really
    850               have any effect at a UART baud rate of 19200bps but serves as an
    851               example of how the throughput may be improved in a real-world 
    852               application where the data rate is of concern. */
    853            if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
   \   00000002   ....               LDR      R0,??DataTable13_3
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0228               CMP      R0,#+2
   \   00000008   08D2               BCS      ??App_TransmitUart2Data_0
   \   0000000A   ....               LDR      R0,??DataTable13_6
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   04D1               BNE      ??App_TransmitUart2Data_0
    854            {
    855              /* If the maximum number of pending data buffes is below maximum limit 
    856                 and we do not have a data buffer already then allocate one. */
    857              mpPacket = MSG_AllocType(nwkToMcpsMessage_t);
   \   00000012   1E20               MOVS     R0,#+30
   \   00000014   ........           BL       MM_Alloc
   \   00000018   ....               LDR      R1,??DataTable13_6
   \   0000001A   0860               STR      R0,[R1, #+0]
    858            }
    859          
    860            if(mpPacket != NULL)
   \                     ??App_TransmitUart2Data_0:
   \   0000001C   ....               LDR      R0,??DataTable13_6
   \   0000001E   0068               LDR      R0,[R0, #+0]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   52D0               BEQ      ??App_TransmitUart2Data_1
    861            {
    862              /* get data from UART */        
    863                mpPacket->msgData.dataReq.pMsdu = &value;
   \   00000024   ....               LDR      R0,??DataTable13_6
   \   00000026   0168               LDR      R1,[R0, #+0]
   \   00000028   1A31               ADDS     R1,R1,#+26
   \   0000002A   6846               MOV      R0,SP
   \   0000002C   ........           BL       __aeabi_uwrite4
    864                /* Data was available in the UART receive buffer. Now create an
    865                   MCPS-Data Request message containing the UART data. */
    866                mpPacket->msgType = gMcpsDataReq_c;
   \   00000030   ....               LDR      R0,??DataTable13_6
   \   00000032   0068               LDR      R0,[R0, #+0]
   \   00000034   0021               MOVS     R1,#+0
   \   00000036   0170               STRB     R1,[R0, #+0]
    867                /* Create the header using coordinator information gained during 
    868                   the scan procedure. Also use the short address we were assigned
    869                   by the coordinator during association. */
    870                FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, mCoordInfo.coordAddress, 8);
   \   00000038   0822               MOVS     R2,#+8
   \   0000003A   ....               LDR      R1,??DataTable10
   \   0000003C   ....               LDR      R0,??DataTable13_6
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   401C               ADDS     R0,R0,#+1
   \   00000042   ........           BL       FLib_MemCpy
    871                FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
   \   00000046   0822               MOVS     R2,#+8
   \   00000048   ....               LDR      R1,??DataTable13
   \   0000004A   ....               LDR      R0,??DataTable13_6
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   0C30               ADDS     R0,R0,#+12
   \   00000050   ........           BL       FLib_MemCpy
    872                FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
   \   00000054   0222               MOVS     R2,#+2
   \   00000056   ....               LDR      R1,??DataTable10
   \   00000058   0831               ADDS     R1,R1,#+8
   \   0000005A   ....               LDR      R0,??DataTable13_6
   \   0000005C   0068               LDR      R0,[R0, #+0]
   \   0000005E   0930               ADDS     R0,R0,#+9
   \   00000060   ........           BL       FLib_MemCpy
    873                FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
   \   00000064   0222               MOVS     R2,#+2
   \   00000066   ....               LDR      R1,??DataTable10
   \   00000068   0831               ADDS     R1,R1,#+8
   \   0000006A   ....               LDR      R0,??DataTable13_6
   \   0000006C   0068               LDR      R0,[R0, #+0]
   \   0000006E   1430               ADDS     R0,R0,#+20
   \   00000070   ........           BL       FLib_MemCpy
    874                mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
   \   00000074   ....               LDR      R0,??DataTable13_6
   \   00000076   0068               LDR      R0,[R0, #+0]
   \   00000078   ....               LDR      R1,??DataTable10
   \   0000007A   897A               LDRB     R1,[R1, #+10]
   \   0000007C   C172               STRB     R1,[R0, #+11]
    875                mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
   \   0000007E   ....               LDR      R0,??DataTable13_6
   \   00000080   0068               LDR      R0,[R0, #+0]
   \   00000082   ....               LDR      R1,??DataTable12
   \   00000084   0978               LDRB     R1,[R1, #+0]
   \   00000086   8175               STRB     R1,[R0, #+22]
    876                mpPacket->msgData.dataReq.msduLength = sizeof(value);
   \   00000088   ....               LDR      R0,??DataTable13_6
   \   0000008A   0068               LDR      R0,[R0, #+0]
   \   0000008C   0121               MOVS     R1,#+1
   \   0000008E   C175               STRB     R1,[R0, #+23]
    877                /* Request MAC level acknowledgement of the data packet */
    878                mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c;
   \   00000090   ....               LDR      R0,??DataTable13_6
   \   00000092   0068               LDR      R0,[R0, #+0]
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   4176               STRB     R1,[R0, #+25]
    879                /* Give the data packet a handle. The handle is
    880                   returned in the MCPS-Data Confirm message. */
    881                mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
   \   00000098   ....               LDR      R0,??DataTable13_6
   \   0000009A   0068               LDR      R0,[R0, #+0]
   \   0000009C   ....               LDR      R1,??DataTable13_7
   \   0000009E   0978               LDRB     R1,[R1, #+0]
   \   000000A0   0176               STRB     R1,[R0, #+24]
   \   000000A2   ....               LDR      R0,??DataTable13_7
   \   000000A4   0078               LDRB     R0,[R0, #+0]
   \   000000A6   401C               ADDS     R0,R0,#+1
   \   000000A8   ....               LDR      R1,??DataTable13_7
   \   000000AA   0870               STRB     R0,[R1, #+0]
    882          #ifdef gMAC2006_d
    883          	  /* Don't use security */
    884          	  mpPacket->msgData.dataReq.securityLevel = 0;
    885          #endif //gMAC2006_d      
    886                /* Send the Data Request to the MCPS */
    887                (void)MSG_Send(NWK_MCPS, mpPacket);
   \   000000AC   ....               LDR      R0,??DataTable13_6
   \   000000AE   0068               LDR      R0,[R0, #+0]
   \   000000B0   ........           BL       NWK_MCPS_SapHandler
    888                /* Prepare for another data buffer */
    889                mpPacket = NULL;
   \   000000B4   ....               LDR      R0,??DataTable13_6
   \   000000B6   0021               MOVS     R1,#+0
   \   000000B8   0160               STR      R1,[R0, #+0]
    890                mcPendingPackets++;
   \   000000BA   ....               LDR      R0,??DataTable13_3
   \   000000BC   0078               LDRB     R0,[R0, #+0]
   \   000000BE   401C               ADDS     R0,R0,#+1
   \   000000C0   ....               LDR      R1,??DataTable13_3
   \   000000C2   0870               STRB     R0,[R1, #+0]
    891                /* Receive another pressed keys */
    892                keysReceived = 0;
   \   000000C4   ....               LDR      R0,??DataTable13_8
   \   000000C6   0021               MOVS     R1,#+0
   \   000000C8   0170               STRB     R1,[R0, #+0]
    893            }
    894                
    895            /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
    896            /* try to send it later   */
    897            if (keysReceived)
   \                     ??App_TransmitUart2Data_1:
   \   000000CA   ....               LDR      R0,??DataTable13_8
   \   000000CC   0078               LDRB     R0,[R0, #+0]
   \   000000CE   0028               CMP      R0,#+0
   \   000000D0   04D0               BEQ      ??App_TransmitUart2Data_2
    898            {
    899            TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   000000D2   0221               MOVS     R1,#+2
   \   000000D4   ....               LDR      R0,??DataTable13_9
   \   000000D6   0078               LDRB     R0,[R0, #+0]
   \   000000D8   ........           BL       TS_SendEvent
    900            }
    901          
    902          }
   \                     ??App_TransmitUart2Data_2:
   \   000000DC   09BC               POP      {R0,R3}
   \   000000DE   1847               BX       R3               ;; return

   \                                 In section .bss, align 1
   \                     ??keysReceived:
   \   00000000                      DS8 1
    903          
    904          /******************************************************************************
    905          * The App_ReceiveUartData() function will check if it is time to send out an
    906          * MLME-Poll request in order to receive data from the coordinator. If its time,
    907          * and we are permitted then a poll request is created and sent.
    908          * 
    909          * The function uses the coordinator information gained during the Active Scan
    910          * for building the MLME-Poll Request message. The message is sent to the MLME
    911          * service access point in the MAC.
    912          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    913          static void    AppPollWaitTimeout(uint8_t tmr)
    914          { 
   \                     AppPollWaitTimeout:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    915            
    916            /* Just to avoid the compiler warning */
    917            tmr++;
   \   00000004   641C               ADDS     R4,R4,#+1
    918            
    919            /* Check if we are permitted, and if it is time to send a poll request.
    920               The poll interval is adjusted dynamically to the current band-width
    921               requirements. */
    922            if(mWaitPollConfirm == FALSE)
   \   00000006   ....               LDR      R0,??DataTable13_2
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   21D1               BNE      ??AppPollWaitTimeout_0
    923            {
    924              /* This is an MLME-POLL.req command. */
    925              mlmeMessage_t *pMlmeMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000E   0F20               MOVS     R0,#+15
   \   00000010   ........           BL       MM_Alloc
   \   00000014   0500               MOVS     R5,R0
    926              if(pMlmeMsg)
   \   00000016   002D               CMP      R5,#+0
   \   00000018   1BD0               BEQ      ??AppPollWaitTimeout_0
    927              {
    928                /* Create the Poll Request message data. */
    929                pMlmeMsg->msgType = gMlmePollReq_c;
   \   0000001A   0C20               MOVS     R0,#+12
   \   0000001C   2870               STRB     R0,[R5, #+0]
    930           
    931                /* Use the coordinator information we got from the Active Scan. */
    932                FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordAddress, mCoordInfo.coordAddress, 8);
   \   0000001E   0822               MOVS     R2,#+8
   \   00000020   ....               LDR      R1,??DataTable10
   \   00000022   2800               MOVS     R0,R5
   \   00000024   401C               ADDS     R0,R0,#+1
   \   00000026   ........           BL       FLib_MemCpy
    933                FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordPanId, mCoordInfo.coordPanId, 2);
   \   0000002A   0222               MOVS     R2,#+2
   \   0000002C   ....               LDR      R1,??DataTable10
   \   0000002E   0831               ADDS     R1,R1,#+8
   \   00000030   2800               MOVS     R0,R5
   \   00000032   0930               ADDS     R0,R0,#+9
   \   00000034   ........           BL       FLib_MemCpy
    934                pMlmeMsg->msgData.pollReq.coordAddrMode = mCoordInfo.coordAddrMode;
   \   00000038   ....               LDR      R0,??DataTable10
   \   0000003A   807A               LDRB     R0,[R0, #+10]
   \   0000003C   E872               STRB     R0,[R5, #+11]
    935          #ifdef gMAC2006_d
    936                pMlmeMsg->msgData.pollReq.securityLevel = 0;
    937          #else      
    938                pMlmeMsg->msgData.pollReq.securityEnable = FALSE;
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   2873               STRB     R0,[R5, #+12]
    939          #endif //gMAC2006_d      
    940                
    941                /* Send the Poll Request to the MLME. */
    942                if(MSG_Send(NWK_MLME, pMlmeMsg) == gSuccess_c)
   \   00000042   2800               MOVS     R0,R5
   \   00000044   ........           BL       NWK_MLME_SapHandler
   \   00000048   0028               CMP      R0,#+0
   \   0000004A   02D1               BNE      ??AppPollWaitTimeout_0
    943                {
    944                  /* Do not allow another Poll request before the confirm is received. */
    945                  mWaitPollConfirm = TRUE;
   \   0000004C   ....               LDR      R0,??DataTable13_2
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   0170               STRB     R1,[R0, #+0]
    946          
    947                }
    948              }
    949            }
    950           /* Restart timer. */
    951           TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
   \                     ??AppPollWaitTimeout_0:
   \   00000052   ....               LDR      R2,??DataTable13_10
   \   00000054   ....               LDR      R0,??DataTable13_1
   \   00000056   0188               LDRH     R1,[R0, #+0]
   \   00000058   ....               LDR      R0,??DataTable13_11
   \   0000005A   0078               LDRB     R0,[R0, #+0]
   \   0000005C   ........           BL       TMR_StartSingleShotTimer
    952          }
   \   00000060   31BC               POP      {R0,R4,R5}
   \   00000062   08BC               POP      {R3}
   \   00000064   1847               BX       R3               ;; return
    953          
    954          /*****************************************************************************
    955          * Handles all key events for this device.
    956          * Interface assumptions: None
    957          * Return value: None
    958          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    959          static void App_HandleKeys
    960            (
    961            key_event_t events  /*IN: Events from keyboard modul */
    962            )
    963          {
   \                     App_HandleKeys:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    964            switch ( events ) 
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   0728               CMP      R0,#+7
   \   0000000E   26D8               BHI      ??App_HandleKeys_0
    965              { 
    966                case gKBD_EventSW1_c:
    967                case gKBD_EventSW2_c:
    968                case gKBD_EventSW3_c:
    969                case gKBD_EventSW4_c:
    970                case gKBD_EventLongSW1_c:
    971                case gKBD_EventLongSW2_c:
    972                case gKBD_EventLongSW3_c:
    973                case gKBD_EventLongSW4_c:
    974                  if(gState == stateInit)
   \                     ??App_HandleKeys_1:
   \   00000010   ....               LDR      R0,??DataTable13_12
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   22D1               BNE      ??App_HandleKeys_0
    975                    {
    976                    StopLed1Flashing();
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   ........           BL       LED_StopFlash
    977                    StopLed2Flashing();
   \   0000001E   0220               MOVS     R0,#+2
   \   00000020   ........           BL       LED_StopFlash
    978                    StopLed3Flashing();
   \   00000024   0420               MOVS     R0,#+4
   \   00000026   ........           BL       LED_StopFlash
    979                    StopLed4Flashing();
   \   0000002A   0820               MOVS     R0,#+8
   \   0000002C   ........           BL       LED_StopFlash
    980                    Led1Off();
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   1720               MOVS     R0,#+23
   \   00000034   ........           BL       Gpio_SetPinData
    981                    Led2Off();
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   1820               MOVS     R0,#+24
   \   0000003C   ........           BL       Gpio_SetPinData
    982                    Led3Off();
   \   00000040   0021               MOVS     R1,#+0
   \   00000042   1920               MOVS     R0,#+25
   \   00000044   ........           BL       Gpio_SetPinData
    983                    Led4Off();
   \   00000048   0021               MOVS     R1,#+0
   \   0000004A   2C20               MOVS     R0,#+44
   \   0000004C   ........           BL       Gpio_SetPinData
    984                    LCD_ClearDisplay();
    985                    LCD_WriteString(1,"Application");
   \   00000050   ....               LDR      R0,??DataTable13_13
    986                    LCD_WriteString(2,"    started");     
   \   00000052   ....               LDR      R0,??DataTable13_14
    987                    TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
   \   00000054   0121               MOVS     R1,#+1
   \   00000056   ....               LDR      R0,??DataTable13_9
   \   00000058   0078               LDRB     R0,[R0, #+0]
   \   0000005A   ........           BL       TS_SendEvent
    988                    }
    989              }    
    990          }
   \                     ??App_HandleKeys_0:
   \   0000005E   10BC               POP      {R4}
   \   00000060   08BC               POP      {R3}
   \   00000062   1847               BX       R3               ;; return
    991          
    992          /*****************************************************************************
    993          * The DeepSleepWakeupStackProc(void) function is called each time the 
    994          * application exits the DeepSleep mode .
    995          * 
    996          * Return value:
    997          *     None
    998          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    999          void DeepSleepWakeupStackProc(void){
   1000            return;
   \                     DeepSleepWakeupStackProc:
   \   00000000   7047               BX       LR               ;; return
   1001          }
   1002          
   1003          /******************************************************************************
   1004          * The following functions are called by the MAC to put messages into the
   1005          * Application's queue. They need to be defined even if they are not used
   1006          * in order to avoid linker errors.
   1007          ******************************************************************************/
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
   1010          {
   \                     MLME_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1011            /* Put the incoming MLME message in the applications input queue. */
   1012            MSG_Queue(&mMlmeNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable13_15
   \   00000008   ........           BL       List_AddTail
   1013            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
   \   0000000C   0421               MOVS     R1,#+4
   \   0000000E   ....               LDR      R0,??DataTable13_9
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
   1014            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
   1015          }
   1016          

   \                                 In section .text, align 2, keep-with-next
   1017          uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
   1018          {
   \                     MCPS_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1019            /* Put the incoming MCPS message in the applications input queue. */
   1020            MSG_Queue(&mMcpsNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable13_16
   \   00000008   ........           BL       List_AddTail
   1021            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   0000000C   0821               MOVS     R1,#+8
   \   0000000E   ....               LDR      R0,??DataTable13_9
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
   1022            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
   1023          }
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
   1026          {
   \                     ASP_APP_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1027            /* If the message is not handled anywhere it must be freed. */
   1028            MSG_Free(pMsg);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       MM_Free
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0400               MOVS     R4,R0
   1029            return gSuccess_c;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   10BC               POP      {R4}
   \   00000012   08BC               POP      {R3}
   \   00000014   1847               BX       R3               ;; return
   1030          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   ........           DC32     mWaitPollConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   ........           DC32     App_HandleKeys

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   ........           DC32     UartRxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   ........           DC32     `?<Constant "\\n\\rPress any switch on...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   ........           DC32     `?<Constant "Press any key">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     `?<Constant "to start.">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   ........           DC32     `?<Constant "Found a coordinator w...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     `?<Constant "Received an MLME-Beac...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   ........           DC32     `?<Constant "MyWirelessApp Demo No...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   ........           DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   ........           DC32     `?<Constant "\\n\\rAddress...........0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   ........           DC32     mCoordInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   ........           DC32     `?<Constant "\\n\\rPAN ID............0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   ........           DC32     `?<Constant "\\n\\rLogical Channel...0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   ........           DC32     `?<Constant "\\n\\rBeacon Spec.......0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     `?<Constant "\\n\\rLink Quality......0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     `?<Constant "\\n\\r\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     `?<Constant "Scan did not find a s...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     `?<Constant "No coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     `?<Constant "found.">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   ........           DC32     `?<Constant "Associating to PAN co...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   ........           DC32     `?<Constant "Associating to ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   ........           DC32     `?<Constant "PAN coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     `?<Constant "Successfully associat...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     `?<Constant "We were assigned the ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     mAddrMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     maMyAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     `?<Constant "\\n\\r\\n\\rReady to send and...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     `?<Constant "Ready to send">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   ........           DC32     `?<Constant "and receive data">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   ........           DC32     AppPollWaitTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     `?<Constant "\\n\\rAssociate Confirm w...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     val

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     valc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Scan...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     `?<Constant "Done\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     `?<Constant "Invalid parameter!\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     `?<Constant "Message allocation fa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Asso...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     mCoordInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     aExtendedAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     mAddrMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     maMyAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   ........           DC32     mWaitPollConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   ........           DC32     `?<Constant "The data packet has b...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   ........           DC32     `?<Constant "Data indication has c...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   ........           DC32     mpPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   ........           DC32     mMsduHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   ........           DC32     ??keysReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   ........           DC32     AppPollWaitTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   ........           DC32     `?<Constant "Application">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   ........           DC32     `?<Constant "    started">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rPress any switch on...">`:
   \   00000000   0A0D50726573       DC8 0AH, 0DH, 50H, 72H, 65H, 73H, 73H, 20H
   \              7320        
   \   00000008   616E79207377       DC8 61H, 6EH, 79H, 20H, 73H, 77H, 69H, 74H
   \              6974        
   \   00000010   6368206F6E20       DC8 63H, 68H, 20H, 6FH, 6EH, 20H, 62H, 6FH
   \              626F        
   \   00000018   61726420746F       DC8 61H, 72H, 64H, 20H, 74H, 6FH, 20H, 73H
   \              2073        
   \   00000020   746172742072       DC8 74H, 61H, 72H, 74H, 20H, 72H, 75H, 6EH
   \              756E        
   \   00000028   6E696E672074       DC8 6EH, 69H, 6EH, 67H, 20H, 74H, 68H, 65H
   \              6865        
   \   00000030   206170706C69       DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
   \              6361        
   \   00000038   74696F6E2E0A       DC8 74H, 69H, 6FH, 6EH, 2EH, 0AH, 0DH, 0
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "Press any key">`:
   \   00000000   507265737320       DC8 "Press any key"
   \              616E79206B65
   \              7900        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "to start.">`:
   \   00000000   746F20737461       DC8 "to start."
   \              72742E00    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received an MLME-Beac...">`:
   \   00000000   526563656976       DC8 "Received an MLME-Beacon Notify Indication\012\015"
   \              656420616E20
   \              4D4C4D452D42
   \              6561636F6E20
   \              4E6F74696679
   \              20496E646963
   \              6174696F6E0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "MyWirelessApp Demo No...">`:
   \   00000000   4D7957697265       DC8 4DH, 79H, 57H, 69H, 72H, 65H, 6CH, 65H
   \              6C65        
   \   00000008   737341707020       DC8 73H, 73H, 41H, 70H, 70H, 20H, 44H, 65H
   \              4465        
   \   00000010   6D6F204E6F6E       DC8 6DH, 6FH, 20H, 4EH, 6FH, 6EH, 20H, 42H
   \              2042        
   \   00000018   6561636F6E20       DC8 65H, 61H, 63H, 6FH, 6EH, 20H, 45H, 6EH
   \              456E        
   \   00000020   642044657669       DC8 64H, 20H, 44H, 65H, 76H, 69H, 63H, 65H
   \              6365        
   \   00000028   206170706C69       DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
   \              6361        
   \   00000030   74696F6E2069       DC8 74H, 69H, 6FH, 6EH, 20H, 69H, 73H, 20H
   \              7320        
   \   00000038   696E69746961       DC8 69H, 6EH, 69H, 74H, 69H, 61H, 6CH, 69H
   \              6C69        
   \   00000040   7A656420616E       DC8 7AH, 65H, 64H, 20H, 61H, 6EH, 64H, 20H
   \              6420        
   \   00000048   72656164792E       DC8 72H, 65H, 61H, 64H, 79H, 2EH, 0AH, 0DH
   \              0A0D        
   \   00000050   0A0D00             DC8 0AH, 0DH, 0
   \   00000053   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Start scanning for a ...">`:
   \   00000000   537461727420       DC8 "Start scanning for a PAN coordinator\012\015"
   \              7363616E6E69
   \              6E6720666F72
   \              20612050414E
   \              20636F6F7264
   \              696E61746F72
   \              0A0D00      
   \   00000027   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Start scanning">`:
   \   00000000   537461727420       DC8 "Start scanning"
   \              7363616E6E69
   \              6E6700      
   \   0000000F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "for coordinator">`:
   \   00000000   666F7220636F       DC8 "for coordinator"
   \              6F7264696E61
   \              746F7200    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Found a coordinator w...">`:
   \   00000000   466F756E6420       DC8 46H, 6FH, 75H, 6EH, 64H, 20H, 61H, 20H
   \              6120        
   \   00000008   636F6F726469       DC8 63H, 6FH, 6FH, 72H, 64H, 69H, 6EH, 61H
   \              6E61        
   \   00000010   746F72207769       DC8 74H, 6FH, 72H, 20H, 77H, 69H, 74H, 68H
   \              7468        
   \   00000018   207468652066       DC8 20H, 74H, 68H, 65H, 20H, 66H, 6FH, 6CH
   \              6F6C        
   \   00000020   6C6F77696E67       DC8 6CH, 6FH, 77H, 69H, 6EH, 67H, 20H, 70H
   \              2070        
   \   00000028   726F70657274       DC8 72H, 6FH, 70H, 65H, 72H, 74H, 69H, 65H
   \              6965        
   \   00000030   733A0A0D00         DC8 73H, 3AH, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000008   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000010   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000018   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000020   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000028   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000030   2D2D2D2D00         DC8 2DH, 2DH, 2DH, 2DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rAddress...........0x">`:
   \   00000000   0A0D41646472       DC8 "\012\015Address...........0x"
   \              6573732E2E2E
   \              2E2E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rPAN ID............0x">`:
   \   00000000   0A0D50414E20       DC8 "\012\015PAN ID............0x"
   \              49442E2E2E2E
   \              2E2E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rLogical Channel...0x">`:
   \   00000000   0A0D4C6F6769       DC8 "\012\015Logical Channel...0x"
   \              63616C204368
   \              616E6E656C2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rBeacon Spec.......0x">`:
   \   00000000   0A0D42656163       DC8 "\012\015Beacon Spec.......0x"
   \              6F6E20537065
   \              632E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rLink Quality......0x">`:
   \   00000000   0A0D4C696E6B       DC8 "\012\015Link Quality......0x"
   \              205175616C69
   \              74792E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r\\n\\r">`:
   \   00000000   0A0D0A0D00         DC8 "\012\015\012\015"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Scan did not find a s...">`:
   \   00000000   5363616E2064       DC8 "Scan did not find a suitable coordinator\012\015"
   \              6964206E6F74
   \              2066696E6420
   \              612073756974
   \              61626C652063
   \              6F6F7264696E
   \              61746F720A0D
   \              00          
   \   0000002B   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "No coordinator">`:
   \   00000000   4E6F20636F6F       DC8 "No coordinator"
   \              7264696E6174
   \              6F7200      
   \   0000000F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "found.">`:
   \   00000000   666F756E642E       DC8 "found."
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Associating to PAN co...">`:
   \   00000000   4173736F6369       DC8 "Associating to PAN coordinator on channel 0x"
   \              6174696E6720
   \              746F2050414E
   \              20636F6F7264
   \              696E61746F72
   \              206F6E206368
   \              616E6E656C20
   \              307800      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Associating to ">`:
   \   00000000   4173736F6369       DC8 "Associating to "
   \              6174696E6720
   \              746F2000    

   \                                 In section .rodata, align 4
   \                     `?<Constant "PAN coordinator">`:
   \   00000000   50414E20636F       DC8 "PAN coordinator"
   \              6F7264696E61
   \              746F7200    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Successfully associat...">`:
   \   00000000   537563636573       DC8 "Successfully associated with the coordinator.\012\015"
   \              7366756C6C79
   \              206173736F63
   \              696174656420
   \              776974682074
   \              686520636F6F
   \              7264696E6174
   \              6F722E0A0D00

   \                                 In section .rodata, align 4
   \                     `?<Constant "We were assigned the ...">`:
   \   00000000   576520776572       DC8 "We were assigned the short address 0x"
   \              652061737369
   \              676E65642074
   \              68652073686F
   \              727420616464
   \              726573732030
   \              7800        
   \   00000026   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r\\n\\rReady to send and...">`:
   \   00000000   0A0D0A0D5265       DC8 0AH, 0DH, 0AH, 0DH, 52H, 65H, 61H, 64H
   \              6164        
   \   00000008   7920746F2073       DC8 79H, 20H, 74H, 6FH, 20H, 73H, 65H, 6EH
   \              656E        
   \   00000010   6420616E6420       DC8 64H, 20H, 61H, 6EH, 64H, 20H, 72H, 65H
   \              7265        
   \   00000018   636569766520       DC8 63H, 65H, 69H, 76H, 65H, 20H, 64H, 61H
   \              6461        
   \   00000020   7461206F7665       DC8 74H, 61H, 20H, 6FH, 76H, 65H, 72H, 20H
   \              7220        
   \   00000028   746865205541       DC8 74H, 68H, 65H, 20H, 55H, 41H, 52H, 54H
   \              5254        
   \   00000030   2E0A0D0A0D00       DC8 2EH, 0AH, 0DH, 0AH, 0DH, 0
   \   00000036   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Ready to send">`:
   \   00000000   526561647920       DC8 "Ready to send"
   \              746F2073656E
   \              6400        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "and receive data">`:
   \   00000000   616E64207265       DC8 "and receive data"
   \              636569766520
   \              6461746100  
   \   00000011   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rAssociate Confirm w...">`:
   \   00000000   0A0D4173736F       DC8 "\012\015Associate Confirm wasn't successful... \012\015\012\015"
   \              636961746520
   \              436F6E666972
   \              6D207761736E
   \              277420737563
   \              636573736675
   \              6C2E2E2E200A
   \              0D0A0D00    
   \   0000002E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Scan...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D5363616E20       DC8 2DH, 53H, 63H, 61H, 6EH, 20H, 52H, 65H
   \              5265        
   \   00000018   717565737420       DC8 71H, 75H, 65H, 73H, 74H, 20H, 6DH, 65H
   \              6D65        
   \   00000020   737361676520       DC8 73H, 73H, 61H, 67H, 65H, 20H, 74H, 6FH
   \              746F        
   \   00000028   20746865204D       DC8 20H, 74H, 68H, 65H, 20H, 4DH, 41H, 43H
   \              4143        
   \   00000030   2E2E2E00           DC8 2EH, 2EH, 2EH, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Done\\n\\r">`:
   \   00000000   446F6E650A0D       DC8 "Done\012\015"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Invalid parameter!\\n\\r">`:
   \   00000000   496E76616C69       DC8 "Invalid parameter!\012\015"
   \              642070617261
   \              6D6574657221
   \              0A0D00      
   \   00000015   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Message allocation fa...">`:
   \   00000000   4D6573736167       DC8 "Message allocation failed!\012\015"
   \              6520616C6C6F
   \              636174696F6E
   \              206661696C65
   \              64210A0D00  
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Asso...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D4173736F63       DC8 2DH, 41H, 73H, 73H, 6FH, 63H, 69H, 61H
   \              6961        
   \   00000018   746520526571       DC8 74H, 65H, 20H, 52H, 65H, 71H, 75H, 65H
   \              7565        
   \   00000020   7374206D6573       DC8 73H, 74H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              7361        
   \   00000028   676520746F20       DC8 67H, 65H, 20H, 74H, 6FH, 20H, 74H, 68H
   \              7468        
   \   00000030   65204D41432E       DC8 65H, 20H, 4DH, 41H, 43H, 2EH, 2EH, 2EH
   \              2E2E        
   \   00000038   00                 DC8 0
   \   00000039   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "The data packet has b...">`:
   \   00000000   546865206461       DC8 54H, 68H, 65H, 20H, 64H, 61H, 74H, 61H
   \              7461        
   \   00000008   207061636B65       DC8 20H, 70H, 61H, 63H, 6BH, 65H, 74H, 20H
   \              7420        
   \   00000010   686173206265       DC8 68H, 61H, 73H, 20H, 62H, 65H, 65H, 6EH
   \              656E        
   \   00000018   2073656E7420       DC8 20H, 73H, 65H, 6EH, 74H, 20H, 74H, 6FH
   \              746F        
   \   00000020   206E6574776F       DC8 20H, 6EH, 65H, 74H, 77H, 6FH, 72H, 6BH
   \              726B        
   \   00000028   206C61796572       DC8 20H, 6CH, 61H, 79H, 65H, 72H, 20H, 2EH
   \              202E        
   \   00000030   2E2E0A0D00         DC8 2EH, 2EH, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Data indication has c...">`:
   \   00000000   446174612069       DC8 "Data indication has come for a data packet\012\015"
   \              6E6469636174
   \              696F6E206861
   \              7320636F6D65
   \              20666F722061
   \              206461746120
   \              7061636B6574
   \              0A0D00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Application">`:
   \   00000000   4170706C6963       DC8 "Application"
   \              6174696F6E00

   \                                 In section .rodata, align 4
   \                     `?<Constant "    started">`:
   \   00000000   202020207374       DC8 "    started"
   \              617274656400
   1031          
   1032          /******************************************************************************/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     ASP_APP_SapHandler               8
     AppPollWaitTimeout              16
     AppTask                         16
     App_HandleAssociateConfirm       8
     App_HandleKeys                   8
     App_HandleMcpsInput              8
     App_HandleMlmeInput              4
     App_HandleScanActiveConfirm     32
     App_SendAssociateRequest        16
     App_StartScan                   16
     App_TransmitUart2Data            8
     App_WaitMsg                      4
     DeepSleepWakeupStackProc         0
     MApp_init                        8
     MCPS_NWK_SapHandler              8
     MLME_NWK_SapHandler              8
     UartRxCallBack                   8


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     mCoordInfo                                   24
     maMyAddress                                   8
     mAddrMode                                     1
     mpPacket                                      4
     mMsduHandle                                   1
     mcPendingPackets                              1
     mWaitPollConfirm                              1
     mPollInterval                                 2
     val                                           1
     valc                                          1
     mMlmeNwkInputQueue                            8
     mMcpsNwkInputQueue                            8
     mTimer_c                                      1
     gState                                        1
     gaNvAppDataSet                                8
     MApp_init                                   122
     AppTask                                     744
     UartRxCallBack                               32
     App_StartScan                               106
     App_HandleScanActiveConfirm                 170
     App_SendAssociateRequest                    126
     App_HandleAssociateConfirm                   70
     App_HandleMlmeInput                          44
     App_HandleMcpsInput                          84
     App_WaitMsg                                  32
     App_TransmitUart2Data                       224
     keysReceived                                  1
     AppPollWaitTimeout                          102
     App_HandleKeys                              100
     DeepSleepWakeupStackProc                      2
     MLME_NWK_SapHandler                          30
     MCPS_NWK_SapHandler                          30
     ASP_APP_SapHandler                           22
     ??DataTable0                                  4
     ??DataTable0_1                                4
     ??DataTable0_2                                4
     ??DataTable0_3                                4
     ??DataTable0_4                                4
     ??DataTable0_5                                4
     ??DataTable0_6                                4
     ??DataTable0_7                                4
     ??DataTable0_8                                4
     ??DataTable0_9                                4
     ??DataTable0_10                               4
     ??DataTable1                                  4
     ??DataTable1_1                                4
     ??DataTable1_2                                4
     ??DataTable2                                  4
     ??DataTable2_1                                4
     ??DataTable2_2                                4
     ??DataTable2_3                                4
     ??DataTable2_4                                4
     ??DataTable2_5                                4
     ??DataTable2_6                                4
     ??DataTable2_7                                4
     ??DataTable2_8                                4
     ??DataTable3                                  4
     ??DataTable3_1                                4
     ??DataTable3_2                                4
     ??DataTable3_3                                4
     ??DataTable3_4                                4
     ??DataTable3_5                                4
     ??DataTable3_6                                4
     ??DataTable3_7                                4
     ??DataTable3_8                                4
     ??DataTable4                                  4
     ??DataTable4_1                                4
     ??DataTable4_2                                4
     ??DataTable4_3                                4
     ??DataTable4_4                                4
     ??DataTable4_5                                4
     ??DataTable4_6                                4
     ??DataTable4_7                                4
     ??DataTable4_8                                4
     ??DataTable4_9                                4
     ??DataTable5                                  4
     ??DataTable6                                  4
     ??DataTable6_1                                4
     ??DataTable7                                  4
     ??DataTable8                                  4
     ??DataTable8_1                                4
     ??DataTable8_2                                4
     ??DataTable8_3                                4
     ??DataTable8_4                                4
     ??DataTable9                                  4
     ??DataTable10                                 4
     ??DataTable11                                 4
     ??DataTable12                                 4
     ??DataTable13                                 4
     ??DataTable13_1                               4
     ??DataTable13_2                               4
     ??DataTable13_3                               4
     ??DataTable13_4                               4
     ??DataTable13_5                               4
     ??DataTable13_6                               4
     ??DataTable13_7                               4
     ??DataTable13_8                               4
     ??DataTable13_9                               4
     ??DataTable13_10                              4
     ??DataTable13_11                              4
     ??DataTable13_12                              4
     ??DataTable13_13                              4
     ??DataTable13_14                              4
     ??DataTable13_15                              4
     ??DataTable13_16                              4
     ?<Constant "\n\rPress any switch on...">     64
     ?<Constant "Press any key">                  16
     ?<Constant "to start.">                      12
     ?<Constant "Received an MLME-Beac...">       44
     ?<Constant "MyWirelessApp Demo No...">       84
     ?<Constant "Start scanning for a ...">       40
     ?<Constant "Start scanning">                 16
     ?<Constant "for coordinator">                16
     ?<Constant "Found a coordinator w...">       56
     ?<Constant "---------------------...">       56
     ?<Constant "\n\rAddress...........0x">       24
     ?<Constant "\n\rPAN ID............0x">       24
     ?<Constant "\n\rLogical Channel...0x">       24
     ?<Constant "\n\rBeacon Spec.......0x">       24
     ?<Constant "\n\rLink Quality......0x">       24
     ?<Constant "\n\r\n\r">                        8
     ?<Constant "Scan did not find a s...">       44
     ?<Constant "No coordinator">                 16
     ?<Constant "found.">                          8
     ?<Constant "Associating to PAN co...">       48
     ?<Constant "Associating to ">                16
     ?<Constant "PAN coordinator">                16
     ?<Constant "Successfully associat...">       48
     ?<Constant "We were assigned the ...">       40
     ?<Constant "\n\r\n\rReady to send and...">   56
     ?<Constant "Ready to send">                  16
     ?<Constant "and receive data">               20
     ?<Constant "\n\rAssociate Confirm w...">     48
     ?<Constant "Sending the MLME-Scan...">       52
     ?<Constant "Done\n\r">                        8
     ?<Constant "Invalid parameter!\n\r">         24
     ?<Constant "Message allocation fa...">       32
     ?<Constant "Sending the MLME-Asso...">       60
     ?<Constant "The data packet has b...">       56
     ?<Constant "Data indication has c...">       48
     ?<Constant "Application">                    12
     ?<Constant "    started">                    12

 
    62 bytes in section .bss
     1 byte  in section .data
 1 220 bytes in section .rodata
 2 328 bytes in section .text
 
 2 328 bytes of CODE  memory
 1 220 bytes of CONST memory
    63 bytes of DATA  memory

Errors: none
Warnings: 2
