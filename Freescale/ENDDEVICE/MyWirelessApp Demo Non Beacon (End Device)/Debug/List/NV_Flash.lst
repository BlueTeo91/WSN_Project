###############################################################################
#                                                                             #
#                                                       12/Oct/2015  10:21:27 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\PLM\Source\NVM\NV_Flash.c        #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\NVM\NV_Flash.c" -D    #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Debug\List\" -lC "C:\Documents   #
#                    and Settings\Administrator\Desktop\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\MyWirelessApp Demo Non Beacon    #
#                    (End Device)\Debug\List\" -lB "C:\Documents and          #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\MacPhy\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Init\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Interface\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Configure\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\UartUtil\" -I        #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Source\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Source\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Interface\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Interface\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\LibInterface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Display\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Keyboard\" -I         #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\NVM\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\TMR\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\UART\" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 5.4     #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\List\NV_Flash.lst          #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\Obj\NV_Flash.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\PLM\Source\NVM\NV_Flash.c
      1          /*****************************************************************************
      2          * Non-volatile storage module local implementation.
      3          *
      4          * Copyright (c) 2006, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          
     13          #include "EmbeddedTypes.h"
     14          #include "TS_Interface.h"
     15          #include "NV_FlashHAL.h"
     16          #include "NV_Flash.h"
     17          #include "Crm.h"
     18          
     19          
     20          /*****************************************************************************
     21          ******************************************************************************
     22          * Private macros
     23          ******************************************************************************
     24          *****************************************************************************/
     25          
     26          /* Size of a member of a struct. */
     27          #ifndef MbrSizeof
     28          #define MbrSizeof(type, member)     (sizeof(((type *) 0)->member))
     29          #endif
     30          
     31          /* There must be at least one more flash page than there are data sets, to */
     32          /* allow for one copy of each data set plus a page for a new copy of one */
     33          /* data set. */
     34          
     35          #if gNvNumberOfRawPages_c <= gNvNumberOfDataSets_c
     36          #error
     37          #endif
     38          
     39          /* this macro must reflect the bit used for the idle task defined in BeeApp.c */
     40          #define gIdleTaskNVIntervalEvent_c  ( 1 << 0 )
     41          #define gMaxPageOffset_c  ( sizeof(NvStructuredSectorHeader_t) + gNvNumberOfRawPages_c * sizeof(NvRawPage_t))
     42          #define gLastPageOffset_c ( sizeof(NvStructuredSectorHeader_t) + (gNvNumberOfRawPages_c - 1) * sizeof(NvRawPage_t))
     43          #define gUninitAddress     0xffffffff
     44          #define NvOpenSector(nvRawSectorAddress, sequenceNumber)     NvOpen_Validate_Sector( nvRawSectorAddress , sequenceNumber, TRUE )
     45          #define NvValidateSector(nvRawSectorAddress, sequenceNumber) NvOpen_Validate_Sector( nvRawSectorAddress , sequenceNumber, FALSE )
     46          #define g_CopyBufferSize_c  64
     47          
     48          /*****************************************************************************
     49          ******************************************************************************
     50          * Private prototypes
     51          ******************************************************************************
     52          *****************************************************************************/
     53          #if gNvStorageIncluded_d
     54          void PowerUpNVM(void);
     55          void PowerDownNVM(void);
     56          static index_t NvDataSetIndexFromID(NvDataSetID_t dataSetID);
     57          static bool_t NvIsValidPage( NvRawPageAddress_t nvRawPageAddress , NvDataSetID_t *pDataSetID );
     58          static bool_t NvIsValidSector (  NvRawSectorAddress_t nvRawSectorAddress  );
     59          static bool_t NvSaveDataSetLowLevel(  index_t dataSetIndex , NvRawPageAddress_t pageAddress  );
     60          static void NvSaveDataSet( index_t dataSetIndex );
     61          static void NvGetFirstBlankPageInfo(NvRawPageAddress_t nvRawSectorAddress, NvRawPageAddress_t* pBlankPage, index_t* pBlankPageIndex);
     62          static NvSectorSequenceNumber_t NvGetSectorSequenceNumber( NvRawSectorAddress_t nvRawSectorAddress );
     63          static bool_t NvCopyDataSet  (  NvRawPageAddress_t sourcePage , NvRawPageAddress_t destPage  );
     64          static bool_t NvOpen_Validate_Sector(NvRawSectorAddress_t nvRawSectorAddress, NvSectorSequenceNumber_t sequenceNumber, bool_t open );
     65          static NvSectorSequenceNumber_t NvLastSectorSequence ( NvSectorSequenceNumber_t sectorSeqA,NvSectorSequenceNumber_t sectorSeqB );
     66          static void NvGetSectorPageInfo ( NvRawSectorAddress_t nvRawSectorAddress, NvSectPageInfo_t* pSectPageInfo );
     67          static bool_t  NvCopyTheRemainsDataSets ( NvSectPageInfo_t* oldSectPageInfo, NvSectPageInfo_t* newSectPageInfo, NvRawPageAddress_t firstBlankPageAddress,index_t firstBlankPageIndex );
     68          #endif
     69          
     70          #if gNvSelfTest_d
     71          static void NvSelfTest(void);
     72          #endif
     73          
     74          /*****************************************************************************
     75          ******************************************************************************
     76          * Private type definitions
     77          ******************************************************************************
     78          *****************************************************************************/
     79          
     80          /* One entry per data set. */
     81          typedef struct NvDataSetInfo_tag {
     82            bool_t saveNextInterval;
     83            NvSaveInterval_t ticksToNextSave;
     84            NvSaveCounter_t countsToNextSave;
     85          } NvDataSetInfo_t;
     86          
     87          
     88          /*****************************************************************************
     89          ******************************************************************************
     90          * Private memory declarations
     91          ******************************************************************************
     92          *****************************************************************************/
     93          
     94          #if gNvStorageIncluded_d
     95          /* Table of dirty flags, one per dataset in NvDataSetDescriptionTable[]. */

   \                                 In section .bss, align 4
     96          static NvDataSetInfo_t maNvDirtyFlags[gNvNumberOfDataSets_c];
   \                     maNvDirtyFlags:
   \   00000000                      DS8 12
     97          
     98          /* Minimum number of calls to NvTimerTick() between saves of a given dataset. */

   \                                 In section .data, align 2
     99          NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
   \                     gNvMinimumTicksBetweenSaves:
   \   00000000   0400               DC16 4
    100          /* Minimum number of calls to NvSaveOnIdle() between saves of a given dataset. */

   \                                 In section .data, align 2
    101          static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
   \                     gNvCountsBetweenSaves:
   \   00000000   0001               DC16 256
    102          
    103          /* If this counter is != 0, do not save to NV Storage. */

   \                                 In section .bss, align 1
    104          static uint8_t mNvCriticalSectionFlag = 0;
   \                     mNvCriticalSectionFlag:
   \   00000000                      DS8 1
    105          #endif                                  /* #if gNvStorageIncluded_d */
    106          
    107          /* Scratch data sets used by the internal unit test. */
    108          
    109          
    110          /*****************************************************************************
    111          ******************************************************************************
    112          * Public functions
    113          ******************************************************************************
    114          *****************************************************************************/
    115          
    116          /* There may be operations that take place over extended times that must
    117           * be atomic from the point of view of NV Storage saves. These routines
    118           * increment/decrement a counter; when the counter is non-zero, no NV
    119           * saves will be done. Note that this does not affect NV restores.
    120           */
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void NvClearCriticalSection(void) {
   \                     NvClearCriticalSection:
   \   00000000   00B5               PUSH     {LR}
    123          #if gNvStorageIncluded_d
    124            if(mNvCriticalSectionFlag)  /* dg - in case of set/clear mismatch */
   \   00000002   ....               LDR      R0,??DataTable5
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   04D0               BEQ      ??NvClearCriticalSection_0
    125              --mNvCriticalSectionFlag;
   \   0000000A   ....               LDR      R0,??DataTable5
   \   0000000C   0078               LDRB     R0,[R0, #+0]
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   ....               LDR      R1,??DataTable5
   \   00000012   0870               STRB     R0,[R1, #+0]
    126          #endif /* gNvStorageIncluded_d */
    127          }
   \                     ??NvClearCriticalSection_0:
   \   00000014   08BC               POP      {R3}
   \   00000016   1847               BX       R3               ;; return
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void NvSetCriticalSection(void) {
    130          #if gNvStorageIncluded_d
    131            ++mNvCriticalSectionFlag;
   \                     NvSetCriticalSection:
   \   00000000   ....               LDR      R0,??DataTable5
   \   00000002   0078               LDRB     R0,[R0, #+0]
   \   00000004   401C               ADDS     R0,R0,#+1
   \   00000006   ....               LDR      R1,??DataTable5
   \   00000008   0870               STRB     R0,[R1, #+0]
    132          #endif /* gNvStorageIncluded_d */
    133          }
   \   0000000A   7047               BX       LR               ;; return
    134          
    135          
    136          /****************************************************************************/
    137          
    138          /* Called from the idle task to process save-on-next-idle and save-on-count. */

   \                                 In section .text, align 2, keep-with-next
    139          void NvIdle(void)
    140          {
   \                     NvIdle:
   \   00000000   10B5               PUSH     {R4,LR}
    141          #if gNvStorageIncluded_d
    142            index_t i;
    143          
    144            if (mNvCriticalSectionFlag) {
   \   00000002   ....               LDR      R0,??DataTable5
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   15D1               BNE      ??NvIdle_0
    145              return;
    146            }
    147             
    148            for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
   \                     ??NvIdle_1:
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0400               MOVS     R4,R0
   \                     ??NvIdle_2:
   \   0000000E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000010   240E               LSRS     R4,R4,#+24
   \   00000012   022C               CMP      R4,#+2
   \   00000014   0FD2               BCS      ??NvIdle_3
    149              if (!maNvDirtyFlags[i].countsToNextSave) {
   \   00000016   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \   0000001A   0620               MOVS     R0,#+6
   \   0000001C   6043               MULS     R0,R4,R0
   \   0000001E   ....               LDR      R1,??DataTable5_1
   \   00000020   0818               ADDS     R0,R1,R0
   \   00000022   8088               LDRH     R0,[R0, #+4]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   04D1               BNE      ??NvIdle_4
    150                NvSaveDataSet(i);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   \   0000002E   ........           BL       NvSaveDataSet
    151              }
    152            }
   \                     ??NvIdle_4:
   \   00000032   641C               ADDS     R4,R4,#+1
   \   00000034   EBE7               B        ??NvIdle_2
    153          #endif
    154          }                                       /* NvIdle() */
   \                     ??NvIdle_3:
   \                     ??NvIdle_0:
   \   00000036   10BC               POP      {R4}
   \   00000038   08BC               POP      {R3}
   \   0000003A   1847               BX       R3               ;; return
    155          
    156          /****************************************************************************/
    157          
    158          /* Return TRUE if the given data set is dirty. */

   \                                 In section .text, align 2, keep-with-next
    159          bool_t NvIsDataSetDirty
    160            (
    161            NvDataSetID_t dataSetID
    162            )
    163          {
   \                     NvIsDataSetDirty:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    164          #if !gNvStorageIncluded_d
    165            (void) dataSetID;
    166            return FALSE;
    167          #else
    168            index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       NvDataSetIndexFromID
   \   0000000E   0500               MOVS     R5,R0
    169            return (    maNvDirtyFlags[dataSetIndex].saveNextInterval
    170                    || (maNvDirtyFlags[dataSetIndex].countsToNextSave != gNvCountsBetweenSaves_c));
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   0620               MOVS     R0,#+6
   \   00000016   6843               MULS     R0,R5,R0
   \   00000018   ....               LDR      R1,??DataTable5_1
   \   0000001A   085C               LDRB     R0,[R1, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   0AD1               BNE      ??NvIsDataSetDirty_0
   \   00000020   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000022   2D0E               LSRS     R5,R5,#+24
   \   00000024   0620               MOVS     R0,#+6
   \   00000026   4543               MULS     R5,R0,R5
   \   00000028   ....               LDR      R0,??DataTable5_1
   \   0000002A   4019               ADDS     R0,R0,R5
   \   0000002C   8088               LDRH     R0,[R0, #+4]
   \   0000002E   8021               MOVS     R1,#+128
   \   00000030   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000032   8842               CMP      R0,R1
   \   00000034   01D0               BEQ      ??NvIsDataSetDirty_1
   \                     ??NvIsDataSetDirty_0:
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   00E0               B        ??NvIsDataSetDirty_2
   \                     ??NvIsDataSetDirty_1:
   \   0000003A   0020               MOVS     R0,#+0
   \                     ??NvIsDataSetDirty_2:
   \   0000003C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000003E   000E               LSRS     R0,R0,#+24
   \   00000040   32BC               POP      {R1,R4,R5}
   \   00000042   08BC               POP      {R3}
   \   00000044   1847               BX       R3               ;; return
    171          #endif                                  /* #if !gNvStorageIncluded_d #else */
    172          }                                       /* NvIsDataSetDirty() */
    173          
    174          /****************************************************************************/
    175          
    176          /* Call this once, before calling any other NV function.
    177           *
    178           * Any page that does not contain a valid, recognized data set is erased, in
    179           * preparation for later reuse.
    180           *
    181           * It is unlikely, but possible, that there could be more than one copy of one
    182           * or more data sets in NV storage. Normally the page containing the older
    183           * version is erased after the new version is written, but a reset at just
    184           * the wrong time could prevent the erasure.
    185           *
    186           * Having more than one copy of any data set is 1) unnecessary, 2) uses space
    187           * that may be needed for future writes, and 3) would complicate other NV code.
    188           * This function scans NV storage for alternate versions of the same data set,
    189           * and if it finds one, erases the older copy (or copies).
    190           */

   \                                 In section .text, align 2, keep-with-next
    191          void NvModuleInit(void)
    192          {
   \                     NvModuleInit:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   87B0               SUB      SP,SP,#+28
    193          #if gNvStorageIncluded_d
    194          #if gNvDebug_d
    195            NvDataItemDescription_t const *pDataItemDescriptions;
    196            index_t dataSetIndex;
    197            NvSize_t dataSetSize;
    198          #endif
    199            index_t i;
    200            index_t sectorIndex;
    201            NvRawSectorAddress_t      oldSectAddress , newSectAddress;
    202            NvSectorSequenceNumber_t  oldSectSeq , newSectSeq;
    203            NvSectPageInfo_t oldSectPageInfo ,  newSectPageInfo;
    204            NvRawPageAddress_t firstBlankPageAddress;
    205            index_t firstBlankPageIndex;
    206            
    207          #if gNvDebug_d
    208            /* The CodeWarrior HCS08 compiler complains about constant == constant. */
    209            uint16_t NvMaxDataSetSize = gNvMaxDataSetSize_c;
    210          #endif
    211            /* Power up the NVM */
    212            PowerUpNVM();
   \   00000004   ........           BL       PowerUpNVM
    213            /* initialize flash layer */
    214            NvHalInit();
   \   00000008   ........           BL       NvHalInit
    215            
    216            /* No data set starts dirty. */
    217            for (i = 0; i < gNvNumberOfDataSets_c; ++i)
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0500               MOVS     R5,R0
   \                     ??NvModuleInit_0:
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   022D               CMP      R5,#+2
   \   00000016   11D2               BCS      ??NvModuleInit_1
    218            {
    219              maNvDirtyFlags[i].saveNextInterval = FALSE;
   \   00000018   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001A   2D0E               LSRS     R5,R5,#+24
   \   0000001C   0620               MOVS     R0,#+6
   \   0000001E   6843               MULS     R0,R5,R0
   \   00000020   ....               LDR      R1,??DataTable5_1
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   0A54               STRB     R2,[R1, R0]
    220              maNvDirtyFlags[i].countsToNextSave = gNvCountsBetweenSaves;
   \   00000026   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000028   2D0E               LSRS     R5,R5,#+24
   \   0000002A   0620               MOVS     R0,#+6
   \   0000002C   6843               MULS     R0,R5,R0
   \   0000002E   ....               LDR      R1,??DataTable5_1
   \   00000030   0818               ADDS     R0,R1,R0
   \   00000032   ....               LDR      R1,??DataTable7
   \   00000034   0988               LDRH     R1,[R1, #+0]
   \   00000036   8180               STRH     R1,[R0, #+4]
    221            }
   \   00000038   6D1C               ADDS     R5,R5,#+1
   \   0000003A   E9E7               B        ??NvModuleInit_0
    222            
    223            /* Scan for and erase duplicate copies of data sets. This code is very */
    224            /* slow (N^2), but it only runs once, and N is small. Data set IDs are */
    225            /* arbitrary values, so its necessary to search through the list. */
    226            
    227            /* Visit every raw page. If it isn't a valid data set, and it isn't clean, */
    228            /* erase it. */
    229            
    230            newSectAddress = gUninitAddress;
   \                     ??NvModuleInit_1:
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   C043               MVNS     R0,R0            ;; #-1
   \   00000040   0600               MOVS     R6,R0
    231            for (sectorIndex = 0; sectorIndex < gNvNumberOfRawSectors_c; ++sectorIndex)
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   0400               MOVS     R4,R0
   \                     ??NvModuleInit_2:
   \   00000046   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000048   240E               LSRS     R4,R4,#+24
   \   0000004A   022C               CMP      R4,#+2
   \   0000004C   77D2               BCS      ??NvModuleInit_3
    232            {
    233              
    234              if (!NvIsValidSector(maNvRawSectorAddressTable[sectorIndex])) 
   \   0000004E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000050   240E               LSRS     R4,R4,#+24
   \   00000052   0420               MOVS     R0,#+4
   \   00000054   6043               MULS     R0,R4,R0
   \   00000056   ....               LDR      R1,??DataTable8
   \   00000058   0858               LDR      R0,[R1, R0]
   \   0000005A   ........           BL       NvIsValidSector
   \   0000005E   0028               CMP      R0,#+0
   \   00000060   15D1               BNE      ??NvModuleInit_4
    235              {
    236                if( !NvHalIsBlank(maNvRawSectorAddressTable[sectorIndex] , 0 , sizeof(NvRawSector_t)) )
   \   00000062   8022               MOVS     R2,#+128
   \   00000064   5201               LSLS     R2,R2,#+5        ;; #+4096
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000006A   240E               LSRS     R4,R4,#+24
   \   0000006C   0420               MOVS     R0,#+4
   \   0000006E   6043               MULS     R0,R4,R0
   \   00000070   ....               LDR      R3,??DataTable8
   \   00000072   1858               LDR      R0,[R3, R0]
   \   00000074   ........           BL       NvHalIsBlank
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   5ED1               BNE      ??NvModuleInit_5
    237                {
    238                  NvHalEraseSector(maNvRawSectorAddressTable[sectorIndex]);
   \   0000007C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000007E   240E               LSRS     R4,R4,#+24
   \   00000080   0420               MOVS     R0,#+4
   \   00000082   6043               MULS     R0,R4,R0
   \   00000084   ....               LDR      R1,??DataTable8
   \   00000086   0858               LDR      R0,[R1, R0]
   \   00000088   ........           BL       NvHalEraseSector
   \   0000008C   55E0               B        ??NvModuleInit_5
    239                }
    240              } 
    241              else
    242              {
    243                if(newSectAddress != gUninitAddress )
   \                     ??NvModuleInit_4:
   \   0000008E   0020               MOVS     R0,#+0
   \   00000090   C043               MVNS     R0,R0            ;; #-1
   \   00000092   8642               CMP      R6,R0
   \   00000094   4AD0               BEQ      ??NvModuleInit_6
    244                {
    245                  newSectSeq = NvGetSectorSequenceNumber(newSectAddress);
   \   00000096   3000               MOVS     R0,R6
   \   00000098   ........           BL       NvGetSectorSequenceNumber
   \   0000009C   6946               MOV      R1,SP
   \   0000009E   8871               STRB     R0,[R1, #+6]
    246                  oldSectSeq =   NvGetSectorSequenceNumber(maNvRawSectorAddressTable[sectorIndex]);
   \   000000A0   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000A2   240E               LSRS     R4,R4,#+24
   \   000000A4   0420               MOVS     R0,#+4
   \   000000A6   6043               MULS     R0,R4,R0
   \   000000A8   ....               LDR      R1,??DataTable8
   \   000000AA   0858               LDR      R0,[R1, R0]
   \   000000AC   ........           BL       NvGetSectorSequenceNumber
   \   000000B0   6946               MOV      R1,SP
   \   000000B2   0871               STRB     R0,[R1, #+4]
    247                  if(oldSectSeq ==  NvLastSectorSequence ( newSectSeq ,oldSectSeq )  )
   \   000000B4   6846               MOV      R0,SP
   \   000000B6   0179               LDRB     R1,[R0, #+4]
   \   000000B8   0091               STR      R1,[SP, #+0]
   \   000000BA   6846               MOV      R0,SP
   \   000000BC   0179               LDRB     R1,[R0, #+4]
   \   000000BE   6846               MOV      R0,SP
   \   000000C0   8079               LDRB     R0,[R0, #+6]
   \   000000C2   ........           BL       NvLastSectorSequence
   \   000000C6   0099               LDR      R1,[SP, #+0]
   \   000000C8   8142               CMP      R1,R0
   \   000000CA   08D1               BNE      ??NvModuleInit_7
    248                  {
    249                    oldSectAddress = newSectAddress ;
   \   000000CC   3700               MOVS     R7,R6
    250                    newSectAddress = maNvRawSectorAddressTable[sectorIndex];
   \   000000CE   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000D0   240E               LSRS     R4,R4,#+24
   \   000000D2   0420               MOVS     R0,#+4
   \   000000D4   6043               MULS     R0,R4,R0
   \   000000D6   ....               LDR      R1,??DataTable8
   \   000000D8   0858               LDR      R0,[R1, R0]
   \   000000DA   0600               MOVS     R6,R0
   \   000000DC   06E0               B        ??NvModuleInit_8
    251                  }
    252                  else
    253                  {
    254                    oldSectAddress = maNvRawSectorAddressTable[sectorIndex];
   \                     ??NvModuleInit_7:
   \   000000DE   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000E0   240E               LSRS     R4,R4,#+24
   \   000000E2   0420               MOVS     R0,#+4
   \   000000E4   6043               MULS     R0,R4,R0
   \   000000E6   ....               LDR      R1,??DataTable8
   \   000000E8   0858               LDR      R0,[R1, R0]
   \   000000EA   0700               MOVS     R7,R0
    255                  }
    256                  NvGetSectorPageInfo ( newSectAddress, &newSectPageInfo );
   \                     ??NvModuleInit_8:
   \   000000EC   03A9               ADD      R1,SP,#+12
   \   000000EE   3000               MOVS     R0,R6
   \   000000F0   ........           BL       NvGetSectorPageInfo
    257                  NvGetSectorPageInfo ( oldSectAddress, &oldSectPageInfo );
   \   000000F4   05A9               ADD      R1,SP,#+20
   \   000000F6   3800               MOVS     R0,R7
   \   000000F8   ........           BL       NvGetSectorPageInfo
    258                  NvGetFirstBlankPageInfo ( newSectAddress , &firstBlankPageAddress, &firstBlankPageIndex );
   \   000000FC   01AA               ADD      R2,SP,#+4
   \   000000FE   521C               ADDS     R2,R2,#+1
   \   00000100   02A9               ADD      R1,SP,#+8
   \   00000102   3000               MOVS     R0,R6
   \   00000104   ........           BL       NvGetFirstBlankPageInfo
    259                  if( NvCopyTheRemainsDataSets(  &oldSectPageInfo , &newSectPageInfo, firstBlankPageAddress,firstBlankPageIndex))
   \   00000108   6846               MOV      R0,SP
   \   0000010A   4379               LDRB     R3,[R0, #+5]
   \   0000010C   029A               LDR      R2,[SP, #+8]
   \   0000010E   03A9               ADD      R1,SP,#+12
   \   00000110   05A8               ADD      R0,SP,#+20
   \   00000112   ........           BL       NvCopyTheRemainsDataSets
   \   00000116   0028               CMP      R0,#+0
   \   00000118   04D0               BEQ      ??NvModuleInit_9
    260                  {
    261                    // copy of te rest of data sets failed
    262                    NvHalEraseSector(newSectAddress);
   \   0000011A   3000               MOVS     R0,R6
   \   0000011C   ........           BL       NvHalEraseSector
    263                    newSectAddress = oldSectAddress;
   \   00000120   3E00               MOVS     R6,R7
   \   00000122   0AE0               B        ??NvModuleInit_5
    264                  }
    265                  else
    266                  {
    267                    NvHalEraseSector(oldSectAddress);
   \                     ??NvModuleInit_9:
   \   00000124   3800               MOVS     R0,R7
   \   00000126   ........           BL       NvHalEraseSector
   \   0000012A   06E0               B        ??NvModuleInit_5
    268                  }
    269                }
    270                else // if(newSectAddress != gUninitAddress )
    271                {
    272                  newSectAddress = maNvRawSectorAddressTable[sectorIndex];
   \                     ??NvModuleInit_6:
   \   0000012C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000012E   240E               LSRS     R4,R4,#+24
   \   00000130   0420               MOVS     R0,#+4
   \   00000132   6043               MULS     R0,R4,R0
   \   00000134   ....               LDR      R1,??DataTable8
   \   00000136   0858               LDR      R0,[R1, R0]
   \   00000138   0600               MOVS     R6,R0
    273                }
    274              }                                   /* if (!NvIsValidDataSet(... else */
    275            }
   \                     ??NvModuleInit_5:
   \   0000013A   641C               ADDS     R4,R4,#+1
   \   0000013C   83E7               B        ??NvModuleInit_2
    276            
    277            
    278            
    279            
    280            /* for (pageIndex = 0; ... */
    281            
    282          #if gNvDebug_d
    283            /* NVM_Interface.h defines the size of the client area of a page as an */
    284            /* unjustified immediate integer constant. Make sure that its correct. */
    285            /* Assert if it isn't. */
    286            if (NvMaxDataSetSize != MbrSizeof(NvStructuredPage_t, clientData)) {
    287              for (;;)
    288              { }
    289            }
    290            
    291            /* Verify that all of the data sets defined by the client code will */
    292            /* fit into the NV storage page size. Doing this once here simplifies */
    293            /* other code. */
    294            for (dataSetIndex = 0; dataSetIndex < gNvNumberOfDataSets_c; ++dataSetIndex) {
    295              pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
    296              if (!pDataItemDescriptions) {
    297                continue;
    298              }
    299              dataSetSize = 0;
    300              
    301              while (pDataItemDescriptions->length) {
    302                dataSetSize += pDataItemDescriptions->length;
    303                ++pDataItemDescriptions;
    304              }
    305              
    306              /* Assert if the data set is too big. */
    307              if (dataSetSize > MbrSizeof(NvStructuredPage_t, clientData)) {
    308                for (;;)
    309                { }
    310              }
    311            }
    312          #endif                                  /* #if gNvDebug_d */
    313            
    314            /* Power down the NVM */
    315            PowerDownNVM();
   \                     ??NvModuleInit_3:
   \   0000013E   ........           BL       PowerDownNVM
    316            
    317          #if gNvSelfTest_d
    318            NvSelfTest();
    319          #endif
    320          #endif                                  /* #if gNvStorageIncluded_d */
    321          }                                       /* NvModuleInit() */
   \   00000142   07B0               ADD      SP,SP,#+28
   \   00000144   F0BC               POP      {R4-R7}
   \   00000146   08BC               POP      {R3}
   \   00000148   1847               BX       R3               ;; return
    322          
    323          /****************************************************************************/
    324          
    325          /* Search for a specific data structure in NV storage, delimited by a known
    326           * string at the beginning and end of the struct, and a known structure length.
    327           * The length includes both strings. The "strings" contain arbitrary bytes;
    328           * they are not assumed to be null-terminated C strings.
    329           *
    330           * This function is only indended for use by by the early startup code (crt0
    331           * and PlatformInit), which needs to find a struct containing hardware
    332           * initialization values.
    333           *
    334           * At that point in the startup process, the stack is available, but no data
    335           * in RAM has been initialized yet. ONLY const data (in ROM) is dependable.
    336           * NvModuleInit() has not been called yet to initialize this module. Be very
    337           * careful about calling local functions.
    338           * NvHalInit() has not been called yet. Do not call HAL functions, directly
    339           * or indirectly.
    340           *
    341           * Return a pointer to the NV storage copy of the data if found.
    342           * Return NULL if not found.
    343           */
    344          //void const *pNvPrimitiveSearch

   \                                 In section .text, align 2, keep-with-next
    345          uint32_t NvPrimitiveSearch
    346            (
    347            unsigned char *pDelimiterString,
    348            index_t delimiterStringLen,
    349            NvSize_t totalStructLen
    350            )
    351          {
   \                     NvPrimitiveSearch:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   84B0               SUB      SP,SP,#+16
    352          #if !gNvStorageIncluded_d
    353            (void) pDelimiterString;
    354            (void) delimiterStringLen;
    355            (void) totalStructLen;
    356            return 0;
    357          #else
    358            NvSize_t lastStartingOffset;
    359            index_t pageIndex;
    360            NvSize_t pageOffset;
    361            index_t sectorIndex;
    362            NvSectPageInfo_t sectPageInfo;
    363            NvRawPageAddress_t pageAddress;
    364            /* If the first string isn't found by lastStartingOffset, the struct */
    365            /* is not present in the page. */
    366            lastStartingOffset = sizeof(NvRawPage_t)
    367                               - sizeof(NvStructuredPageHeader_t)     /* Trailer. */
    368                               - totalStructLen;
   \   00000004   6846               MOV      R0,SP
   \   00000006   FD21               MOVS     R1,#+253
   \   00000008   4900               LSLS     R1,R1,#+1        ;; #+506
   \   0000000A   6A46               MOV      R2,SP
   \   0000000C   128B               LDRH     R2,[R2, #+24]
   \   0000000E   891A               SUBS     R1,R1,R2
   \   00000010   0180               STRH     R1,[R0, #+0]
    369            /* Power up the NVM */
    370            PowerUpNVM();
   \   00000012   ........           BL       PowerUpNVM
    371            /* Scan the NV storage pages. Invalid pages are ignored. */
    372              for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   0500               MOVS     R5,R0
   \                     ??NvPrimitiveSearch_0:
   \   0000001A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001C   2D0E               LSRS     R5,R5,#+24
   \   0000001E   022D               CMP      R5,#+2
   \   00000020   0BD2               BCS      ??NvPrimitiveSearch_1
    373                 {
    374                  if(NvIsValidSector(maNvRawSectorAddressTable[sectorIndex]))
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   0420               MOVS     R0,#+4
   \   00000028   6843               MULS     R0,R5,R0
   \   0000002A   ....               LDR      R1,??DataTable8
   \   0000002C   0858               LDR      R0,[R1, R0]
   \   0000002E   ........           BL       NvIsValidSector
   \   00000032   0028               CMP      R0,#+0
   \   00000034   01D1               BNE      ??NvPrimitiveSearch_1
    375                   {
    376                    break;
    377                   }
    378                 }
   \                     ??NvPrimitiveSearch_2:
   \   00000036   6D1C               ADDS     R5,R5,#+1
   \   00000038   EFE7               B        ??NvPrimitiveSearch_0
    379              if(sectorIndex == gNvNumberOfRawSectors_c)
   \                     ??NvPrimitiveSearch_1:
   \   0000003A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003C   2D0E               LSRS     R5,R5,#+24
   \   0000003E   022D               CMP      R5,#+2
   \   00000040   03D1               BNE      ??NvPrimitiveSearch_3
    380                {
    381                 PowerDownNVM();
   \   00000042   ........           BL       PowerDownNVM
    382                 return 0;
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   53E0               B        ??NvPrimitiveSearch_4
    383                }
    384              NvGetSectorPageInfo ( maNvRawSectorAddressTable[sectorIndex], &sectPageInfo );
   \                     ??NvPrimitiveSearch_3:
   \   0000004A   01A9               ADD      R1,SP,#+4
   \   0000004C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000004E   2D0E               LSRS     R5,R5,#+24
   \   00000050   0420               MOVS     R0,#+4
   \   00000052   6843               MULS     R0,R5,R0
   \   00000054   ....               LDR      R2,??DataTable8
   \   00000056   1058               LDR      R0,[R2, R0]
   \   00000058   ........           BL       NvGetSectorPageInfo
    385              
    386              for(pageIndex = 0; pageIndex < gNvNumberOfDataSets_c; pageIndex++)
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   0600               MOVS     R6,R0
   \                     ??NvPrimitiveSearch_5:
   \   00000060   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000062   360E               LSRS     R6,R6,#+24
   \   00000064   022E               CMP      R6,#+2
   \   00000066   41D2               BCS      ??NvPrimitiveSearch_6
    387                {
    388                   if(sectPageInfo[pageIndex] != gUninitAddress)
   \   00000068   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   0000006A   360E               LSRS     R6,R6,#+24
   \   0000006C   0420               MOVS     R0,#+4
   \   0000006E   7043               MULS     R0,R6,R0
   \   00000070   01A9               ADD      R1,SP,#+4
   \   00000072   0858               LDR      R0,[R1, R0]
   \   00000074   0021               MOVS     R1,#+0
   \   00000076   C943               MVNS     R1,R1            ;; #-1
   \   00000078   8842               CMP      R0,R1
   \   0000007A   35D0               BEQ      ??NvPrimitiveSearch_7
    389                   {
    390                      pageAddress = sectPageInfo[pageIndex];
   \   0000007C   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   0000007E   360E               LSRS     R6,R6,#+24
   \   00000080   0420               MOVS     R0,#+4
   \   00000082   7043               MULS     R0,R6,R0
   \   00000084   01A9               ADD      R1,SP,#+4
   \   00000086   0858               LDR      R0,[R1, R0]
   \   00000088   0700               MOVS     R7,R0
    391                      for (pageOffset = sizeof(NvStructuredPageHeader_t); pageOffset <= lastStartingOffset;  ++pageOffset)
   \   0000008A   0220               MOVS     R0,#+2
   \   0000008C   0400               MOVS     R4,R0
   \                     ??NvPrimitiveSearch_8:
   \   0000008E   6846               MOV      R0,SP
   \   00000090   0088               LDRH     R0,[R0, #+0]
   \   00000092   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000094   240C               LSRS     R4,R4,#+16
   \   00000096   A042               CMP      R0,R4
   \   00000098   26D3               BCC      ??NvPrimitiveSearch_7
    392                         {               	
    393          
    394                         if (NvHalVerify(pageAddress,pageOffset,pDelimiterString,delimiterStringLen )
    395                          && NvHalVerify(pageAddress,pageOffset+totalStructLen - delimiterStringLen,pDelimiterString,delimiterStringLen ))
   \   0000009A   6846               MOV      R0,SP
   \   0000009C   037D               LDRB     R3,[R0, #+20]
   \   0000009E   1B04               LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
   \   000000A0   1B0C               LSRS     R3,R3,#+16
   \   000000A2   049A               LDR      R2,[SP, #+16]
   \   000000A4   2100               MOVS     R1,R4
   \   000000A6   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000A8   090C               LSRS     R1,R1,#+16
   \   000000AA   3800               MOVS     R0,R7
   \   000000AC   ........           BL       NvHalVerify
   \   000000B0   0028               CMP      R0,#+0
   \   000000B2   17D0               BEQ      ??NvPrimitiveSearch_9
   \   000000B4   6846               MOV      R0,SP
   \   000000B6   037D               LDRB     R3,[R0, #+20]
   \   000000B8   1B04               LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
   \   000000BA   1B0C               LSRS     R3,R3,#+16
   \   000000BC   049A               LDR      R2,[SP, #+16]
   \   000000BE   6846               MOV      R0,SP
   \   000000C0   008B               LDRH     R0,[R0, #+24]
   \   000000C2   2018               ADDS     R0,R4,R0
   \   000000C4   6946               MOV      R1,SP
   \   000000C6   097D               LDRB     R1,[R1, #+20]
   \   000000C8   411A               SUBS     R1,R0,R1
   \   000000CA   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000CC   090C               LSRS     R1,R1,#+16
   \   000000CE   3800               MOVS     R0,R7
   \   000000D0   ........           BL       NvHalVerify
   \   000000D4   0028               CMP      R0,#+0
   \   000000D6   05D0               BEQ      ??NvPrimitiveSearch_9
    396                             {
    397                                 /* Power down the NVM */
    398                               PowerDownNVM();
   \   000000D8   ........           BL       PowerDownNVM
    399                               return pageAddress + pageOffset;
   \   000000DC   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   000000DE   240C               LSRS     R4,R4,#+16
   \   000000E0   3819               ADDS     R0,R7,R4
   \   000000E2   06E0               B        ??NvPrimitiveSearch_4
    400                    
    401                             }                               /* if (NvHalVerify(pageIndex,pag ... */
    402                         }                                   /* for (pageOffset = sizeof ... */
   \                     ??NvPrimitiveSearch_9:
   \   000000E4   641C               ADDS     R4,R4,#+1
   \   000000E6   D2E7               B        ??NvPrimitiveSearch_8
    403                     
    404                   }
    405                }
   \                     ??NvPrimitiveSearch_7:
   \   000000E8   761C               ADDS     R6,R6,#+1
   \   000000EA   B9E7               B        ??NvPrimitiveSearch_5
    406              
    407            
    408            /* Power down the NVM */
    409            PowerDownNVM();
   \                     ??NvPrimitiveSearch_6:
   \   000000EC   ........           BL       PowerDownNVM
    410            return 0;
   \   000000F0   0020               MOVS     R0,#+0
   \                     ??NvPrimitiveSearch_4:
   \   000000F2   07B0               ADD      SP,SP,#+28
   \   000000F4   F0BC               POP      {R4-R7}
   \   000000F6   08BC               POP      {R3}
   \   000000F8   1847               BX       R3               ;; return
    411          #endif                                  /* #if !gNvStorageIncluded_d #else */
    412          }                                       /* pNvPrimitiveSearch() */
    413          
    414                                                 /* NvRestoreDataSet() */
    415          
    416          /****************************************************************************/
    417          
    418          /* Copy the most recent version of a data set from NV storage to RAM. */
    419          /* Note that the copy will succeed if a valid copy of the data set is found */
    420          /* in NV storage, regardless of the state of the data set's dirty flag. */
    421          /* Return TRUE if the copy is successful. */
    422          

   \                                 In section .text, align 2, keep-with-next
    423          bool_t NvRestoreDataSet
    424            (
    425            NvDataSetID_t dataSetID
    426           )
    427          {
   \                     NvRestoreDataSet:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   84B0               SUB      SP,SP,#+16
    428          #if !gNvStorageIncluded_d
    429            (void) dataSetID;
    430            return FALSE;
    431          #else
    432            NvDataItemDescription_t const *pDataItemDescriptions;
    433            index_t dataSetIndex;
    434            index_t sectorIndex;
    435            NvRawSectorAddress_t sectorAddress;
    436            NvSectPageInfo_t sectPageInfo;
    437            NvSize_t pageOffset;
    438            /* Power up the NVM */
    439            PowerUpNVM();
   \   00000004   ........           BL       PowerUpNVM
    440            /* Find the data set description. */
    441            dataSetIndex = NvDataSetIndexFromID(dataSetID);
   \   00000008   6846               MOV      R0,SP
   \   0000000A   007C               LDRB     R0,[R0, #+16]
   \   0000000C   ........           BL       NvDataSetIndexFromID
   \   00000010   0700               MOVS     R7,R0
    442            
    443            for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   0400               MOVS     R4,R0
   \                     ??NvRestoreDataSet_0:
   \   00000016   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \   0000001A   022C               CMP      R4,#+2
   \   0000001C   0DD2               BCS      ??NvRestoreDataSet_1
    444                 {
    445                 sectorAddress = maNvRawSectorAddressTable[sectorIndex];  
   \   0000001E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000020   240E               LSRS     R4,R4,#+24
   \   00000022   0420               MOVS     R0,#+4
   \   00000024   6043               MULS     R0,R4,R0
   \   00000026   ....               LDR      R1,??DataTable8
   \   00000028   0858               LDR      R0,[R1, R0]
   \   0000002A   0090               STR      R0,[SP, #+0]
    446                 if(NvIsValidSector(sectorAddress))
   \   0000002C   0098               LDR      R0,[SP, #+0]
   \   0000002E   ........           BL       NvIsValidSector
   \   00000032   0028               CMP      R0,#+0
   \   00000034   01D1               BNE      ??NvRestoreDataSet_1
    447                   {
    448                    break;
    449                   }
    450                 }
   \                     ??NvRestoreDataSet_2:
   \   00000036   641C               ADDS     R4,R4,#+1
   \   00000038   EDE7               B        ??NvRestoreDataSet_0
    451            if(sectorIndex == gNvNumberOfRawSectors_c)
   \                     ??NvRestoreDataSet_1:
   \   0000003A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000003C   240E               LSRS     R4,R4,#+24
   \   0000003E   022C               CMP      R4,#+2
   \   00000040   03D1               BNE      ??NvRestoreDataSet_3
    452            {
    453              // there are no valid sectors
    454              PowerDownNVM(); 
   \   00000042   ........           BL       PowerDownNVM
    455              return FALSE;
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   44E0               B        ??NvRestoreDataSet_4
    456            }
    457          
    458            NvGetSectorPageInfo(sectorAddress , &sectPageInfo);
   \                     ??NvRestoreDataSet_3:
   \   0000004A   01A9               ADD      R1,SP,#+4
   \   0000004C   0098               LDR      R0,[SP, #+0]
   \   0000004E   ........           BL       NvGetSectorPageInfo
    459            if(sectPageInfo[dataSetIndex] == gUninitAddress)
   \   00000052   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000054   3F0E               LSRS     R7,R7,#+24
   \   00000056   0420               MOVS     R0,#+4
   \   00000058   7843               MULS     R0,R7,R0
   \   0000005A   01A9               ADD      R1,SP,#+4
   \   0000005C   0858               LDR      R0,[R1, R0]
   \   0000005E   0021               MOVS     R1,#+0
   \   00000060   C943               MVNS     R1,R1            ;; #-1
   \   00000062   8842               CMP      R0,R1
   \   00000064   03D1               BNE      ??NvRestoreDataSet_5
    460            {
    461              // the page does not exist in the valid sector
    462              PowerDownNVM(); 
   \   00000066   ........           BL       PowerDownNVM
    463              return FALSE;
   \   0000006A   0020               MOVS     R0,#+0
   \   0000006C   32E0               B        ??NvRestoreDataSet_4
    464            }
    465            pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
   \                     ??NvRestoreDataSet_5:
   \   0000006E   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000070   3F0E               LSRS     R7,R7,#+24
   \   00000072   0820               MOVS     R0,#+8
   \   00000074   7843               MULS     R0,R7,R0
   \   00000076   ....               LDR      R1,??DataTable17
   \   00000078   0818               ADDS     R0,R1,R0
   \   0000007A   4068               LDR      R0,[R0, #+4]
   \   0000007C   0600               MOVS     R6,R0
    466          
    467            /* Start reading just after the page header. */
    468            pageOffset = sizeof(NvStructuredPageHeader_t);
   \   0000007E   0220               MOVS     R0,#+2
   \   00000080   0500               MOVS     R5,R0
    469          
    470            /* Copy data from the NV storage page to the destination data set. */
    471            while (pDataItemDescriptions->length)
   \                     ??NvRestoreDataSet_6:
   \   00000082   B088               LDRH     R0,[R6, #+4]
   \   00000084   0028               CMP      R0,#+0
   \   00000086   12D0               BEQ      ??NvRestoreDataSet_7
    472            {
    473              NvHalRead(sectPageInfo[dataSetIndex], pageOffset, (uint8_t*)pDataItemDescriptions->pointer, pDataItemDescriptions->length);
   \   00000088   B388               LDRH     R3,[R6, #+4]
   \   0000008A   3268               LDR      R2,[R6, #+0]
   \   0000008C   2900               MOVS     R1,R5
   \   0000008E   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000090   090C               LSRS     R1,R1,#+16
   \   00000092   0D00               MOVS     R5,R1
   \   00000094   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000096   3F0E               LSRS     R7,R7,#+24
   \   00000098   0421               MOVS     R1,#+4
   \   0000009A   7943               MULS     R1,R7,R1
   \   0000009C   01A8               ADD      R0,SP,#+4
   \   0000009E   4058               LDR      R0,[R0, R1]
   \   000000A0   2900               MOVS     R1,R5
   \   000000A2   ........           BL       NvHalRead
    474              pageOffset += pDataItemDescriptions->length;
   \   000000A6   B088               LDRH     R0,[R6, #+4]
   \   000000A8   2D18               ADDS     R5,R5,R0
    475              ++pDataItemDescriptions;
   \   000000AA   0836               ADDS     R6,R6,#+8
   \   000000AC   E9E7               B        ??NvRestoreDataSet_6
    476            }
    477          
    478            maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
   \                     ??NvRestoreDataSet_7:
   \   000000AE   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   000000B0   3F0E               LSRS     R7,R7,#+24
   \   000000B2   0620               MOVS     R0,#+6
   \   000000B4   7843               MULS     R0,R7,R0
   \   000000B6   ....               LDR      R1,??DataTable7_1
   \   000000B8   0022               MOVS     R2,#+0
   \   000000BA   0A54               STRB     R2,[R1, R0]
    479            maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
   \   000000BC   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   000000BE   3F0E               LSRS     R7,R7,#+24
   \   000000C0   0620               MOVS     R0,#+6
   \   000000C2   7843               MULS     R0,R7,R0
   \   000000C4   ....               LDR      R1,??DataTable7_1
   \   000000C6   0818               ADDS     R0,R1,R0
   \   000000C8   8021               MOVS     R1,#+128
   \   000000CA   4900               LSLS     R1,R1,#+1        ;; #+256
   \   000000CC   8180               STRH     R1,[R0, #+4]
    480            /* Power down the NVM */
    481            PowerDownNVM();
   \   000000CE   ........           BL       PowerDownNVM
    482            return TRUE;
   \   000000D2   0120               MOVS     R0,#+1
   \                     ??NvRestoreDataSet_4:
   \   000000D4   05B0               ADD      SP,SP,#+20
   \   000000D6   F0BC               POP      {R4-R7}
   \   000000D8   08BC               POP      {R3}
   \   000000DA   1847               BX       R3               ;; return
    483          #endif                                  /* #if !gNvStorageIncluded_d #else */
    484          }
    485          /****************************************************************************/
    486          
    487          /* Save the data set on the next call to NvIdle(). */
    488          /* Use the save-on-count mechanism. */

   \                                 In section .text, align 2, keep-with-next
    489          void NvSaveOnIdle
    490            (
    491            NvDataSetID_t dataSetID
    492           )
    493          {
   \                     NvSaveOnIdle:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    494          #if !gNvStorageIncluded_d
    495            (void) dataSetID;
    496          #else
    497            maNvDirtyFlags[NvDataSetIndexFromID(dataSetID)].countsToNextSave = 0;
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       NvDataSetIndexFromID
   \   0000000E   0621               MOVS     R1,#+6
   \   00000010   4843               MULS     R0,R1,R0
   \   00000012   ....               LDR      R1,??DataTable18
   \   00000014   0818               ADDS     R0,R1,R0
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   8180               STRH     R1,[R0, #+4]
    498          #endif
    499          }
   \   0000001A   10BC               POP      {R4}
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
    500          
    501          /****************************************************************************/
    502          

   \                                 In section .text, align 2, keep-with-next
    503          void NvSaveOnInterval
    504            (
    505            NvDataSetID_t dataSetID
    506           )
    507          {
   \                     NvSaveOnInterval:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    508          #if !gNvStorageIncluded_d
    509            (void) dataSetID;
    510          #else
    511            index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       NvDataSetIndexFromID
   \   0000000E   0500               MOVS     R5,R0
    512          
    513            if (!maNvDirtyFlags[dataSetIndex].saveNextInterval) {
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   0620               MOVS     R0,#+6
   \   00000016   6843               MULS     R0,R5,R0
   \   00000018   ....               LDR      R1,??DataTable18
   \   0000001A   085C               LDRB     R0,[R1, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   13D1               BNE      ??NvSaveOnInterval_0
    514              maNvDirtyFlags[dataSetIndex].ticksToNextSave  = gNvMinimumTicksBetweenSaves_c;
   \   00000020   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000022   2D0E               LSRS     R5,R5,#+24
   \   00000024   0620               MOVS     R0,#+6
   \   00000026   6843               MULS     R0,R5,R0
   \   00000028   ....               LDR      R1,??DataTable18
   \   0000002A   0818               ADDS     R0,R1,R0
   \   0000002C   0421               MOVS     R1,#+4
   \   0000002E   4180               STRH     R1,[R0, #+2]
    515              maNvDirtyFlags[dataSetIndex].saveNextInterval = TRUE;
   \   00000030   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000032   2D0E               LSRS     R5,R5,#+24
   \   00000034   0620               MOVS     R0,#+6
   \   00000036   6843               MULS     R0,R5,R0
   \   00000038   ....               LDR      R1,??DataTable18
   \   0000003A   0122               MOVS     R2,#+1
   \   0000003C   0A54               STRB     R2,[R1, R0]
    516              TS_SendEvent(gIdleTaskID, gIdleTaskNVIntervalEvent_c);  
   \   0000003E   0121               MOVS     R1,#+1
   \   00000040   ....               LDR      R0,??DataTable18_1
   \   00000042   0078               LDRB     R0,[R0, #+0]
   \   00000044   ........           BL       TS_SendEvent
    517            }
    518          #endif
    519          }                                       /* NvSaveOnInterval() */
   \                     ??NvSaveOnInterval_0:
   \   00000048   31BC               POP      {R0,R4,R5}
   \   0000004A   08BC               POP      {R3}
   \   0000004C   1847               BX       R3               ;; return
    520          
    521          /****************************************************************************/
    522          
    523          /* Decrement the counter. Once it reaches 0, the next call to NvIdle() will */
    524          /* save the data set. */

   \                                 In section .text, align 2, keep-with-next
    525          void NvSaveOnCount
    526            (
    527            NvDataSetID_t dataSetID
    528            )
    529          {
   \                     NvSaveOnCount:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    530          #if !gNvStorageIncluded_d
    531            (void) dataSetID;
    532          #else
    533            index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       NvDataSetIndexFromID
   \   0000000E   0500               MOVS     R5,R0
    534          
    535            if (maNvDirtyFlags[dataSetIndex].countsToNextSave) {
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   0620               MOVS     R0,#+6
   \   00000016   6843               MULS     R0,R5,R0
   \   00000018   ....               LDR      R1,??DataTable18
   \   0000001A   0818               ADDS     R0,R1,R0
   \   0000001C   8088               LDRH     R0,[R0, #+4]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   0ED0               BEQ      ??NvSaveOnCount_0
    536              --maNvDirtyFlags[dataSetIndex].countsToNextSave;
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   0620               MOVS     R0,#+6
   \   00000028   6843               MULS     R0,R5,R0
   \   0000002A   ....               LDR      R1,??DataTable18
   \   0000002C   0818               ADDS     R0,R1,R0
   \   0000002E   8088               LDRH     R0,[R0, #+4]
   \   00000030   401E               SUBS     R0,R0,#+1
   \   00000032   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000034   2D0E               LSRS     R5,R5,#+24
   \   00000036   0621               MOVS     R1,#+6
   \   00000038   6943               MULS     R1,R5,R1
   \   0000003A   ....               LDR      R2,??DataTable18
   \   0000003C   5118               ADDS     R1,R2,R1
   \   0000003E   8880               STRH     R0,[R1, #+4]
    537            }
    538          #endif
    539          }                                       /* NvSaveOnCount() */
   \                     ??NvSaveOnCount_0:
   \   00000040   31BC               POP      {R0,R4,R5}
   \   00000042   08BC               POP      {R3}
   \   00000044   1847               BX       R3               ;; return
    540          
    541          /****************************************************************************/
    542          
    543          /* Set the timer used by NvSaveOnInterval(). Takes effect after the next */
    544          /* save. */

   \                                 In section .text, align 2, keep-with-next
    545          void NvSetMinimumTicksBetweenSaves
    546            (
    547            NvSaveInterval_t newInterval
    548           )
    549          {
    550          #if !gNvStorageIncluded_d
    551            (void) newInterval;
    552          #else
    553            gNvMinimumTicksBetweenSaves = newInterval;
   \                     NvSetMinimumTicksBetweenSaves:
   \   00000000   ....               LDR      R1,??DataTable18_2
   \   00000002   0880               STRH     R0,[R1, #+0]
    554          #endif
    555          }                                       /* NvSetMinimumTicksBetweenSaves() */
   \   00000004   7047               BX       LR               ;; return
    556          
    557          /****************************************************************************/
    558          
    559          /* Set the counter trigger value used by NvSaveOnCount(). Takes effect */
    560          /* after the next save. */

   \                                 In section .text, align 2, keep-with-next
    561          void NvSetCountsBetweenSaves
    562            (
    563            NvSaveCounter_t newCounter
    564           )
    565          {
    566          #if !gNvStorageIncluded_d
    567            (void) newCounter;
    568          #else
    569            gNvCountsBetweenSaves = newCounter;
   \                     NvSetCountsBetweenSaves:
   \   00000000   ....               LDR      R1,??DataTable18_3
   \   00000002   0880               STRH     R0,[R1, #+0]
    570          #endif
    571          }                                       /* NvSetCountsBetweenSaves() */
   \   00000004   7047               BX       LR               ;; return
    572          
    573          /****************************************************************************/
    574          
    575          /* Called from the idle task to process save-on-interval requests. */
    576          /* Returns FALSE if the timer tick counters for all data sets have reached */
    577          /* zero. In this case, the timer can be turned off. */
    578          /* Returns TRUE if any of the data sets' timer tick counters have not yet */
    579          /* counted down to zero. In this case, the timer should be active. */

   \                                 In section .text, align 2, keep-with-next
    580          bool_t NvTimerTick(bool_t countTick)
    581          {
   \                     NvTimerTick:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0700               MOVS     R7,R0
    582          #if !gNvStorageIncluded_d
    583            (void) countTick;
    584            return FALSE;
    585          #else
    586            index_t i;
    587            bool_t fTicksLeft = FALSE;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0500               MOVS     R5,R0
    588            NvDataSetInfo_t *pDirtyFlags;
    589          
    590            if (countTick) {
   \   00000008   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000000A   3F0E               LSRS     R7,R7,#+24
   \   0000000C   002F               CMP      R7,#+0
   \   0000000E   24D0               BEQ      ??NvTimerTick_0
    591              pDirtyFlags = maNvDirtyFlags;
   \   00000010   ....               LDR      R0,??DataTable18
   \   00000012   0600               MOVS     R6,R0
    592              for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   0400               MOVS     R4,R0
   \                     ??NvTimerTick_1:
   \   00000018   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000001A   240E               LSRS     R4,R4,#+24
   \   0000001C   022C               CMP      R4,#+2
   \   0000001E   1CD2               BCS      ??NvTimerTick_0
    593                
    594                if(pDirtyFlags->ticksToNextSave)
   \   00000020   7088               LDRH     R0,[R6, #+2]
   \   00000022   0028               CMP      R0,#+0
   \   00000024   02D0               BEQ      ??NvTimerTick_2
    595                  --(pDirtyFlags->ticksToNextSave);
   \   00000026   7088               LDRH     R0,[R6, #+2]
   \   00000028   401E               SUBS     R0,R0,#+1
   \   0000002A   7080               STRH     R0,[R6, #+2]
    596                if(pDirtyFlags->ticksToNextSave)
   \                     ??NvTimerTick_2:
   \   0000002C   7088               LDRH     R0,[R6, #+2]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   01D0               BEQ      ??NvTimerTick_3
    597                  fTicksLeft = TRUE;
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   0500               MOVS     R5,R0
    598          
    599                if (pDirtyFlags->saveNextInterval
    600                    && !pDirtyFlags->ticksToNextSave
    601                    && !mNvCriticalSectionFlag) {
   \                     ??NvTimerTick_3:
   \   00000036   3078               LDRB     R0,[R6, #+0]
   \   00000038   0028               CMP      R0,#+0
   \   0000003A   0BD0               BEQ      ??NvTimerTick_4
   \   0000003C   7088               LDRH     R0,[R6, #+2]
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   08D1               BNE      ??NvTimerTick_4
   \   00000042   ....               LDR      R0,??DataTable18_4
   \   00000044   0078               LDRB     R0,[R0, #+0]
   \   00000046   0028               CMP      R0,#+0
   \   00000048   04D1               BNE      ??NvTimerTick_4
    602                  NvSaveDataSet(i);
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000004E   000E               LSRS     R0,R0,#+24
   \   00000050   ........           BL       NvSaveDataSet
    603                }
    604          
    605                ++pDirtyFlags;
   \                     ??NvTimerTick_4:
   \   00000054   B61D               ADDS     R6,R6,#+6
    606              }
   \   00000056   641C               ADDS     R4,R4,#+1
   \   00000058   DEE7               B        ??NvTimerTick_1
    607            }
    608          
    609            return fTicksLeft;
   \                     ??NvTimerTick_0:
   \   0000005A   2800               MOVS     R0,R5
   \   0000005C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000005E   000E               LSRS     R0,R0,#+24
   \   00000060   F2BC               POP      {R1,R4-R7}
   \   00000062   08BC               POP      {R3}
   \   00000064   1847               BX       R3               ;; return
    610          #endif
    611          }                                       /* NvTimerTick() */
    612          
    613          /*****************************************************************************
    614          ******************************************************************************
    615          * Private functions
    616          ******************************************************************************
    617          *****************************************************************************/
    618          /*****************************************************************************
    619          *  PowerUpNVM - Turns on the NVM voltage regulator
    620          ******************************************************************************/
    621          

   \                                 In section .text, align 2, keep-with-next
    622          void PowerUpNVM(void)
    623          {
   \                     PowerUpNVM:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    624            crmVRegCntl_t VRegCntl;
    625          
    626            VRegCntl.vReg = g1P8VReg_c;
   \   00000004   6846               MOV      R0,SP
   \   00000006   0221               MOVS     R1,#+2
   \   00000008   0170               STRB     R1,[R0, #+0]
    627            VRegCntl.cntl.vReg1P8VEn =1;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   0171               STRB     R1,[R0, #+4]
    628            CRM_VRegCntl(&VRegCntl);
   \   00000010   6846               MOV      R0,SP
   \   00000012   ........           BL       CRM_VRegCntl
    629            while(!CRM_VRegIsReady(V_REG_MASK_1P8V)){};
   \                     ??PowerUpNVM_0:
   \   00000016   ....               LDR      R0,??DataTable19  ;; 0x80003018
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   0100               MOVS     R1,R0
   \   0000001C   4903               LSLS     R1,R1,#+13       ;; ZeroExtS R1,R1,#+13,#+31
   \   0000001E   C90F               LSRS     R1,R1,#+31
   \   00000020   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000022   090E               LSRS     R1,R1,#+24
   \   00000024   0029               CMP      R1,#+0
   \   00000026   F6D0               BEQ      ??PowerUpNVM_0
    630          }
   \   00000028   0FBC               POP      {R0-R3}
   \   0000002A   1847               BX       R3               ;; return
    631          
    632          /*****************************************************************************
    633          *  PowerDownNVM - Turns off the NVM voltage regulator
    634          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    635          void PowerDownNVM(void)
    636          {
   \                     PowerDownNVM:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   83B0               SUB      SP,SP,#+12
    637            crmVRegCntl_t VRegCntl;
    638          
    639            VRegCntl.vReg = g1P8VReg_c;
   \   00000004   6846               MOV      R0,SP
   \   00000006   0221               MOVS     R1,#+2
   \   00000008   0170               STRB     R1,[R0, #+0]
    640            VRegCntl.cntl.vReg1P8VEn =0;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0171               STRB     R1,[R0, #+4]
    641            CRM_VRegCntl(&VRegCntl);
   \   00000010   6846               MOV      R0,SP
   \   00000012   ........           BL       CRM_VRegCntl
    642          }
   \   00000016   0FBC               POP      {R0-R3}
   \   00000018   1847               BX       R3               ;; return
    643          
    644          
    645          /****************************************************************************/
    646          
    647          /* Given a data set ID, return it's index in the NvDataSetTable[].
    648           * Data set IDs are arbitrary values, so they have to be searched for.
    649           */
    650          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    651          static index_t NvDataSetIndexFromID
    652            (
    653            NvDataSetID_t dataSetID
    654           )
    655          {
   \                     NvDataSetIndexFromID:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
    656            index_t i;
    657          
    658            for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   1000               MOVS     R0,R2
   \                     ??NvDataSetIndexFromID_0:
   \   00000008   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000A   000E               LSRS     R0,R0,#+24
   \   0000000C   0228               CMP      R0,#+2
   \   0000000E   17D2               BCS      ??NvDataSetIndexFromID_1
    659              if (NvDataSetTable[i].pItemDescriptions
    660                   && (NvDataSetTable[i].dataSetID == dataSetID)) {
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   0822               MOVS     R2,#+8
   \   00000016   4243               MULS     R2,R0,R2
   \   00000018   ....               LDR      R3,??DataTable17
   \   0000001A   9A18               ADDS     R2,R3,R2
   \   0000001C   5268               LDR      R2,[R2, #+4]
   \   0000001E   002A               CMP      R2,#+0
   \   00000020   0CD0               BEQ      ??NvDataSetIndexFromID_2
   \   00000022   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000024   000E               LSRS     R0,R0,#+24
   \   00000026   0822               MOVS     R2,#+8
   \   00000028   4243               MULS     R2,R0,R2
   \   0000002A   ....               LDR      R3,??DataTable17
   \   0000002C   9A5C               LDRB     R2,[R3, R2]
   \   0000002E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000030   090E               LSRS     R1,R1,#+24
   \   00000032   8A42               CMP      R2,R1
   \   00000034   02D1               BNE      ??NvDataSetIndexFromID_2
    661                return i;
   \   00000036   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000038   000E               LSRS     R0,R0,#+24
   \   0000003A   02E0               B        ??NvDataSetIndexFromID_3
    662              }
    663            }
   \                     ??NvDataSetIndexFromID_2:
   \   0000003C   401C               ADDS     R0,R0,#+1
   \   0000003E   E3E7               B        ??NvDataSetIndexFromID_0
    664          
    665            /* Can't find it. Must be a programming error in the caller. There's */
    666            /* no good way to handle errors, but at least this makes it obvious */
    667            /* during debugging. */
    668            for (;;) { }
   \                     ??NvDataSetIndexFromID_1:
   \   00000040   FEE7               B        ??NvDataSetIndexFromID_1
   \                     ??NvDataSetIndexFromID_3:
   \   00000042   08BC               POP      {R3}
   \   00000044   1847               BX       R3               ;; return
    669          }                                       /* NvDataSetIndexFromID() */
    670          #endif                                  /* #if gNvStorageIncluded_d */
    671          
    672          
    673          /****************************************************************************/
    674          
    675          /* Examine an NV storage page. Check the magic number, check that the header
    676           * and trailer match, and check that the data set ID is recognized by the
    677           * application's table of data set descriptions.
    678           * Return TRUE if it looks legit; FALSE otherwise.
    679           */
    680          
    681          
    682          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    683          static bool_t NvIsValidPage
    684            (
    685            NvRawPageAddress_t nvRawPageAddress , NvDataSetID_t *pDataSetID
    686            )
    687          {
   \                     NvIsValidPage:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0F00               MOVS     R7,R1
    688            bool_t legitDataSetID;
    689            index_t i;
    690            NvStructuredPageHeader_t pageHeader;
    691            
    692            NvHalRead(nvRawPageAddress,0,(unsigned char*)&pageHeader,sizeof(NvStructuredPageHeader_t));
   \   00000006   0223               MOVS     R3,#+2
   \   00000008   6A46               MOV      R2,SP
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   2800               MOVS     R0,R5
   \   0000000E   ........           BL       NvHalRead
    693             
    694          
    695            /* Is the data set ID legit? */
    696            for (legitDataSetID = FALSE, i = 0; i < gNvNumberOfDataSets_c; ++i) 
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   0600               MOVS     R6,R0
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   0400               MOVS     R4,R0
   \                     ??NvIsValidPage_0:
   \   0000001A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000001C   240E               LSRS     R4,R4,#+24
   \   0000001E   022C               CMP      R4,#+2
   \   00000020   19D2               BCS      ??NvIsValidPage_1
    697              {
    698              if(NvDataSetTable[i].dataSetID && (NvDataSetTable[i].dataSetID == pageHeader.dataSetID)) 
   \   00000022   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000024   240E               LSRS     R4,R4,#+24
   \   00000026   0820               MOVS     R0,#+8
   \   00000028   6043               MULS     R0,R4,R0
   \   0000002A   ....               LDR      R1,??DataTable17
   \   0000002C   085C               LDRB     R0,[R1, R0]
   \   0000002E   0028               CMP      R0,#+0
   \   00000030   0FD0               BEQ      ??NvIsValidPage_2
   \   00000032   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000034   240E               LSRS     R4,R4,#+24
   \   00000036   0820               MOVS     R0,#+8
   \   00000038   6043               MULS     R0,R4,R0
   \   0000003A   ....               LDR      R1,??DataTable17
   \   0000003C   085C               LDRB     R0,[R1, R0]
   \   0000003E   6946               MOV      R1,SP
   \   00000040   4978               LDRB     R1,[R1, #+1]
   \   00000042   8842               CMP      R0,R1
   \   00000044   05D1               BNE      ??NvIsValidPage_2
    699                {
    700                legitDataSetID = TRUE;
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   0600               MOVS     R6,R0
    701                *pDataSetID = pageHeader.dataSetID;
   \   0000004A   6846               MOV      R0,SP
   \   0000004C   4078               LDRB     R0,[R0, #+1]
   \   0000004E   3870               STRB     R0,[R7, #+0]
    702                break;
   \   00000050   01E0               B        ??NvIsValidPage_1
    703                }
    704              }
   \                     ??NvIsValidPage_2:
   \   00000052   641C               ADDS     R4,R4,#+1
   \   00000054   E1E7               B        ??NvIsValidPage_0
    705          
    706            /* Do the header and trailer match? */
    707            /* Is the magic number legit? */
    708            if (legitDataSetID
    709                 && NvHalVerify( nvRawPageAddress , sizeof(NvRawPage_t)- sizeof(NvStructuredPageHeader_t),(unsigned char*)&pageHeader,sizeof(NvStructuredPageHeader_t))
    710            
    711           
    712                 && (pageHeader.magicNumber == mNvMagicNumber_c)) {
   \                     ??NvIsValidPage_1:
   \   00000056   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000058   360E               LSRS     R6,R6,#+24
   \   0000005A   002E               CMP      R6,#+0
   \   0000005C   0ED0               BEQ      ??NvIsValidPage_3
   \   0000005E   0223               MOVS     R3,#+2
   \   00000060   6A46               MOV      R2,SP
   \   00000062   FD21               MOVS     R1,#+253
   \   00000064   4900               LSLS     R1,R1,#+1        ;; #+506
   \   00000066   2800               MOVS     R0,R5
   \   00000068   ........           BL       NvHalVerify
   \   0000006C   0028               CMP      R0,#+0
   \   0000006E   05D0               BEQ      ??NvIsValidPage_3
   \   00000070   6846               MOV      R0,SP
   \   00000072   0078               LDRB     R0,[R0, #+0]
   \   00000074   2728               CMP      R0,#+39
   \   00000076   01D1               BNE      ??NvIsValidPage_3
    713              return TRUE;
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   00E0               B        ??NvIsValidPage_4
    714            }
    715          
    716            return FALSE;
   \                     ??NvIsValidPage_3:
   \   0000007C   0020               MOVS     R0,#+0
   \                     ??NvIsValidPage_4:
   \   0000007E   F2BC               POP      {R1,R4-R7}
   \   00000080   08BC               POP      {R3}
   \   00000082   1847               BX       R3               ;; return
    717          }                                       /* NvIsValidDataSet() */
    718          #endif                                  /* #if gNvStorageIncluded_d */
    719          /****************************************************************************/
    720          
    721          /* Examine an NV sector. Check the magic number, check that the header
    722           * and trailer match
    723           * Return TRUE if it looks legit; FALSE otherwise.
    724           */
    725          
    726          /********************************************************/
    727          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    728          static bool_t NvIsValidSector
    729            (
    730            NvRawSectorAddress_t nvRawSectorAddress
    731            )
    732          {
   \                     NvIsValidSector:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    733          
    734            NvStructuredSectorHeader_t sectorHeader;
    735            
    736            NvHalRead(nvRawSectorAddress,0,(unsigned char*)&sectorHeader,sizeof(NvStructuredSectorHeader_t));
   \   00000006   0223               MOVS     R3,#+2
   \   00000008   6A46               MOV      R2,SP
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       NvHalRead
    737            
    738            /* Do the header and trailer match? */
    739            /* Is the magic number legit? */
    740            if (NvHalVerify( nvRawSectorAddress , sizeof(NvRawSector_t)- sizeof(NvStructuredSectorHeader_t),(unsigned char*)&sectorHeader,sizeof(NvStructuredSectorHeader_t))
    741            
    742           
    743                 && (sectorHeader.magicNumber == mNvMagicNumber_c)) {
   \   00000012   0223               MOVS     R3,#+2
   \   00000014   6A46               MOV      R2,SP
   \   00000016   ....               LDR      R1,??DataTable19_1  ;; 0xffe
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   ........           BL       NvHalVerify
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   05D0               BEQ      ??NvIsValidSector_0
   \   00000022   6846               MOV      R0,SP
   \   00000024   0078               LDRB     R0,[R0, #+0]
   \   00000026   2728               CMP      R0,#+39
   \   00000028   01D1               BNE      ??NvIsValidSector_0
    744              return TRUE;
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   00E0               B        ??NvIsValidSector_1
    745            }
    746          
    747            return FALSE;
   \                     ??NvIsValidSector_0:
   \   0000002E   0020               MOVS     R0,#+0
   \                     ??NvIsValidSector_1:
   \   00000030   16BC               POP      {R1,R2,R4}
   \   00000032   08BC               POP      {R3}
   \   00000034   1847               BX       R3               ;; return
    748          }                                       /* NvIsValidDataSet() */
    749          #endif                                  /* #if gNvStorageIncluded_d */
    750          
    751          
    752          /********************************************************/
    753          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    754          static bool_t NvOpen_Validate_Sector(NvRawSectorAddress_t nvRawSectorAddress, NvSectorSequenceNumber_t sequenceNumber, bool_t open )
    755            {
   \                     NvOpen_Validate_Sector:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0700               MOVS     R7,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    756            NvStructuredSectorHeader_t sectorHeader;
    757            NvSize_t pageOffset;
    758            sectorHeader.magicNumber = mNvMagicNumber_c;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   2721               MOVS     R1,#+39
   \   0000000C   0170               STRB     R1,[R0, #+0]
    759            sectorHeader.sequenceNumber = sequenceNumber;
   \   0000000E   6846               MOV      R0,SP
   \   00000010   4670               STRB     R6,[R0, #+1]
    760            pageOffset = open ? 0 : ( sizeof(NvRawSector_t) - sizeof(NvStructuredSectorHeader_t) );
   \   00000012   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000014   2D0E               LSRS     R5,R5,#+24
   \   00000016   002D               CMP      R5,#+0
   \   00000018   01D0               BEQ      ??NvOpen_Validate_Sector_0
   \   0000001A   0024               MOVS     R4,#+0
   \   0000001C   00E0               B        ??NvOpen_Validate_Sector_1
   \                     ??NvOpen_Validate_Sector_0:
   \   0000001E   ....               LDR      R4,??DataTable19_1  ;; 0xffe
    761            if( NvHalWrite( nvRawSectorAddress , pageOffset , (uint8_t*)&sectorHeader , sizeof(NvStructuredSectorHeader_t)))
   \                     ??NvOpen_Validate_Sector_1:
   \   00000020   0223               MOVS     R3,#+2
   \   00000022   6A46               MOV      R2,SP
   \   00000024   2100               MOVS     R1,R4
   \   00000026   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000028   090C               LSRS     R1,R1,#+16
   \   0000002A   3800               MOVS     R0,R7
   \   0000002C   ........           BL       NvHalWrite
   \   00000030   0028               CMP      R0,#+0
   \   00000032   01D0               BEQ      ??NvOpen_Validate_Sector_2
    762             {
    763              return FALSE;  
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   00E0               B        ??NvOpen_Validate_Sector_3
    764             }
    765            return TRUE;
   \                     ??NvOpen_Validate_Sector_2:
   \   00000038   0120               MOVS     R0,#+1
   \                     ??NvOpen_Validate_Sector_3:
   \   0000003A   F2BC               POP      {R1,R4-R7}
   \   0000003C   08BC               POP      {R3}
   \   0000003E   1847               BX       R3               ;; return
    766            }                                       /* NvIsValidDataSet() */
    767          #endif                                  /* #if gNvStorageIncluded_d */
    768          
    769            /****************************************************************************/
    770          
    771          /* Examine an NV sector. Check the magic number, check that the header
    772           * and trailer match
    773           * Return TRUE if it looks legit; FALSE otherwise.
    774           */
    775          
    776          
    777          #if gNvStorageIncluded_d
    778          

   \                                 In section .text, align 2, keep-with-next
    779          static void NvGetFirstBlankPageInfo
    780            (
    781            NvRawSectorAddress_t nvRawSectorAddress, NvRawPageAddress_t* pBlankPage, index_t* pBlankPageIndex 
    782            )
    783          {
   \                     NvGetFirstBlankPageInfo:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0F00               MOVS     R7,R1
   \   00000004   1600               MOVS     R6,R2
    784            NvRawPageAddress_t pageAddress;
    785            index_t pageIndex;
    786            *pBlankPage = gMaxPageOffset_c + nvRawSectorAddress;
   \   00000006   0098               LDR      R0,[SP, #+0]
   \   00000008   ....               LDR      R1,??DataTable19_2  ;; 0xfe2
   \   0000000A   4018               ADDS     R0,R0,R1
   \   0000000C   3860               STR      R0,[R7, #+0]
    787            pageAddress  =   gLastPageOffset_c + nvRawSectorAddress;
   \   0000000E   0098               LDR      R0,[SP, #+0]
   \   00000010   ....               LDR      R1,??DataTable19_3  ;; 0xde6
   \   00000012   4018               ADDS     R0,R0,R1
   \   00000014   0400               MOVS     R4,R0
    788            *pBlankPageIndex = pageIndex  = gNvNumberOfRawPages_c;
   \   00000016   0820               MOVS     R0,#+8
   \   00000018   0500               MOVS     R5,R0
   \   0000001A   3070               STRB     R0,[R6, #+0]
    789            
    790            while(pageIndex --)
   \                     ??NvGetFirstBlankPageInfo_0:
   \   0000001C   2800               MOVS     R0,R5
   \   0000001E   451E               SUBS     R5,R0,#+1
   \   00000020   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000022   000E               LSRS     R0,R0,#+24
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0DD0               BEQ      ??NvGetFirstBlankPageInfo_1
    791            {
    792              if( NvHalIsBlank ( pageAddress, 0 , sizeof(NvRawPage_t)))
   \   00000028   FE22               MOVS     R2,#+254
   \   0000002A   5200               LSLS     R2,R2,#+1        ;; #+508
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       NvHalIsBlank
   \   00000034   0028               CMP      R0,#+0
   \   00000036   04D0               BEQ      ??NvGetFirstBlankPageInfo_2
    793                {
    794                *pBlankPage = pageAddress;
   \   00000038   3C60               STR      R4,[R7, #+0]
    795                *pBlankPageIndex = pageIndex;
   \   0000003A   3570               STRB     R5,[R6, #+0]
    796                }
    797              else
    798                {
    799                  return;
    800                }
    801              pageAddress -= sizeof(NvRawPage_t);
   \   0000003C   ....               LDR      R0,??DataTable19_4  ;; 0xfffffe04
   \   0000003E   2418               ADDS     R4,R4,R0
   \   00000040   ECE7               B        ??NvGetFirstBlankPageInfo_0
   \                     ??NvGetFirstBlankPageInfo_2:
   \   00000042   FFE7               B        ??NvGetFirstBlankPageInfo_3
    802            }  
    803          
    804          }                                      
   \                     ??NvGetFirstBlankPageInfo_1:
   \                     ??NvGetFirstBlankPageInfo_3:
   \   00000044   F1BC               POP      {R0,R4-R7}
   \   00000046   08BC               POP      {R3}
   \   00000048   1847               BX       R3               ;; return
    805          #endif                                  /* #if gNvStorageIncluded_d */
    806            /****************************************************************************/
    807          
    808          /* Examine an NV sector. Check the magic number, check that the header
    809           * and trailer match
    810           * Return TRUE if it looks legit; FALSE otherwise.
    811           */
    812          
    813          
    814          #if gNvStorageIncluded_d
    815                
    816          /*typedef struct NvSectInfo_tag {
    817            NvSectorSequenceNumber_t sequenceNumber;
    818            NvRawPageAddress_t pageAddress[gNvNumberOfDataSets_c];
    819          } NvSectInfo_t;
    820           typedef NvRawPageAddress_t NvSectPageInfo_t[ gNvNumberOfDataSets_c ];     
    821                */
    822          

   \                                 In section .text, align 2, keep-with-next
    823          static void NvGetSectorPageInfo
    824            (
    825            NvRawSectorAddress_t nvRawSectorAddress, NvSectPageInfo_t* pSectPageInfo
    826            )
    827          {
   \                     NvGetSectorPageInfo:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0F00               MOVS     R7,R1
    828            
    829            NvRawPageAddress_t pageAddress;
    830            index_t pageIndex;
    831            NvDataSetID_t dataSetID;
    832            for(pageIndex = 0; pageIndex < gNvNumberOfDataSets_c; pageIndex++)
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0500               MOVS     R5,R0
   \                     ??NvGetSectorPageInfo_0:
   \   0000000A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000000C   2D0E               LSRS     R5,R5,#+24
   \   0000000E   022D               CMP      R5,#+2
   \   00000010   08D2               BCS      ??NvGetSectorPageInfo_1
    833            {
    834              (*pSectPageInfo)[pageIndex] = (NvRawPageAddress_t)gUninitAddress;
   \   00000012   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000014   2D0E               LSRS     R5,R5,#+24
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   6843               MULS     R0,R5,R0
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   C943               MVNS     R1,R1            ;; #-1
   \   0000001E   3950               STR      R1,[R7, R0]
    835            }
   \   00000020   6D1C               ADDS     R5,R5,#+1
   \   00000022   F2E7               B        ??NvGetSectorPageInfo_0
    836            
    837           
    838            for(pageIndex = 0 ,pageAddress  = nvRawSectorAddress + sizeof(NvStructuredSectorHeader_t); pageIndex < gNvNumberOfRawPages_c ; pageIndex++ , pageAddress += sizeof(NvRawPage_t ))
   \                     ??NvGetSectorPageInfo_1:
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   0500               MOVS     R5,R0
   \   00000028   3000               MOVS     R0,R6
   \   0000002A   801C               ADDS     R0,R0,#+2
   \   0000002C   0400               MOVS     R4,R0
   \                     ??NvGetSectorPageInfo_2:
   \   0000002E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000030   2D0E               LSRS     R5,R5,#+24
   \   00000032   082D               CMP      R5,#+8
   \   00000034   11D2               BCS      ??NvGetSectorPageInfo_3
    839            {
    840              
    841                  if( NvIsValidPage( pageAddress , &dataSetID ))
   \   00000036   6946               MOV      R1,SP
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       NvIsValidPage
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   06D0               BEQ      ??NvGetSectorPageInfo_4
    842                    {
    843                      (*pSectPageInfo)[NvDataSetIndexFromID(dataSetID)] = pageAddress;
   \   00000042   6846               MOV      R0,SP
   \   00000044   0078               LDRB     R0,[R0, #+0]
   \   00000046   ........           BL       NvDataSetIndexFromID
   \   0000004A   0421               MOVS     R1,#+4
   \   0000004C   4843               MULS     R0,R1,R0
   \   0000004E   3C50               STR      R4,[R7, R0]
    844                    }
    845                    
    846            }
   \                     ??NvGetSectorPageInfo_4:
   \   00000050   6D1C               ADDS     R5,R5,#+1
   \   00000052   FE20               MOVS     R0,#+254
   \   00000054   4000               LSLS     R0,R0,#+1        ;; #+508
   \   00000056   2418               ADDS     R4,R4,R0
   \   00000058   E9E7               B        ??NvGetSectorPageInfo_2
    847          
    848          }                                      
   \                     ??NvGetSectorPageInfo_3:
   \   0000005A   F1BC               POP      {R0,R4-R7}
   \   0000005C   08BC               POP      {R3}
   \   0000005E   1847               BX       R3               ;; return
    849          #endif                                  /* #if gNvStorageIncluded_d */      
    850                      
    851            /****************************************************************************/
    852          
    853          /* Examine an NV sector. Check the magic number, check that the header
    854           * and trailer match
    855           * Return TRUE if it looks legit; FALSE otherwise.
    856           */
    857          
    858          
    859          #if gNvStorageIncluded_d
    860          

   \                                 In section .text, align 2, keep-with-next
    861          static NvSectorSequenceNumber_t NvGetSectorSequenceNumber
    862            (
    863            NvRawSectorAddress_t nvRawSectorAddress
    864            )
    865          {
   \                     NvGetSectorSequenceNumber:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    866            NvSectorSequenceNumber_t sectorSequenceNumber;
    867            NvHalRead( nvRawSectorAddress,  sizeof(NvMagicNumber_t) , (uint8_t *)&sectorSequenceNumber, sizeof(sectorSequenceNumber));
   \   00000006   0123               MOVS     R3,#+1
   \   00000008   6A46               MOV      R2,SP
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       NvHalRead
    868            return sectorSequenceNumber;
   \   00000012   6846               MOV      R0,SP
   \   00000014   0078               LDRB     R0,[R0, #+0]
   \   00000016   16BC               POP      {R1,R2,R4}
   \   00000018   08BC               POP      {R3}
   \   0000001A   1847               BX       R3               ;; return
    869          }                                      
    870          #endif                                  /* #if gNvStorageIncluded_d */                  
    871            /****************************************************************************/
    872          
    873          /* Examine an NV sector. Check the magic number, check that the header
    874           * and trailer match
    875           * Return TRUE if it looks legit; FALSE otherwise.
    876           */
    877          
    878          
    879          #if gNvStorageIncluded_d
    880          

   \                                 In section .text, align 2, keep-with-next
    881          static NvSectorSequenceNumber_t NvLastSectorSequence
    882          (
    883          NvSectorSequenceNumber_t sectorSeqA,NvSectorSequenceNumber_t sectorSeqB
    884          )
    885          {
   \                     NvLastSectorSequence:
   \   00000000   00B5               PUSH     {LR}
    886            NvSectorSequenceNumber_t seqDiff;
    887            seqDiff = sectorSeqA - sectorSeqB;
   \   00000002   431A               SUBS     R3,R0,R1
   \   00000004   1A00               MOVS     R2,R3
    888            return (seqDiff == 1) ? sectorSeqA : sectorSeqB ;
   \   00000006   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000008   120E               LSRS     R2,R2,#+24
   \   0000000A   012A               CMP      R2,#+1
   \   0000000C   00D0               BEQ      ??NvLastSectorSequence_0
   \                     ??NvLastSectorSequence_1:
   \   0000000E   0800               MOVS     R0,R1
   \                     ??NvLastSectorSequence_0:
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   08BC               POP      {R3}
   \   00000016   1847               BX       R3               ;; return
    889          }                                      
    890          #endif                                  /* #if gNvStorageIncluded_d */                  
    891                      
    892          /****************************************************************************/
    893          
    894          /* Save the contents of a data set, regardless of the state of the set's
    895           * dirty flag. Always writes a full page.
    896           *
    897           * Retry if the HAL reports an error. There isn't anything that the caller
    898           * can do about errors, so reporting one would be pointless.
    899           *
    900           * The flash controller reports errors that it detects, but power supply
    901           * fluctuations may still cause undetected errors. Its tempting to compute
    902           * some kind of checksum, and verify it after write, and also when a data
    903           * set is restored. This would complicate the code somewhat, and may not
    904           * be a common enough problem to be worth the extra code space.
    905           */
    906          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    907          static bool_t NvSaveDataSetLowLevel
    908            (
    909            index_t dataSetIndex , NvRawPageAddress_t pageAddress
    910            )
    911          {
   \                     NvSaveDataSetLowLevel:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0700               MOVS     R7,R0
   \   00000004   0E00               MOVS     R6,R1
    912            NvDataItemDescription_t const *pDataItemDescriptions;
    913            NvDataSetID_t dataSetID;
    914            static NvStructuredPageHeader_t pageHeader;
    915            NvSize_t pageOffset;
    916            
    917            dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
   \   00000006   6846               MOV      R0,SP
   \   00000008   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000000A   3F0E               LSRS     R7,R7,#+24
   \   0000000C   0821               MOVS     R1,#+8
   \   0000000E   7943               MULS     R1,R7,R1
   \   00000010   ....               LDR      R2,??NvCopyDataSet_0
   \   00000012   515C               LDRB     R1,[R2, R1]
   \   00000014   0170               STRB     R1,[R0, #+0]
    918          
    919            /* Set up the page header/trailer. */
    920            pageHeader.magicNumber = mNvMagicNumber_c;
   \   00000016   ....               LDR      R0,??DataTable20
   \   00000018   2721               MOVS     R1,#+39
   \   0000001A   0170               STRB     R1,[R0, #+0]
    921            pageHeader.dataSetID = dataSetID;
   \   0000001C   ....               LDR      R0,??DataTable20
   \   0000001E   6946               MOV      R1,SP
   \   00000020   0978               LDRB     R1,[R1, #+0]
   \   00000022   4170               STRB     R1,[R0, #+1]
    922            pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
   \   00000024   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000026   3F0E               LSRS     R7,R7,#+24
   \   00000028   0820               MOVS     R0,#+8
   \   0000002A   7843               MULS     R0,R7,R0
   \   0000002C   ....               LDR      R1,??NvCopyDataSet_0
   \   0000002E   0818               ADDS     R0,R1,R0
   \   00000030   4068               LDR      R0,[R0, #+4]
   \   00000032   0500               MOVS     R5,R0
    923            pageOffset = 0;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   0400               MOVS     R4,R0
    924          
    925              /* Write the page header to the beginning of the page. */
    926             if( FALSE == NvHalWrite( pageAddress,  pageOffset,  (uint8_t*) &pageHeader,  sizeof(pageHeader)) )
   \   00000038   0223               MOVS     R3,#+2
   \   0000003A   ....               LDR      R2,??DataTable20
   \   0000003C   2100               MOVS     R1,R4
   \   0000003E   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000040   090C               LSRS     R1,R1,#+16
   \   00000042   3000               MOVS     R0,R6
   \   00000044   ........           BL       NvHalWrite
   \   00000048   0028               CMP      R0,#+0
   \   0000004A   01D1               BNE      ??NvSaveDataSetLowLevel_0
    927               {
    928                 return FALSE;
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   23E0               B        ??NvSaveDataSetLowLevel_1
    929               }
    930             pageOffset += sizeof(pageHeader);
   \                     ??NvSaveDataSetLowLevel_0:
   \   00000050   A41C               ADDS     R4,R4,#+2
    931          
    932              /* Write the client data to the page. Note that the sizes of all of the */
    933              /* data sets in NvDataSetTable[] were validated in NvModuleInit(), so it */
    934              /* isn't necesary to check it here. */
    935              while ( pDataItemDescriptions->length) 
   \                     ??NvSaveDataSetLowLevel_2:
   \   00000052   A888               LDRH     R0,[R5, #+4]
   \   00000054   0028               CMP      R0,#+0
   \   00000056   0FD0               BEQ      ??NvSaveDataSetLowLevel_3
    936                {
    937                 if( FALSE == NvHalWrite( pageAddress, pageOffset, (uint8_t*)(pDataItemDescriptions->pointer), pDataItemDescriptions->length))
   \   00000058   AB88               LDRH     R3,[R5, #+4]
   \   0000005A   2A68               LDR      R2,[R5, #+0]
   \   0000005C   2100               MOVS     R1,R4
   \   0000005E   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000060   090C               LSRS     R1,R1,#+16
   \   00000062   3000               MOVS     R0,R6
   \   00000064   ........           BL       NvHalWrite
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   01D1               BNE      ??NvSaveDataSetLowLevel_4
    938                   {
    939                     return FALSE;
   \   0000006C   0020               MOVS     R0,#+0
   \   0000006E   13E0               B        ??NvSaveDataSetLowLevel_1
    940                   }
    941                 pageOffset += pDataItemDescriptions->length;
   \                     ??NvSaveDataSetLowLevel_4:
   \   00000070   A888               LDRH     R0,[R5, #+4]
   \   00000072   2418               ADDS     R4,R4,R0
    942                ++pDataItemDescriptions;
   \   00000074   0835               ADDS     R5,R5,#+8
   \   00000076   ECE7               B        ??NvSaveDataSetLowLevel_2
    943                }
    944          
    945              /* Write the terminal copy of the header. If this works, we're done. */
    946              pageOffset =   sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t);
   \                     ??NvSaveDataSetLowLevel_3:
   \   00000078   FD20               MOVS     R0,#+253
   \   0000007A   4000               LSLS     R0,R0,#+1        ;; #+506
   \   0000007C   0400               MOVS     R4,R0
    947              if( FALSE == NvHalWrite( pageAddress, pageOffset, (uint8_t *) &pageHeader, sizeof(pageHeader)) )
   \   0000007E   0223               MOVS     R3,#+2
   \   00000080   ....               LDR      R2,??DataTable20
   \   00000082   2100               MOVS     R1,R4
   \   00000084   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000086   090C               LSRS     R1,R1,#+16
   \   00000088   3000               MOVS     R0,R6
   \   0000008A   ........           BL       NvHalWrite
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   01D1               BNE      ??NvSaveDataSetLowLevel_5
    948                {
    949                 return FALSE;
   \   00000092   0020               MOVS     R0,#+0
   \   00000094   00E0               B        ??NvSaveDataSetLowLevel_1
    950                }
    951              return TRUE;
   \                     ??NvSaveDataSetLowLevel_5:
   \   00000096   0120               MOVS     R0,#+1
   \                     ??NvSaveDataSetLowLevel_1:
   \   00000098   F2BC               POP      {R1,R4-R7}
   \   0000009A   08BC               POP      {R3}
   \   0000009C   1847               BX       R3               ;; return
    952          }                                       /* NvSaveDataSetLowLevel() */

   \                                 In section .bss, align 4
   \                     ??pageHeader:
   \   00000000                      DS8 4
    953          
    954          
    955          #endif                                  /* #if !gNvStorageIncluded_d */
    956          
    957          /****************************************************************************/
    958          
    959          /* Save the contents of a data set, regardless of the state of the set's
    960           * dirty flag. Always writes a full page.
    961           *
    962           * Retry if the HAL reports an error. There isn't anything that the caller
    963           * can do about errors, so reporting one would be pointless.
    964           *
    965           * The flash controller reports errors that it detects, but power supply
    966           * fluctuations may still cause undetected errors. Its tempting to compute
    967           * some kind of checksum, and verify it after write, and also when a data
    968           * set is restored. This would complicate the code somewhat, and may not
    969           * be a common enough problem to be worth the extra code space.
    970           */
    971          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
    972          static void NvSaveDataSet
    973          (
    974          index_t dataSetIndex 
    975          )
    976          {
   \                     NvSaveDataSet:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
    977            index_t i;
    978            NvRawSectorAddress_t activeSectorAddress , oldSectorAddress ;
    979            NvRawPageAddress_t firstBlankPageAddress;
    980            bool_t sectorChange;
    981            bool_t sectorOpen;
    982            bool_t dataSaved;
    983            bool_t nvmError ;
    984            index_t sectorIndex;
    985            index_t firstBlankPageIndex;
    986            uint8_t retries;
    987            NvSectorSequenceNumber_t sectSeqNo;
    988            NvSectPageInfo_t validSectPageInfo, newSectPageInfo;
    989            
    990            PowerUpNVM();   
   \   00000004   ........           BL       PowerUpNVM
    991            retries = mNvFlashCmdRetries_c;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   2021               MOVS     R1,#+32
   \   0000000C   0172               STRB     R1,[R0, #+8]
    992            while(retries--)  
   \                     ??NvSaveDataSet_0:
   \   0000000E   6846               MOV      R0,SP
   \   00000010   007A               LDRB     R0,[R0, #+8]
   \   00000012   6946               MOV      R1,SP
   \   00000014   421E               SUBS     R2,R0,#+1
   \   00000016   0A72               STRB     R2,[R1, #+8]
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   00D1               BNE      .+4
   \   00000020   16E1               B        ??NvSaveDataSet_1
    993            {
    994              nvmError = FALSE;  
   \   00000022   6846               MOV      R0,SP
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   0170               STRB     R1,[R0, #+0]
    995              sectorChange = FALSE;
   \   00000028   6846               MOV      R0,SP
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   8170               STRB     R1,[R0, #+2]
    996              sectorOpen = FALSE;
   \   0000002E   6846               MOV      R0,SP
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   C170               STRB     R1,[R0, #+3]
    997              activeSectorAddress = gUninitAddress;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   C043               MVNS     R0,R0            ;; #-1
   \   00000038   0600               MOVS     R6,R0
    998              dataSaved = FALSE;
   \   0000003A   6846               MOV      R0,SP
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   4172               STRB     R1,[R0, #+9]
    999              // search for the valid sector
   1000              for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   0400               MOVS     R4,R0
   \                     ??NvSaveDataSet_2:
   \   00000044   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000046   240E               LSRS     R4,R4,#+24
   \   00000048   022C               CMP      R4,#+2
   \   0000004A   19D2               BCS      ??NvSaveDataSet_3
   1001              {
   1002                if(NvIsValidSector(maNvRawSectorAddressTable[sectorIndex]))
   \   0000004C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000004E   240E               LSRS     R4,R4,#+24
   \   00000050   0420               MOVS     R0,#+4
   \   00000052   6043               MULS     R0,R4,R0
   \   00000054   ....               LDR      R1,??DataTable21
   \   00000056   0858               LDR      R0,[R1, R0]
   \   00000058   ........           BL       NvIsValidSector
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   0DD0               BEQ      ??NvSaveDataSet_4
   1003                {
   1004                  activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
   \   00000060   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000062   240E               LSRS     R4,R4,#+24
   \   00000064   0420               MOVS     R0,#+4
   \   00000066   6043               MULS     R0,R4,R0
   \   00000068   ....               LDR      R1,??DataTable21
   \   0000006A   0858               LDR      R0,[R1, R0]
   \   0000006C   0600               MOVS     R6,R0
   1005                  NvGetFirstBlankPageInfo(activeSectorAddress, &firstBlankPageAddress, &firstBlankPageIndex);
   \   0000006E   00AA               ADD      R2,SP,#+0
   \   00000070   521C               ADDS     R2,R2,#+1
   \   00000072   01A9               ADD      R1,SP,#+4
   \   00000074   3000               MOVS     R0,R6
   \   00000076   ........           BL       NvGetFirstBlankPageInfo
   1006                  break;
   \   0000007A   01E0               B        ??NvSaveDataSet_3
   1007                }
   1008              }
   \                     ??NvSaveDataSet_4:
   \   0000007C   641C               ADDS     R4,R4,#+1
   \   0000007E   E1E7               B        ??NvSaveDataSet_2
   1009              while(dataSaved == FALSE)
   \                     ??NvSaveDataSet_3:
   \   00000080   6846               MOV      R0,SP
   \   00000082   407A               LDRB     R0,[R0, #+9]
   \   00000084   0028               CMP      R0,#+0
   \   00000086   00D0               BEQ      .+4
   \   00000088   98E0               B        ??NvSaveDataSet_5
   1010              {
   1011                if(activeSectorAddress == gUninitAddress)
   \   0000008A   0020               MOVS     R0,#+0
   \   0000008C   C043               MVNS     R0,R0            ;; #-1
   \   0000008E   8642               CMP      R6,R0
   \   00000090   21D1               BNE      ??NvSaveDataSet_6
   1012                {
   1013                  // There is no valid sector.Is the first time when a page is saved.  
   1014                  sectorIndex = 0;
   \   00000092   0020               MOVS     R0,#+0
   \   00000094   0400               MOVS     R4,R0
   1015                  sectSeqNo = 0;
   \   00000096   0020               MOVS     R0,#+0
   \   00000098   0700               MOVS     R7,R0
   1016                  activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
   \   0000009A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000009C   240E               LSRS     R4,R4,#+24
   \   0000009E   0420               MOVS     R0,#+4
   \   000000A0   6043               MULS     R0,R4,R0
   \   000000A2   ....               LDR      R1,??DataTable21
   \   000000A4   0858               LDR      R0,[R1, R0]
   \   000000A6   0600               MOVS     R6,R0
   1017                  firstBlankPageAddress = activeSectorAddress + sizeof(NvStructuredSectorHeader_t);
   \   000000A8   3000               MOVS     R0,R6
   \   000000AA   801C               ADDS     R0,R0,#+2
   \   000000AC   0190               STR      R0,[SP, #+4]
   1018                  firstBlankPageIndex = 0;
   \   000000AE   6846               MOV      R0,SP
   \   000000B0   0021               MOVS     R1,#+0
   \   000000B2   4170               STRB     R1,[R0, #+1]
   1019                  if (nvmError =  NvOpenSector(activeSectorAddress, sectSeqNo))
   \   000000B4   0122               MOVS     R2,#+1
   \   000000B6   3900               MOVS     R1,R7
   \   000000B8   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000000BA   090E               LSRS     R1,R1,#+24
   \   000000BC   3000               MOVS     R0,R6
   \   000000BE   ........           BL       NvOpen_Validate_Sector
   \   000000C2   6946               MOV      R1,SP
   \   000000C4   0870               STRB     R0,[R1, #+0]
   \   000000C6   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000C8   000E               LSRS     R0,R0,#+24
   \   000000CA   0028               CMP      R0,#+0
   \   000000CC   76D1               BNE      ??NvSaveDataSet_5
   1020                  {
   1021                    break;
   1022                  }
   1023                  sectorOpen = TRUE;
   \                     ??NvSaveDataSet_7:
   \   000000CE   6846               MOV      R0,SP
   \   000000D0   0121               MOVS     R1,#+1
   \   000000D2   C170               STRB     R1,[R0, #+3]
   \   000000D4   52E0               B        ??NvSaveDataSet_8
   1024                }
   1025                else   
   1026                {   
   1027                  if( gNvNumberOfRawPages_c == firstBlankPageIndex )
   \                     ??NvSaveDataSet_6:
   \   000000D6   6846               MOV      R0,SP
   \   000000D8   4078               LDRB     R0,[R0, #+1]
   \   000000DA   0828               CMP      R0,#+8
   \   000000DC   4ED1               BNE      ??NvSaveDataSet_8
   1028                  {
   1029                    // there is no room to save all data sets  
   1030                    if(sectorChange || sectorOpen)
   \   000000DE   6846               MOV      R0,SP
   \   000000E0   8078               LDRB     R0,[R0, #+2]
   \   000000E2   6946               MOV      R1,SP
   \   000000E4   C978               LDRB     R1,[R1, #+3]
   \   000000E6   0143               ORRS     R1,R1,R0
   \   000000E8   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000000EA   090E               LSRS     R1,R1,#+24
   \   000000EC   0029               CMP      R1,#+0
   \   000000EE   03D0               BEQ      ??NvSaveDataSet_9
   1031                    {
   1032                      nvmError = TRUE;
   \   000000F0   6846               MOV      R0,SP
   \   000000F2   0121               MOVS     R1,#+1
   \   000000F4   0170               STRB     R1,[R0, #+0]
   1033                      break;
   \   000000F6   61E0               B        ??NvSaveDataSet_5
   1034                      //after a sector change or after a sectorOpen data sets cannot be saved in the new sector.
   1035                      // must be a hardware issue. leave the loop and erase the sector again
   1036                    }
   1037                    else
   1038                    {
   1039                      
   1040                      sectSeqNo = NvGetSectorSequenceNumber(activeSectorAddress);
   \                     ??NvSaveDataSet_9:
   \   000000F8   3000               MOVS     R0,R6
   \   000000FA   ........           BL       NvGetSectorSequenceNumber
   \   000000FE   0700               MOVS     R7,R0
   1041                      oldSectorAddress = activeSectorAddress;
   \   00000100   0396               STR      R6,[SP, #+12]
   1042                      NvGetSectorPageInfo(activeSectorAddress , &validSectPageInfo);
   \   00000102   06A9               ADD      R1,SP,#+24
   \   00000104   3000               MOVS     R0,R6
   \   00000106   ........           BL       NvGetSectorPageInfo
   1043                      sectSeqNo  +=  1;
   \   0000010A   7F1C               ADDS     R7,R7,#+1
   1044                      for(i=0 ; i < gNvNumberOfDataSets_c; i++ )
   \   0000010C   0020               MOVS     R0,#+0
   \   0000010E   0500               MOVS     R5,R0
   \                     ??NvSaveDataSet_10:
   \   00000110   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000112   2D0E               LSRS     R5,R5,#+24
   \   00000114   022D               CMP      R5,#+2
   \   00000116   09D2               BCS      ??NvSaveDataSet_11
   1045                      {
   1046                        newSectPageInfo[i] = (NvRawPageAddress_t)gUninitAddress;
   \   00000118   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000011A   2D0E               LSRS     R5,R5,#+24
   \   0000011C   0420               MOVS     R0,#+4
   \   0000011E   6843               MULS     R0,R5,R0
   \   00000120   04A9               ADD      R1,SP,#+16
   \   00000122   0022               MOVS     R2,#+0
   \   00000124   D243               MVNS     R2,R2            ;; #-1
   \   00000126   0A50               STR      R2,[R1, R0]
   1047                      }
   \   00000128   6D1C               ADDS     R5,R5,#+1
   \   0000012A   F1E7               B        ??NvSaveDataSet_10
   1048                      sectorIndex = ((sectorIndex + 1) < gNvNumberOfRawSectors_c)?(sectorIndex + 1):0 ;
   \                     ??NvSaveDataSet_11:
   \   0000012C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000012E   240E               LSRS     R4,R4,#+24
   \   00000130   2000               MOVS     R0,R4
   \   00000132   401C               ADDS     R0,R0,#+1
   \   00000134   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000136   000C               LSRS     R0,R0,#+16
   \   00000138   0228               CMP      R0,#+2
   \   0000013A   01D2               BCS      ??NvSaveDataSet_12
   \   0000013C   641C               ADDS     R4,R4,#+1
   \   0000013E   00E0               B        ??NvSaveDataSet_13
   \                     ??NvSaveDataSet_12:
   \   00000140   0024               MOVS     R4,#+0
   1049                      activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
   \                     ??NvSaveDataSet_13:
   \   00000142   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000144   240E               LSRS     R4,R4,#+24
   \   00000146   0420               MOVS     R0,#+4
   \   00000148   6043               MULS     R0,R4,R0
   \   0000014A   ....               LDR      R1,??DataTable21
   \   0000014C   0858               LDR      R0,[R1, R0]
   \   0000014E   0600               MOVS     R6,R0
   1050                      firstBlankPageAddress = activeSectorAddress + sizeof(NvStructuredSectorHeader_t);
   \   00000150   3000               MOVS     R0,R6
   \   00000152   801C               ADDS     R0,R0,#+2
   \   00000154   0190               STR      R0,[SP, #+4]
   1051                      firstBlankPageIndex = 0;
   \   00000156   6846               MOV      R0,SP
   \   00000158   0021               MOVS     R1,#+0
   \   0000015A   4170               STRB     R1,[R0, #+1]
   1052                      
   1053                      if (nvmError =  NvOpenSector(activeSectorAddress , sectSeqNo) )
   \   0000015C   0122               MOVS     R2,#+1
   \   0000015E   3900               MOVS     R1,R7
   \   00000160   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000162   090E               LSRS     R1,R1,#+24
   \   00000164   3000               MOVS     R0,R6
   \   00000166   ........           BL       NvOpen_Validate_Sector
   \   0000016A   6946               MOV      R1,SP
   \   0000016C   0870               STRB     R0,[R1, #+0]
   \   0000016E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000170   000E               LSRS     R0,R0,#+24
   \   00000172   0028               CMP      R0,#+0
   \   00000174   22D1               BNE      ??NvSaveDataSet_5
   1054                      {
   1055                        break;
   1056                      }
   1057                      sectorChange = TRUE;
   \                     ??NvSaveDataSet_14:
   \   00000176   6846               MOV      R0,SP
   \   00000178   0121               MOVS     R1,#+1
   \   0000017A   8170               STRB     R1,[R0, #+2]
   1058                      
   1059                      // if a sector change all data sets to be saved must be saved in the new sector 
   1060                      //and after that the remains data sets must be copied from the old sector
   1061                    }
   1062                  }
   1063                }//else from (activeSectorAddress == 0)
   1064                if(NvSaveDataSetLowLevel(dataSetIndex,firstBlankPageAddress ))
   \                     ??NvSaveDataSet_8:
   \   0000017C   0199               LDR      R1,[SP, #+4]
   \   0000017E   08A8               ADD      R0,SP,#+32
   \   00000180   0078               LDRB     R0,[R0, #+0]
   \   00000182   ........           BL       NvSaveDataSetLowLevel
   \   00000186   0028               CMP      R0,#+0
   \   00000188   0DD0               BEQ      ??NvSaveDataSet_15
   1065                {
   1066                  dataSaved = TRUE; 
   \   0000018A   6846               MOV      R0,SP
   \   0000018C   0121               MOVS     R1,#+1
   \   0000018E   4172               STRB     R1,[R0, #+9]
   1067                  if(sectorChange)
   \   00000190   6846               MOV      R0,SP
   \   00000192   8078               LDRB     R0,[R0, #+2]
   \   00000194   0028               CMP      R0,#+0
   \   00000196   06D0               BEQ      ??NvSaveDataSet_15
   1068                  {
   1069                    newSectPageInfo[dataSetIndex] = firstBlankPageAddress;
   \   00000198   08A8               ADD      R0,SP,#+32
   \   0000019A   0078               LDRB     R0,[R0, #+0]
   \   0000019C   0421               MOVS     R1,#+4
   \   0000019E   4843               MULS     R0,R1,R0
   \   000001A0   04A9               ADD      R1,SP,#+16
   \   000001A2   019A               LDR      R2,[SP, #+4]
   \   000001A4   0A50               STR      R2,[R1, R0]
   1070                  }
   1071                }  
   1072                firstBlankPageAddress +=  sizeof(NvRawPage_t);
   \                     ??NvSaveDataSet_15:
   \   000001A6   0198               LDR      R0,[SP, #+4]
   \   000001A8   FE21               MOVS     R1,#+254
   \   000001AA   4900               LSLS     R1,R1,#+1        ;; #+508
   \   000001AC   4018               ADDS     R0,R0,R1
   \   000001AE   0190               STR      R0,[SP, #+4]
   1073                firstBlankPageIndex ++;
   \   000001B0   6846               MOV      R0,SP
   \   000001B2   4078               LDRB     R0,[R0, #+1]
   \   000001B4   401C               ADDS     R0,R0,#+1
   \   000001B6   6946               MOV      R1,SP
   \   000001B8   4870               STRB     R0,[R1, #+1]
   \   000001BA   61E7               B        ??NvSaveDataSet_3
   1074                
   1075              }//  while(dataSaved == FALSE))
   1076              if((sectorChange || sectorOpen) && (nvmError == FALSE))
   \                     ??NvSaveDataSet_5:
   \   000001BC   6846               MOV      R0,SP
   \   000001BE   8078               LDRB     R0,[R0, #+2]
   \   000001C0   6946               MOV      R1,SP
   \   000001C2   C978               LDRB     R1,[R1, #+3]
   \   000001C4   0143               ORRS     R1,R1,R0
   \   000001C6   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001C8   090E               LSRS     R1,R1,#+24
   \   000001CA   0029               CMP      R1,#+0
   \   000001CC   0CD0               BEQ      ??NvSaveDataSet_16
   \   000001CE   6846               MOV      R0,SP
   \   000001D0   0078               LDRB     R0,[R0, #+0]
   \   000001D2   0028               CMP      R0,#+0
   \   000001D4   08D1               BNE      ??NvSaveDataSet_16
   1077                {
   1078                //the sector must be marked as a valid one(write the magic number and the sequence number at the end of the sector)
   1079                nvmError = NvValidateSector(activeSectorAddress, sectSeqNo);
   \   000001D6   0022               MOVS     R2,#+0
   \   000001D8   3900               MOVS     R1,R7
   \   000001DA   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001DC   090E               LSRS     R1,R1,#+24
   \   000001DE   3000               MOVS     R0,R6
   \   000001E0   ........           BL       NvOpen_Validate_Sector
   \   000001E4   6946               MOV      R1,SP
   \   000001E6   0870               STRB     R0,[R1, #+0]
   1080                }
   1081              
   1082              if(sectorChange &&(nvmError == FALSE))
   \                     ??NvSaveDataSet_16:
   \   000001E8   6846               MOV      R0,SP
   \   000001EA   8078               LDRB     R0,[R0, #+2]
   \   000001EC   0028               CMP      R0,#+0
   \   000001EE   0CD0               BEQ      ??NvSaveDataSet_17
   \   000001F0   6846               MOV      R0,SP
   \   000001F2   0078               LDRB     R0,[R0, #+0]
   \   000001F4   0028               CMP      R0,#+0
   \   000001F6   08D1               BNE      ??NvSaveDataSet_17
   1083              {
   1084                // the remains data sets must be copied from the old sector
   1085                nvmError =NvCopyTheRemainsDataSets(&validSectPageInfo, &newSectPageInfo,firstBlankPageAddress,firstBlankPageIndex);
   \   000001F8   6846               MOV      R0,SP
   \   000001FA   4378               LDRB     R3,[R0, #+1]
   \   000001FC   019A               LDR      R2,[SP, #+4]
   \   000001FE   04A9               ADD      R1,SP,#+16
   \   00000200   06A8               ADD      R0,SP,#+24
   \   00000202   ........           BL       NvCopyTheRemainsDataSets
   \   00000206   6946               MOV      R1,SP
   \   00000208   0870               STRB     R0,[R1, #+0]
   1086              }
   1087          
   1088              if((sectorChange ) && (nvmError == FALSE))
   \                     ??NvSaveDataSet_17:
   \   0000020A   6846               MOV      R0,SP
   \   0000020C   8078               LDRB     R0,[R0, #+2]
   \   0000020E   0028               CMP      R0,#+0
   \   00000210   06D0               BEQ      ??NvSaveDataSet_18
   \   00000212   6846               MOV      R0,SP
   \   00000214   0078               LDRB     R0,[R0, #+0]
   \   00000216   0028               CMP      R0,#+0
   \   00000218   02D1               BNE      ??NvSaveDataSet_18
   1089              {
   1090                NvHalEraseSector(oldSectorAddress);  
   \   0000021A   0398               LDR      R0,[SP, #+12]
   \   0000021C   ........           BL       NvHalEraseSector
   1091              } 
   1092              if(nvmError)
   \                     ??NvSaveDataSet_18:
   \   00000220   6846               MOV      R0,SP
   \   00000222   0078               LDRB     R0,[R0, #+0]
   \   00000224   0028               CMP      R0,#+0
   \   00000226   03D0               BEQ      ??NvSaveDataSet_19
   1093              {
   1094                NvHalEraseSector(activeSectorAddress);
   \   00000228   3000               MOVS     R0,R6
   \   0000022A   ........           BL       NvHalEraseSector
   1095                
   1096                continue;  
   \   0000022E   EEE6               B        ??NvSaveDataSet_0
   1097              }
   1098              
   1099              maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
   \                     ??NvSaveDataSet_19:
   \   00000230   08A8               ADD      R0,SP,#+32
   \   00000232   0078               LDRB     R0,[R0, #+0]
   \   00000234   0621               MOVS     R1,#+6
   \   00000236   4843               MULS     R0,R1,R0
   \   00000238   ....               LDR      R1,??DataTable21_1
   \   0000023A   0022               MOVS     R2,#+0
   \   0000023C   0A54               STRB     R2,[R1, R0]
   1100              maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
   \   0000023E   08A8               ADD      R0,SP,#+32
   \   00000240   0078               LDRB     R0,[R0, #+0]
   \   00000242   0621               MOVS     R1,#+6
   \   00000244   4843               MULS     R0,R1,R0
   \   00000246   ....               LDR      R1,??DataTable21_1
   \   00000248   0818               ADDS     R0,R1,R0
   \   0000024A   8021               MOVS     R1,#+128
   \   0000024C   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000024E   8180               STRH     R1,[R0, #+4]
   1101              
   1102              
   1103              break;
   1104            } 
   1105            PowerDownNVM();
   \                     ??NvSaveDataSet_1:
   \   00000250   ........           BL       PowerDownNVM
   1106          }                                       /* NvSaveDataSet() */
   \   00000254   09B0               ADD      SP,SP,#+36
   \   00000256   F0BC               POP      {R4-R7}
   \   00000258   08BC               POP      {R3}
   \   0000025A   1847               BX       R3               ;; return
   1107          
   1108          
   1109          #endif                                  /* #if !gNvStorageIncluded_d */            
   1110          /****************************************************************************/
   1111                      
   1112          #if gNvStorageIncluded_d

   \                                 In section .text, align 4, keep-with-next
   1113          static bool_t NvCopyDataSet
   1114            (
   1115            NvRawPageAddress_t sourcePage , NvRawPageAddress_t destPage
   1116            )
   1117          {
   \                     NvCopyDataSet:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   91B0               SUB      SP,SP,#+68
   1118            NvDataItemDescription_t const *pDataItemDescriptions;
   1119            static NvStructuredPageHeader_t pageHeader;
   1120            index_t dataSetIndex;
   1121            uint8_t buffer[g_CopyBufferSize_c];
   1122            NvSize_t length;
   1123            NvSize_t numBytes;
   1124            NvSize_t pageOffset;
   1125            
   1126            NvHalRead(sourcePage, 0, (uint8_t*)&pageHeader, sizeof(pageHeader));  
   \   00000004   0223               MOVS     R3,#+2
   \   00000006   ....               LDR      R2,??DataTable21_2
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   1198               LDR      R0,[SP, #+68]
   \   0000000C   ........           BL       NvHalRead
   1127            dataSetIndex = NvDataSetIndexFromID(pageHeader.dataSetID); 
   \   00000010   ....               LDR      R0,??DataTable21_2
   \   00000012   4078               LDRB     R0,[R0, #+1]
   \   00000014   ........           BL       NvDataSetIndexFromID
   \   00000018   6946               MOV      R1,SP
   \   0000001A   0870               STRB     R0,[R1, #+0]
   1128            /* Set up the page header/trailer. */
   1129            pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
   \   0000001C   6846               MOV      R0,SP
   \   0000001E   0078               LDRB     R0,[R0, #+0]
   \   00000020   0821               MOVS     R1,#+8
   \   00000022   4843               MULS     R0,R1,R0
   \   00000024   0649               LDR      R1,??NvCopyDataSet_0
   \   00000026   0818               ADDS     R0,R1,R0
   \   00000028   4068               LDR      R0,[R0, #+4]
   \   0000002A   0600               MOVS     R6,R0
   1130            length = 0;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0400               MOVS     R4,R0
   1131             while (pDataItemDescriptions->length)
   \                     ??NvCopyDataSet_1:
   \   00000030   B088               LDRH     R0,[R6, #+4]
   \   00000032   0028               CMP      R0,#+0
   \   00000034   06D0               BEQ      ??NvCopyDataSet_2
   1132             {
   1133              length += pDataItemDescriptions->length;
   \   00000036   B088               LDRH     R0,[R6, #+4]
   \   00000038   2418               ADDS     R4,R4,R0
   1134              ++pDataItemDescriptions;
   \   0000003A   0836               ADDS     R6,R6,#+8
   \   0000003C   F8E7               B        ??NvCopyDataSet_1
   \   0000003E   C046               Nop      
   \                     ??NvCopyDataSet_0:
   \   00000040   ........           DC32     NvDataSetTable
   1135             }
   1136           
   1137            pageOffset = 0;
   \                     ??NvCopyDataSet_2:
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   0500               MOVS     R5,R0
   1138            if( FALSE == NvHalWrite( destPage,  pageOffset,  (uint8_t*) &pageHeader,  sizeof(pageHeader)) )
   \   00000048   0223               MOVS     R3,#+2
   \   0000004A   ....               LDR      R2,??DataTable21_2
   \   0000004C   2900               MOVS     R1,R5
   \   0000004E   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000050   090C               LSRS     R1,R1,#+16
   \   00000052   1298               LDR      R0,[SP, #+72]
   \   00000054   ........           BL       NvHalWrite
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   01D1               BNE      ??NvCopyDataSet_3
   1139               {
   1140                 return FALSE;
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   37E0               B        ??NvCopyDataSet_4
   1141               }
   1142              
   1143            pageOffset = sizeof(NvStructuredPageHeader_t);
   \                     ??NvCopyDataSet_3:
   \   00000060   0220               MOVS     R0,#+2
   \   00000062   0500               MOVS     R5,R0
   1144            
   1145            while(length)
   \                     ??NvCopyDataSet_5:
   \   00000064   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000066   240C               LSRS     R4,R4,#+16
   \   00000068   002C               CMP      R4,#+0
   \   0000006A   21D0               BEQ      ??NvCopyDataSet_6
   1146            {
   1147              numBytes = (length  <  sizeof(buffer)) ? length : sizeof(buffer);
   \   0000006C   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   0000006E   240C               LSRS     R4,R4,#+16
   \   00000070   402C               CMP      R4,#+64
   \   00000072   01D2               BCS      ??NvCopyDataSet_7
   \   00000074   2700               MOVS     R7,R4
   \   00000076   00E0               B        ??NvCopyDataSet_8
   \                     ??NvCopyDataSet_7:
   \   00000078   4027               MOVS     R7,#+64
   1148              NvHalRead(sourcePage, pageOffset , buffer, numBytes);  
   \                     ??NvCopyDataSet_8:
   \   0000007A   3B00               MOVS     R3,R7
   \   0000007C   1B04               LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
   \   0000007E   1B0C               LSRS     R3,R3,#+16
   \   00000080   01AA               ADD      R2,SP,#+4
   \   00000082   2900               MOVS     R1,R5
   \   00000084   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   00000086   090C               LSRS     R1,R1,#+16
   \   00000088   1198               LDR      R0,[SP, #+68]
   \   0000008A   ........           BL       NvHalRead
   1149              if( FALSE == NvHalWrite( destPage,  pageOffset,  buffer, numBytes) )
   \   0000008E   3B00               MOVS     R3,R7
   \   00000090   1B04               LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
   \   00000092   1B0C               LSRS     R3,R3,#+16
   \   00000094   01AA               ADD      R2,SP,#+4
   \   00000096   2900               MOVS     R1,R5
   \   00000098   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   0000009A   090C               LSRS     R1,R1,#+16
   \   0000009C   1298               LDR      R0,[SP, #+72]
   \   0000009E   ........           BL       NvHalWrite
   \   000000A2   0028               CMP      R0,#+0
   \   000000A4   01D1               BNE      ??NvCopyDataSet_9
   1150               {
   1151                 return FALSE;
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   12E0               B        ??NvCopyDataSet_4
   1152               }
   1153              length -= numBytes;
   \                     ??NvCopyDataSet_9:
   \   000000AA   E41B               SUBS     R4,R4,R7
   1154              pageOffset += numBytes;
   \   000000AC   ED19               ADDS     R5,R5,R7
   \   000000AE   D9E7               B        ??NvCopyDataSet_5
   1155            }
   1156             /* Write the terminal copy of the header. If this works, we're done. */
   1157             pageOffset =   sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t);
   \                     ??NvCopyDataSet_6:
   \   000000B0   FD20               MOVS     R0,#+253
   \   000000B2   4000               LSLS     R0,R0,#+1        ;; #+506
   \   000000B4   0500               MOVS     R5,R0
   1158              if( FALSE == NvHalWrite( destPage, pageOffset, (uint8_t *) &pageHeader, sizeof(pageHeader)) )
   \   000000B6   0223               MOVS     R3,#+2
   \   000000B8   ....               LDR      R2,??DataTable21_2
   \   000000BA   2900               MOVS     R1,R5
   \   000000BC   0904               LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
   \   000000BE   090C               LSRS     R1,R1,#+16
   \   000000C0   1298               LDR      R0,[SP, #+72]
   \   000000C2   ........           BL       NvHalWrite
   \   000000C6   0028               CMP      R0,#+0
   \   000000C8   01D1               BNE      ??NvCopyDataSet_10
   1159                {
   1160                 return FALSE;
   \   000000CA   0020               MOVS     R0,#+0
   \   000000CC   00E0               B        ??NvCopyDataSet_4
   1161                }
   1162              return TRUE;
   \                     ??NvCopyDataSet_10:
   \   000000CE   0120               MOVS     R0,#+1
   \                     ??NvCopyDataSet_4:
   \   000000D0   13B0               ADD      SP,SP,#+76
   \   000000D2   F0BC               POP      {R4-R7}
   \   000000D4   08BC               POP      {R3}
   \   000000D6   1847               BX       R3               ;; return
   1163          }                                       /* NvCopyDataSet() */

   \                                 In section .bss, align 4
   \                     ??pageHeader_1:
   \   00000000                      DS8 4
   1164          
   1165          
   1166          #endif                                  /* #if !gNvStorageIncluded_d */
   1167                      
   1168          /****************************************************************************/
   1169                      
   1170          #if gNvStorageIncluded_d

   \                                 In section .text, align 2, keep-with-next
   1171          static bool_t  NvCopyTheRemainsDataSets
   1172            (
   1173             NvSectPageInfo_t* oldSectPageInfo, NvSectPageInfo_t *newSectPageInfo, NvRawPageAddress_t firstBlankPageAddress,index_t firstBlankPageIndex
   1174            )
   1175          {
   \                     NvCopyTheRemainsDataSets:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1600               MOVS     R6,R2
   \   00000006   1F00               MOVS     R7,R3
   1176            index_t dataSetsToCopy;
   1177            index_t dataSetIndex;
   1178            for(dataSetIndex = 0 , dataSetsToCopy = 0 ; dataSetIndex < gNvNumberOfDataSets_c ; dataSetIndex++ )
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0500               MOVS     R5,R0
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0400               MOVS     R4,R0
   \                     ??NvCopyTheRemainsDataSets_0:
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   022D               CMP      R5,#+2
   \   00000016   16D2               BCS      ??NvCopyTheRemainsDataSets_1
   1179              {
   1180                if( ( (*oldSectPageInfo)[dataSetIndex] != gUninitAddress ) && ((*newSectPageInfo)[dataSetIndex] == gUninitAddress))
   \   00000018   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001A   2D0E               LSRS     R5,R5,#+24
   \   0000001C   0420               MOVS     R0,#+4
   \   0000001E   6843               MULS     R0,R5,R0
   \   00000020   0199               LDR      R1,[SP, #+4]
   \   00000022   0858               LDR      R0,[R1, R0]
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   C943               MVNS     R1,R1            ;; #-1
   \   00000028   8842               CMP      R0,R1
   \   0000002A   0AD0               BEQ      ??NvCopyTheRemainsDataSets_2
   \   0000002C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000002E   2D0E               LSRS     R5,R5,#+24
   \   00000030   0420               MOVS     R0,#+4
   \   00000032   6843               MULS     R0,R5,R0
   \   00000034   0299               LDR      R1,[SP, #+8]
   \   00000036   0858               LDR      R0,[R1, R0]
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   C943               MVNS     R1,R1            ;; #-1
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   00D1               BNE      ??NvCopyTheRemainsDataSets_2
   1181                {
   1182                  dataSetsToCopy++;
   \   00000040   641C               ADDS     R4,R4,#+1
   1183                }
   1184              }
   \                     ??NvCopyTheRemainsDataSets_2:
   \   00000042   6D1C               ADDS     R5,R5,#+1
   \   00000044   E4E7               B        ??NvCopyTheRemainsDataSets_0
   1185            if(!dataSetsToCopy)
   \                     ??NvCopyTheRemainsDataSets_1:
   \   00000046   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000048   240E               LSRS     R4,R4,#+24
   \   0000004A   002C               CMP      R4,#+0
   \   0000004C   01D1               BNE      ??NvCopyTheRemainsDataSets_3
   1186              return FALSE;
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   38E0               B        ??NvCopyTheRemainsDataSets_4
   1187            dataSetIndex = 0;
   \                     ??NvCopyTheRemainsDataSets_3:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   0500               MOVS     R5,R0
   1188            while(dataSetsToCopy)
   \                     ??NvCopyTheRemainsDataSets_5:
   \   00000056   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000058   240E               LSRS     R4,R4,#+24
   \   0000005A   002C               CMP      R4,#+0
   \   0000005C   31D0               BEQ      ??NvCopyTheRemainsDataSets_6
   1189            {
   1190               if((gNvNumberOfRawPages_c - firstBlankPageIndex) < dataSetsToCopy )
   \   0000005E   0820               MOVS     R0,#+8
   \   00000060   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000062   3F0E               LSRS     R7,R7,#+24
   \   00000064   C01B               SUBS     R0,R0,R7
   \   00000066   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000068   240E               LSRS     R4,R4,#+24
   \   0000006A   A042               CMP      R0,R4
   \   0000006C   01DA               BGE      ??NvCopyTheRemainsDataSets_7
   1191                 return TRUE;
   \   0000006E   0120               MOVS     R0,#+1
   \   00000070   28E0               B        ??NvCopyTheRemainsDataSets_4
   1192               if( ( (*oldSectPageInfo)[dataSetIndex] != gUninitAddress ) && ((*newSectPageInfo)[dataSetIndex] == gUninitAddress))
   \                     ??NvCopyTheRemainsDataSets_7:
   \   00000072   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000074   2D0E               LSRS     R5,R5,#+24
   \   00000076   0420               MOVS     R0,#+4
   \   00000078   6843               MULS     R0,R5,R0
   \   0000007A   0199               LDR      R1,[SP, #+4]
   \   0000007C   0858               LDR      R0,[R1, R0]
   \   0000007E   0021               MOVS     R1,#+0
   \   00000080   C943               MVNS     R1,R1            ;; #-1
   \   00000082   8842               CMP      R0,R1
   \   00000084   1BD0               BEQ      ??NvCopyTheRemainsDataSets_8
   \   00000086   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000088   2D0E               LSRS     R5,R5,#+24
   \   0000008A   0420               MOVS     R0,#+4
   \   0000008C   6843               MULS     R0,R5,R0
   \   0000008E   0299               LDR      R1,[SP, #+8]
   \   00000090   0858               LDR      R0,[R1, R0]
   \   00000092   0021               MOVS     R1,#+0
   \   00000094   C943               MVNS     R1,R1            ;; #-1
   \   00000096   8842               CMP      R0,R1
   \   00000098   11D1               BNE      ??NvCopyTheRemainsDataSets_8
   1193                {
   1194                  if( NvCopyDataSet( (*oldSectPageInfo)[dataSetIndex] , firstBlankPageAddress))
   \   0000009A   3100               MOVS     R1,R6
   \   0000009C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000009E   2D0E               LSRS     R5,R5,#+24
   \   000000A0   0420               MOVS     R0,#+4
   \   000000A2   6843               MULS     R0,R5,R0
   \   000000A4   019A               LDR      R2,[SP, #+4]
   \   000000A6   1058               LDR      R0,[R2, R0]
   \   000000A8   ........           BL       NvCopyDataSet
   \   000000AC   0028               CMP      R0,#+0
   \   000000AE   01D0               BEQ      ??NvCopyTheRemainsDataSets_9
   1195                  {
   1196                    dataSetsToCopy--;
   \   000000B0   641E               SUBS     R4,R4,#+1
   1197                    dataSetIndex++;
   \   000000B2   6D1C               ADDS     R5,R5,#+1
   1198                  }
   1199                  firstBlankPageAddress +=  sizeof(NvRawPage_t);
   \                     ??NvCopyTheRemainsDataSets_9:
   \   000000B4   FE20               MOVS     R0,#+254
   \   000000B6   4000               LSLS     R0,R0,#+1        ;; #+508
   \   000000B8   3618               ADDS     R6,R6,R0
   1200                  firstBlankPageIndex ++;
   \   000000BA   7F1C               ADDS     R7,R7,#+1
   \   000000BC   CBE7               B        ??NvCopyTheRemainsDataSets_5
   1201                }
   1202               else
   1203                 {
   1204                  dataSetIndex++;
   \                     ??NvCopyTheRemainsDataSets_8:
   \   000000BE   6D1C               ADDS     R5,R5,#+1
   \   000000C0   C9E7               B        ??NvCopyTheRemainsDataSets_5
   1205                 }
   1206            }
   1207             
   1208            return FALSE;
   \                     ??NvCopyTheRemainsDataSets_6:
   \   000000C2   0020               MOVS     R0,#+0
   \                     ??NvCopyTheRemainsDataSets_4:
   \   000000C4   FEBC               POP      {R1-R7}
   \   000000C6   08BC               POP      {R3}
   \   000000C8   1847               BX       R3               ;; return
   1209          
   1210          }                                       /* NvCopyDataSet() */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     mNvCriticalSectionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     maNvDirtyFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     gNvCountsBetweenSaves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   ........           DC32     maNvDirtyFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     maNvRawSectorAddressTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     NvDataSetTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   ........           DC32     maNvDirtyFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   ........           DC32     gIdleTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   ........           DC32     gNvMinimumTicksBetweenSaves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   ........           DC32     gNvCountsBetweenSaves

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   ........           DC32     mNvCriticalSectionFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   18300080           DC32     0x80003018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   FE0F0000           DC32     0xffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   E20F0000           DC32     0xfe2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   E60D0000           DC32     0xde6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   04FEFFFF           DC32     0xfffffe04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     ??pageHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     maNvRawSectorAddressTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   ........           DC32     maNvDirtyFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   ........           DC32     ??pageHeader_1
   1211          
   1212          
   1213          #endif                                  /* #if !gNvStorageIncluded_d */            
   1214          
   1215              

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     NvClearCriticalSection             4
     NvCopyDataSet                     96
     NvCopyTheRemainsDataSets          32
     NvDataSetIndexFromID               4
     NvGetFirstBlankPageInfo           24
     NvGetSectorPageInfo               24
     NvGetSectorSequenceNumber         16
     NvIdle                             8
     NvIsDataSetDirty                  16
     NvIsValidPage                     24
     NvIsValidSector                   16
     NvLastSectorSequence               4
     NvModuleInit                      48
     NvOpen_Validate_Sector            24
     NvPrimitiveSearch                 48
     NvRestoreDataSet                  40
     NvSaveDataSet                     56
     NvSaveDataSetLowLevel             24
     NvSaveOnCount                     16
     NvSaveOnIdle                       8
     NvSaveOnInterval                  16
     NvSetCountsBetweenSaves            0
     NvSetCriticalSection               0
     NvSetMinimumTicksBetweenSaves      0
     NvTimerTick                       24
     PowerDownNVM                      16
     PowerUpNVM                        16


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     maNvDirtyFlags                  12
     gNvMinimumTicksBetweenSaves      2
     gNvCountsBetweenSaves            2
     mNvCriticalSectionFlag           1
     NvClearCriticalSection          24
     NvSetCriticalSection            12
     NvIdle                          60
     NvIsDataSetDirty                70
     NvModuleInit                   330
     NvPrimitiveSearch              250
     NvRestoreDataSet               220
     NvSaveOnIdle                    32
     NvSaveOnInterval                78
     NvSaveOnCount                   70
     NvSetMinimumTicksBetweenSaves    6
     NvSetCountsBetweenSaves          6
     NvTimerTick                    102
     PowerUpNVM                      44
     PowerDownNVM                    26
     NvDataSetIndexFromID            70
     NvIsValidPage                  132
     NvIsValidSector                 54
     NvOpen_Validate_Sector          64
     NvGetFirstBlankPageInfo         74
     NvGetSectorPageInfo             96
     NvGetSectorSequenceNumber       28
     NvLastSectorSequence            24
     NvSaveDataSetLowLevel          158
     pageHeader                       4
     NvSaveDataSet                  604
     NvCopyDataSet                  216
     pageHeader                       4
     NvCopyTheRemainsDataSets       202
     ??DataTable5                     4
     ??DataTable5_1                   4
     ??DataTable7                     4
     ??DataTable7_1                   4
     ??DataTable8                     4
     ??DataTable17                    4
     ??DataTable18                    4
     ??DataTable18_1                  4
     ??DataTable18_2                  4
     ??DataTable18_3                  4
     ??DataTable18_4                  4
     ??DataTable19                    4
     ??DataTable19_1                  4
     ??DataTable19_2                  4
     ??DataTable19_3                  4
     ??DataTable19_4                  4
     ??DataTable20                    4
     ??DataTable21                    4
     ??DataTable21_1                  4
     ??DataTable21_2                  4

 
    21 bytes in section .bss
     4 bytes in section .data
 3 132 bytes in section .text
 
 3 132 bytes of CODE memory
    25 bytes of DATA memory

Errors: none
Warnings: none
