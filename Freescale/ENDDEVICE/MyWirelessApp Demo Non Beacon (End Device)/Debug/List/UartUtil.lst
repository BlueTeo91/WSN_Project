###############################################################################
#                                                                             #
#                                                       08/Dec/2015  00:24:13 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Application\UartUtil\UartUtil.c                  #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Application\UartUtil\UartUtil.c" -D              #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Debug\List\" -lC "C:\Documents and               #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Debug\List\" -lB    #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN_Pro #
#                    ject\ENDDEV\MyWirelessApp Demo Non Beacon (End           #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Debug\Obj\"         #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=ARM7TDMI-S --fpu=None              #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.4 Evaluation\arm\INC\DLib_Config_Normal.h"   #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\MacPhy\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\Application\Init\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\Application\Interface\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\Configure\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\UartUtil\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\Application\Source\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\SSM\TS\Interface\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\SSM\TS\Source\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and         #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\SSM\ZTC\Source\"    #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Interface\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\LibInterface\"  #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Source\Display\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End                             #
#                    Device)\PLM\Source\Keyboard\" -I "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\Source\NVM\"    #
#                    -I "C:\Documents and Settings\Administrator\Desktop\WSN_ #
#                    Project\ENDDEV\MyWirelessApp Demo Non Beacon (End        #
#                    Device)\PLM\Source\TMR\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWire #
#                    lessApp Demo Non Beacon (End Device)\PLM\Source\UART\"   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench 5.4  #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Debug\List\UartUtil.lst                          #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\WSN_Proj #
#                    ect\ENDDEV\MyWirelessApp Demo Non Beacon (End            #
#                    Device)\Debug\Obj\UartUtil.o                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\WSN_Project\ENDDEV\MyWirelessApp Demo Non Beacon (End Device)\Application\UartUtil\UartUtil.c
      1          /************************************************************************************
      2          * Includes the UART Utils.
      3          *
      4          * (c) Copyright 2007, Freescale, Inc. All rights reserved.
      5          *
      6          * No part of this document must be reproduced in any form - including copied,
      7          * transcribed, printed or by any electronic means - without specific written
      8          * permission from Freescale Semiconductor.
      9          *
     10          ************************************************************************************/
     11          #include "EmbeddedTypes.h"
     12          #include "UartUtil.h"
     13          #include "UART_Interface.h"
     14          #include "UartLowLevel.h"
     15          
     16          /******************************************************************************/
     17          /******************************************************************************/
     18          
     19          /************************************************************************************
     20          *************************************************************************************
     21          * Private macros
     22          *************************************************************************************
     23          ************************************************************************************/
     24          
     25          /************************************************************************************
     26          *************************************************************************************
     27          * Private prototypes
     28          *************************************************************************************/
     29          
     30          
     31          /************************************************************************************
     32          *************************************************************************************
     33          * Private type definitions
     34          *************************************************************************************
     35          ************************************************************************************/
     36          
     37          /************************************************************************************
     38          *************************************************************************************
     39          * Public memory declarations
     40          *************************************************************************************
     41          ************************************************************************************/
     42           
     43          /************************************************************************************
     44          *************************************************************************************
     45          * Private memory declarations
     46          *************************************************************************************
     47          ************************************************************************************/
     48          
     49          /************************************************************************************
     50          *************************************************************************************
     51          * Public functions
     52          *************************************************************************************
     53          ************************************************************************************/
     54          #if gUart1_Enabled_d || gUart2_Enabled_d
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void UartUtil_TxCallback(unsigned char const *pBuf)
     57          {
     58            (void) pBuf;
     59          }
   \                     UartUtil_TxCallback:
   \   00000000   7047               BX       LR               ;; return
     60          
     61          /************************************************************************************/
     62          

   \                                 In section .text, align 2, keep-with-next
     63          void UartUtil_Tx(uint8_t * pData, uint8_t length)
     64          {
   \                     UartUtil_Tx:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
     65            /* wait until module can insert message into uart buffers */
     66            while(!UartX_Transmit((unsigned char const*)pData,(index_t)length,UartUtil_TxCallback));
   \                     ??UartUtil_Tx_0:
   \   00000006   ....               LDR      R2,??DataTable2
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       Uart2_Transmit
   \   00000014   0028               CMP      R0,#+0
   \   00000016   F6D0               BEQ      ??UartUtil_Tx_0
     67            /* wait until tx complete */
     68            while (UartX_IsTxActive());      
   \                     ??UartUtil_Tx_1:
   \   00000018   ........           BL       Uart2_IsTxActive
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   FBD1               BNE      ??UartUtil_Tx_1
     69          }
   \   00000020   31BC               POP      {R0,R4,R5}
   \   00000022   08BC               POP      {R3}
   \   00000024   1847               BX       R3               ;; return
     70          
     71          /************************************************************************************/
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void UartUtil_Print(uint8_t* pString, uartUtilBlock_t allowToBlock)
     74          {
   \                     UartUtil_Print:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0F00               MOVS     R7,R1
     75            uint16_t i = 0;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0400               MOVS     R4,R0
     76            uint8_t*  pTmpString = pString ;
   \   0000000A   3500               MOVS     R5,R6
     77            
     78            while (*pTmpString != '\0') 
   \                     ??UartUtil_Print_0:
   \   0000000C   2878               LDRB     R0,[R5, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   02D0               BEQ      ??UartUtil_Print_1
     79            {
     80              pTmpString++;
   \   00000012   6D1C               ADDS     R5,R5,#+1
     81              i++;
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   F9E7               B        ??UartUtil_Print_0
     82            } 
     83            if(allowToBlock)
   \                     ??UartUtil_Print_1:
   \   00000018   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000001A   3F0E               LSRS     R7,R7,#+24
   \   0000001C   002F               CMP      R7,#+0
   \   0000001E   06D0               BEQ      ??UartUtil_Print_2
     84            {
     85              /* wait until module can insert message into uart buffers and until tx completes */  
     86          	UartUtil_Tx(pString,(uint8_t)i);
   \   00000020   2100               MOVS     R1,R4
   \   00000022   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000024   090E               LSRS     R1,R1,#+24
   \   00000026   3000               MOVS     R0,R6
   \   00000028   ........           BL       UartUtil_Tx
   \   0000002C   06E0               B        ??UartUtil_Print_3
     87            }
     88            else
     89            {
     90              (void)UartX_Transmit((unsigned char const*)pString,(index_t)i,UartUtil_TxCallback);
   \                     ??UartUtil_Print_2:
   \   0000002E   ....               LDR      R2,??DataTable2
   \   00000030   2100               MOVS     R1,R4
   \   00000032   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000034   090E               LSRS     R1,R1,#+24
   \   00000036   3000               MOVS     R0,R6
   \   00000038   ........           BL       Uart2_Transmit
     91            }
     92          }
   \                     ??UartUtil_Print_3:
   \   0000003C   F1BC               POP      {R0,R4-R7}
   \   0000003E   08BC               POP      {R3}
   \   00000040   1847               BX       R3               ;; return
     93          
     94          
     95          /************************************************************************************/
     96          
     97          /* Trasform from hex to ascii */

   \                                 In section .text, align 2, keep-with-next
     98          static uint8_t HexToAscii(uint8_t hex)
     99          {
   \                     HexToAscii:
   \   00000000   00B5               PUSH     {LR}
    100            hex &= 0x0F;
   \   00000002   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000004   000F               LSRS     R0,R0,#+28
    101            return hex + ((hex <= 9) ? '0' : ('A'-10));
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   0A28               CMP      R0,#+10
   \   0000000C   01D2               BCS      ??HexToAscii_0
   \   0000000E   3021               MOVS     R1,#+48
   \   00000010   00E0               B        ??HexToAscii_1
   \                     ??HexToAscii_0:
   \   00000012   3721               MOVS     R1,#+55
   \                     ??HexToAscii_1:
   \   00000014   4018               ADDS     R0,R0,R1
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    102          }
    103          
    104          /************************************************************************************/
    105          
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void UartUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
    108          {
   \                     UartUtil_PrintHex:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0600               MOVS     R6,R0
   \   00000006   0C00               MOVS     R4,R1
   \   00000008   1700               MOVS     R7,R2
    109            uint8_t i=0; 
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0500               MOVS     R5,R0
    110            uint8_t hexString[6]; /* 2 bytes  - hexadecimal display 
    111                                     1 byte   - separator ( comma)
    112          						   1 byte   - separator ( space)
    113                                     2 bytes  - new line (\n\r)  */
    114            
    115            if(! (flags & gPrtHexBigEndian_c))
   \   0000000E   F807               LSLS     R0,R7,#+31
   \   00000010   03D4               BMI      ??UartUtil_PrintHex_0
    116             {
    117              hex = hex + (len-1);
   \   00000012   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000014   240E               LSRS     R4,R4,#+24
   \   00000016   3619               ADDS     R6,R6,R4
   \   00000018   761E               SUBS     R6,R6,#+1
    118             }
    119             
    120            while(len)
   \                     ??UartUtil_PrintHex_0:
   \   0000001A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000001C   240E               LSRS     R4,R4,#+24
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   4AD0               BEQ      ??UartUtil_PrintHex_1
    121            {
    122              /* wait until previous hex print transmission is over */  
    123              while (UartX_IsTxActive());  
   \                     ??UartUtil_PrintHex_2:
   \   00000022   ........           BL       Uart2_IsTxActive
   \   00000026   0028               CMP      R0,#+0
   \   00000028   FBD1               BNE      ??UartUtil_PrintHex_2
    124                
    125              /* start preparing the print of a new byte */
    126              i=0;
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   0500               MOVS     R5,R0
    127              hexString[i++] = HexToAscii((*hex)>>4);
   \   0000002E   3078               LDRB     R0,[R6, #+0]
   \   00000030   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000032   000E               LSRS     R0,R0,#+24
   \   00000034   0009               LSRS     R0,R0,#+4
   \   00000036   ........           BL       HexToAscii
   \   0000003A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003C   2D0E               LSRS     R5,R5,#+24
   \   0000003E   6946               MOV      R1,SP
   \   00000040   4855               STRB     R0,[R1, R5]
   \   00000042   6D1C               ADDS     R5,R5,#+1
    128              hexString[i++] = HexToAscii( *hex);
   \   00000044   3078               LDRB     R0,[R6, #+0]
   \   00000046   ........           BL       HexToAscii
   \   0000004A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000004C   2D0E               LSRS     R5,R5,#+24
   \   0000004E   6946               MOV      R1,SP
   \   00000050   4855               STRB     R0,[R1, R5]
   \   00000052   6D1C               ADDS     R5,R5,#+1
    129          
    130              if(flags & gPrtHexCommas_c)
   \   00000054   7807               LSLS     R0,R7,#+29
   \   00000056   05D5               BPL      ??UartUtil_PrintHex_3
    131               {
    132                hexString[i++] = ',';
   \   00000058   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000005A   2D0E               LSRS     R5,R5,#+24
   \   0000005C   6846               MOV      R0,SP
   \   0000005E   2C21               MOVS     R1,#+44
   \   00000060   4155               STRB     R1,[R0, R5]
   \   00000062   6D1C               ADDS     R5,R5,#+1
    133               }
    134              if(flags & gPrtHexSpaces_c) 
   \                     ??UartUtil_PrintHex_3:
   \   00000064   3807               LSLS     R0,R7,#+28
   \   00000066   05D5               BPL      ??UartUtil_PrintHex_4
    135               { 
    136                hexString[i++] = ' ';
   \   00000068   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000006A   2D0E               LSRS     R5,R5,#+24
   \   0000006C   6846               MOV      R0,SP
   \   0000006E   2021               MOVS     R1,#+32
   \   00000070   4155               STRB     R1,[R0, R5]
   \   00000072   6D1C               ADDS     R5,R5,#+1
    137               }
    138              hex = hex + (flags & gPrtHexBigEndian_c ? 1 : -1);
   \                     ??UartUtil_PrintHex_4:
   \   00000074   F807               LSLS     R0,R7,#+31
   \   00000076   01D5               BPL      ??UartUtil_PrintHex_5
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   01E0               B        ??UartUtil_PrintHex_6
   \                     ??UartUtil_PrintHex_5:
   \   0000007C   0020               MOVS     R0,#+0
   \   0000007E   C043               MVNS     R0,R0            ;; #-1
   \                     ??UartUtil_PrintHex_6:
   \   00000080   3618               ADDS     R6,R6,R0
    139              len--;
   \   00000082   641E               SUBS     R4,R4,#+1
    140              
    141              if((len == 0) && (flags & gPrtHexNewLine_c))
   \   00000084   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000086   240E               LSRS     R4,R4,#+24
   \   00000088   002C               CMP      R4,#+0
   \   0000008A   0DD1               BNE      ??UartUtil_PrintHex_7
   \   0000008C   B807               LSLS     R0,R7,#+30
   \   0000008E   0BD5               BPL      ??UartUtil_PrintHex_7
    142               {
    143                hexString[i++] = '\n';
   \   00000090   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000092   2D0E               LSRS     R5,R5,#+24
   \   00000094   6846               MOV      R0,SP
   \   00000096   0A21               MOVS     R1,#+10
   \   00000098   4155               STRB     R1,[R0, R5]
   \   0000009A   6D1C               ADDS     R5,R5,#+1
    144                hexString[i++] = '\r';
   \   0000009C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000009E   2D0E               LSRS     R5,R5,#+24
   \   000000A0   6846               MOV      R0,SP
   \   000000A2   0D21               MOVS     R1,#+13
   \   000000A4   4155               STRB     R1,[R0, R5]
   \   000000A6   6D1C               ADDS     R5,R5,#+1
    145               }
    146               /* transmit formatted byte */      
    147              (void)UartX_Transmit((unsigned char const*)hexString,(index_t)i,UartUtil_TxCallback);   
   \                     ??UartUtil_PrintHex_7:
   \   000000A8   ....               LDR      R2,??DataTable2
   \   000000AA   2900               MOVS     R1,R5
   \   000000AC   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000000AE   090E               LSRS     R1,R1,#+24
   \   000000B0   6846               MOV      R0,SP
   \   000000B2   ........           BL       Uart2_Transmit
   \   000000B6   B0E7               B        ??UartUtil_PrintHex_0
    148            }
    149            /* wait to complete the last transmission */
    150            while (UartX_IsTxActive());   
   \                     ??UartUtil_PrintHex_1:
   \   000000B8   ........           BL       Uart2_IsTxActive
   \   000000BC   0028               CMP      R0,#+0
   \   000000BE   FBD1               BNE      ??UartUtil_PrintHex_1
    151          }
   \   000000C0   F7BC               POP      {R0-R2,R4-R7}
   \   000000C2   08BC               POP      {R3}
   \   000000C4   1847               BX       R3               ;; return
    152          
    153          /************************************************************************************/
    154          /* Configure UART to work in stop mode or in normal mode*/

   \                                 In section .text, align 2, keep-with-next
    155          void UartUtil_ConfigureStopMode(bool_t enterStopMode)
    156          {
   \                     UartUtil_ConfigureStopMode:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    157          
    158            if ( TRUE == enterStopMode )
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   012C               CMP      R4,#+1
   \   0000000A   0AD1               BNE      ??UartUtil_ConfigureStopMode_0
    159            {  
    160              /* Configure UART before entering stop mode */  
    161              #if (gUart1_Enabled_d == TRUE)  
    162              UartCloseReceiver(UART_1);
    163              UartCloseTransmitter(UART_1);            
    164              #endif /* gUart1_Enabled_d */
    165              
    166              #if (gUart2_Enabled_d == TRUE)  
    167              UartCloseReceiver(UART_2);
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   0221               MOVS     R1,#+2
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   ........           BL       UartOpenCloseTransceiver
    168              UartCloseTransmitter(UART_2);            
   \   00000016   0022               MOVS     R2,#+0
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   0120               MOVS     R0,#+1
   \   0000001C   ........           BL       UartOpenCloseTransceiver
   \   00000020   09E0               B        ??UartUtil_ConfigureStopMode_1
    169              #endif /* gUart2_Enabled_d */
    170            }  
    171            else
    172            {
    173              /* Restore UART settings */ 
    174              #if (gUart1_Enabled_d == TRUE)  
    175              UartOpenReceiver(UART_1); 
    176              UartOpenTransmitter(UART_1); 
    177              #endif /* gUart1_Enabled_d */
    178              
    179              #if (gUart2_Enabled_d == TRUE)  
    180              UartOpenReceiver(UART_2); 
   \                     ??UartUtil_ConfigureStopMode_0:
   \   00000022   0122               MOVS     R2,#+1
   \   00000024   0221               MOVS     R1,#+2
   \   00000026   0120               MOVS     R0,#+1
   \   00000028   ........           BL       UartOpenCloseTransceiver
    181              UartOpenTransmitter(UART_2);           
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   ........           BL       UartOpenCloseTransceiver
    182              #endif /* gUart2_Enabled_d */       
    183          
    184            }
    185          
    186          }  
   \                     ??UartUtil_ConfigureStopMode_1:
   \   00000036   10BC               POP      {R4}
   \   00000038   08BC               POP      {R3}
   \   0000003A   1847               BX       R3               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     UartUtil_TxCallback
    187          
    188          #else /* gUart1_Enabled_d || gUart2_Enabled_d */
    189          
    190          /* Create  dummy functions  */
    191          void UartUtil_Print(uint8_t* pString, uartUtilBlock_t allowToBlock)
    192          {
    193            /* Avoid compiler warning */
    194            (void)pString;
    195            (void)allowToBlock;
    196          }
    197          
    198          /************************************************************************************/
    199          
    200          void UartUtil_PrintHex(uint8_t *hex, uint8_t len, uint8_t flags)
    201          {
    202            /* Avoid compiler warning */
    203            (void)hex;
    204            (void)len;
    205            (void)flags;
    206          }
    207          
    208          /************************************************************************************/
    209          
    210          void UartUtil_Tx(uint8_t * pData, uint8_t length){
    211            /* Avoid compiler warning */
    212            (void)pData;
    213            (void)length;
    214          }
    215          
    216          /************************************************************************************/
    217          void UartUtil_ConfigureStopMode(bool_t enterStopMode){
    218          (void)enterStopMode;  
    219          }
    220          #endif  /* gUart1_Enabled_d || gUart2_Enabled_d */

   Maximum stack usage in bytes:

     Function                   .cstack
     --------                   -------
     HexToAscii                      4
     UartUtil_ConfigureStopMode      8
     UartUtil_Print                 24
     UartUtil_PrintHex              32
     UartUtil_Tx                    16
     UartUtil_TxCallback             0


   Section sizes:

     Function/Label             Bytes
     --------------             -----
     UartUtil_TxCallback           2
     UartUtil_Tx                  38
     UartUtil_Print               66
     HexToAscii                   30
     UartUtil_PrintHex           198
     UartUtil_ConfigureStopMode   60
     ??DataTable2                  4

 
 398 bytes in section .text
 
 398 bytes of CODE memory

Errors: none
Warnings: none
