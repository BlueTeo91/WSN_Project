///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      08/Dec/2015  21:20:00 /
// IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM               /
// Copyright (C) 1999-2010 IAR Systems AB.                                    /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\LPM\PWR.c                            /
//    Command line =  "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\LPM\PWR.c" -D gMacStandAlone_d=1 -D  /
//                    gSAPMessagesEnableLlc_d=0 -D gZtcIncluded_d=0 -D        /
//                    gTargetMC1322xSRB=1 --preprocess "C:\Documents and      /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" -lC "C:\Documents and  /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" -lB "C:\Documents and  /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" --diag_suppress        /
//                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and      /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\Obj\" --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa --no_clustering  /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program   /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\DLib_Config_Normal.h" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\MacPhy\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Init\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Interface\" -I "C:\Documents and    /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Configure\" -I          /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\UartUtil\" -I "C:\Documents and     /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Source\" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\TS\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\TS\Source\" -I "C:\Documents    /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and        /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\ZTC\Source\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Interface\" -I "C:\Documents and            /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\LibInterface\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\Display\" -I "C:\Documents and       /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\Keyboard\" -I            /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\NVM\" -I "C:\Documents and           /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\TMR\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR      /
//                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"     /
//                    --interwork --cpu_mode thumb -On                        /
//    List file    =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Debug\List\PWR.s                                /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME PWR

        EXTERN Asp_GetMacStateReq
        EXTERN CRM_GoToSleep
        EXTERN CRM_Wait4Irq
        EXTERN CRM_WuCntl
        EXTERN DeepSleepWakeupStackProc
        EXTERN IntDisableAll
        EXTERN IntRestoreAll
        EXTERN TMR_AreAllTimersOff
        EXTERN TMR_NotCountedTicksBeforeSleep
        EXTERN TMR_SyncLpmTimers
        EXTERN TS_PendingEvents
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dmul
        EXTERN __aeabi_ui2d
        EXTERN gHardwareParameters

        PUBLIC PWRLib_LVD_ReportLevel
        PUBLIC PWRLib_MCU_WakeupReason
        PUBLIC PWRLib_Reset
        PUBLIC PWRLib_StackPS
        PUBLIC PWR_AllOff
        PUBLIC PWR_AllowDeviceToSleep
        PUBLIC PWR_CheckForAndEnterNewPowerState
        PUBLIC PWR_CheckForAndEnterNewPowerState_Init
        PUBLIC PWR_CheckIfDeviceCanGoToSleep
        PUBLIC PWR_DeepSleepAllowed
        PUBLIC PWR_DisallowDeviceToSleep
        PUBLIC PWR_EnterLowPower
        PUBLIC PWR_HandleDeepSleep
        PUBLIC PWR_HandleSleep
        PUBLIC PWR_MCUSleep
        PUBLIC PWR_MCUWait
        PUBLIC PWR_RunAgain
        PUBLIC PWR_SetDozeTimeSymbols
        PUBLIC PWR_SetExtOutPol
        PUBLIC PWR_SleepAllowed

// C:\Documents and Settings\Administrator\Desktop\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\PLM\Source\LPM\PWR.c
//    1 /************************************************************************************
//    2 * Function to handle the different power down states.
//    3 *
//    4 *
//    5 * (c) Copyright 2008, Freescale, Inc. All rights reserved.
//    6 *
//    7 *
//    8 * No part of this document must be reproduced in any form - including copied,
//    9 * transcribed, printed or by any electronic means - without specific written
//   10 * permission from Freescale Semiconductor.
//   11 *
//   12 ************************************************************************************/
//   13 
//   14 
//   15 /************************************************************************************
//   16 *************************************************************************************
//   17 * Includes
//   18 *************************************************************************************
//   19 ************************************************************************************/
//   20 #include "EmbeddedTypes.h"
//   21 #include "PWR_Configuration.h"   
//   22 #include "PWR_Interface.h"
//   23 #include "Crm.h"
//   24 #include "Keyboard.h"
//   25 #include "KeyboardHAL.h"
//   26 #include "Interrupt.h"
//   27 #include "AppAspInterface.h"
//   28 #include "AppToPlatformConfig.h"
//   29 #include "TMR_Interface.h"
//   30 #include "NV_Data.h"
//   31 /******************************************************************************
//   32 *******************************************************************************
//   33 * Private macros
//   34 *******************************************************************************
//   35 ******************************************************************************/                                              
//   36 
//   37 #define PWR_MCUDoze()      PWR_MCUSleep(gDoze_c)
//   38 
//   39 #define PWR_MCUHibernate() PWR_MCUSleep(gHibernate_c)
//   40 
//   41 #define mPWR_MacaClk                       (*((volatile uint32_t *)(0x80004048)))
//   42 #define mMACA_TIMER_UPDATE_FACTOR_HIB_2K   125
//   43 #define mMACA_TIMER_UPDATE_FACTOR_HIB_32K  (125.0/16.0)
//   44 #define mMACA_TIMER_UPDATE_FACTOR_DOZE     ((250000.0*128.0)/SYSTEM_CLOCK)
//   45 
//   46 /******************************************************************************
//   47 *******************************************************************************
//   48 * Private prototypes
//   49 *******************************************************************************
//   50 ******************************************************************************/
//   51 #if (cPWR_UsePowerDownMode)
//   52 #if (cPWR_UpdateMACAClockAtWakeUp)
//   53 static void PWR_MacaTimerUpdate(void);
//   54 #endif /* cPWR_UpdateMACAClockAtWakeUp */
//   55 #endif /* cPWR_UsePowerDownMode */
//   56 /******************************************************************************
//   57 *******************************************************************************
//   58 * Private type definitions
//   59 *******************************************************************************
//   60 ******************************************************************************/
//   61 
//   62 /******************************************************************************
//   63 *******************************************************************************
//   64 * Private memory declarations
//   65 *******************************************************************************
//   66 ******************************************************************************/
//   67 #if (gTMR_EnableLowPowerTimers_d) 
//   68 #if cPWR_UsePowerDownMode

        SECTION `.bss`:DATA:NOROOT(1)
//   69  static uint16_t notCountedTmrTicksBeforeSleep;
notCountedTmrTicksBeforeSleep:
        DS8 2
//   70 #endif //cPWR_UsePowerDownMode
//   71 #endif
//   72 
//   73 #if cPWR_UsePowerDownMode

        SECTION `.bss`:DATA:NOROOT(0)
//   74 static uint8_t mExtOutPol = cPWR_ExtOutPol;
mExtOutPol:
        DS8 1
//   75 #endif //cPWR_UsePowerDownMode
//   76 /******************************************************************************
//   77 *******************************************************************************
//   78 * Public memory declarations
//   79 *******************************************************************************
//   80 ******************************************************************************/

        SECTION `.bss`:DATA:NOROOT(0)
//   81 static uint8_t mLPMFlag = gAllowDeviceToSleep_c;
mLPMFlag:
        DS8 1
//   82 /* but recommended to be regarded as private */
//   83 
//   84 #if (cPWR_UpdateMACAClockAtWakeUp)
//   85 #if cPWR_UsePowerDownMode

        SECTION `.bss`:DATA:NOROOT(2)
//   86 static   uint32_t mSavedMacaClk;
mSavedMacaClk:
        DS8 4
//   87 #endif //cPWR_UsePowerDownMode
//   88 #endif /* cPWR_UpdateMACAClockAtWakeUp */
//   89 

        SECTION `.bss`:DATA:NOROOT(2)
//   90 volatile PWRLib_WakeupReason_t     PWRLib_MCU_WakeupReason;
PWRLib_MCU_WakeupReason:
        DS8 4
//   91 
//   92 #if (cPWR_UseMCUStatus)
//   93   PWRLib_MCUStatus_t               PWRLib_MCUStatus;
//   94 #endif  // #if (cPWR_UseMCUStatus)
//   95  
//   96 #if (cPWR_UseRADIOStatus)
//   97     PWRLib_RADIOStatus_t           PWRLib_RADIOStatus;
//   98 #endif  /* #if (cPWR_UseRADIOStatus) */ 
//   99 /*--- Zigbee STACK status ---*/ 

        SECTION `.bss`:DATA:NOROOT(0)
//  100 PWRLib_StackPS_t                   PWRLib_StackPS;
PWRLib_StackPS:
        DS8 1
//  101 
//  102 
//  103 /* Sleep timeout in MAC symbols to be used in DeepSleepMode 8 */
//  104 #if ((cPWR_UsePowerDownMode) && (cPWR_DeepSleepMode == 8))
//  105  static uint32_t mPWR_SleepTimeoutSym = cPWR_Ms2MACSymbols(cPWR_SleepTimeoutMs);
//  106 #endif   
//  107  
//  108 
//  109 /************************************************************************************
//  110 * Set the output state of the 4 external drivers (i.e. KBI[3:0] ) for use during sleep.
//  111 *
//  112 * Interface assumptions:
//  113 *   None
//  114 *   
//  115 * Return value:
//  116 *   None
//  117 * 
//  118 ************************************************************************************/
//  119 #if cPWR_UsePowerDownMode

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  120 void PWR_SetExtOutPol(uint8_t val)
//  121 {
//  122   mExtOutPol = val;
PWR_SetExtOutPol:
        LDR      R1,??DataTable12
        STRB     R0,[R1, #+0]
//  123 }
        BX       LR               ;; return
//  124 #endif //cPWR_UsePowerDownMode
//  125 
//  126 /************************************************************************************
//  127 * Set the NVM write operation semaphore.
//  128 *
//  129 * This function will set the NVM write operation semaphore so that the idle task wont
//  130 * do a NVM write operation unless this is released by calling 
//  131 * NVM_ClearCriticalNVMSection.
//  132 *
//  133 * Interface assumptions:
//  134 *   None
//  135 *   
//  136 * Return value:
//  137 *   None
//  138 * 
//  139 ************************************************************************************/
//  140 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  141 void PWR_AllowDeviceToSleep(void)
//  142 {
PWR_AllowDeviceToSleep:
        PUSH     {R4,LR}
//  143   unsigned int saveInt;
//  144   saveInt = IntDisableAll();
        BL       IntDisableAll
        MOVS     R4,R0
//  145   
//  146   if( mLPMFlag != 0 )
        LDR      R0,??DataTable12_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??PWR_AllowDeviceToSleep_0
//  147   {
//  148     mLPMFlag--;
        LDR      R0,??DataTable12_1
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR      R1,??DataTable12_1
        STRB     R0,[R1, #+0]
//  149   }
//  150   IntRestoreAll(saveInt);
??PWR_AllowDeviceToSleep_0:
        MOVS     R0,R4
        BL       IntRestoreAll
//  151 }
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  152 
//  153 /************************************************************************************
//  154 * Release the NVM write operation semaphore.
//  155 *
//  156 * This function will release the NVM write operation semaphore so that the idle task 
//  157 * can do a NVM write operation.
//  158 *  
//  159 * Interface assumptions:
//  160 *   None
//  161 *   
//  162 * Return value:
//  163 *   None
//  164 *
//  165 ************************************************************************************/
//  166  

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  167 void PWR_DisallowDeviceToSleep(void)
//  168 {
PWR_DisallowDeviceToSleep:
        PUSH     {R7,LR}
//  169   IntDisableAll();
        BL       IntDisableAll
//  170   mLPMFlag++;
        LDR      R0,??DataTable12_1
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable12_1
        STRB     R0,[R1, #+0]
//  171   IntEnableAll();
        MOVS     R0,#+0
        BL       IntRestoreAll
//  172 }
        POP      {R0,R3}
        BX       R3               ;; return
//  173 
//  174 /***********************************************************************************
//  175 * This function is used to  Check  the Permission flag to go to 
//  176 * low power mode
//  177 *
//  178 * Interface assumptions:
//  179 * None
//  180 * 
//  181 * The routine limitations.
//  182 * None
//  183 *
//  184 * Return value:
//  185 *   TRUE  : If the device is allowed to go to the LPM else FALSE
//  186 *
//  187 * Effects on global data.
//  188 * None
//  189 *
//  190 * Source of algorithm used.
//  191 * None
//  192 *
//  193 *****************************************************************************/ 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  194 bool_t PWR_CheckIfDeviceCanGoToSleep( void ) 
//  195 {
PWR_CheckIfDeviceCanGoToSleep:
        PUSH     {LR}
//  196   return (bool_t)(mLPMFlag == 0); 
        LDR      R0,??DataTable12_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??PWR_CheckIfDeviceCanGoToSleep_0
        MOVS     R0,#+1
        B        ??PWR_CheckIfDeviceCanGoToSleep_1
??PWR_CheckIfDeviceCanGoToSleep_0:
        MOVS     R0,#+0
??PWR_CheckIfDeviceCanGoToSleep_1:
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        POP      {R3}
        BX       R3               ;; return
//  197 }
//  198 
//  199 /*****************************************************************************/
//  200 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  201 void PWRLib_Reset(void)
//  202 {
//  203  CRM_SoftReset();
PWRLib_Reset:
        LDR      R0,??DataTable12_2  ;; 0x80003050
        LDR      R1,??DataTable13  ;; 0x87651234
        STR      R1,[R0, #+0]
//  204 }
        BX       LR               ;; return
//  205 /*****************************************************************************/
//  206 
//  207 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  208 void PWR_MCUWait(void) {
PWR_MCUWait:
        PUSH     {R7,LR}
//  209 #if (cPWR_UsePowerDownMode)
//  210   mMCU_SetStatus( MCU_Wait);
//  211   mRADIO_SetStatus(RADIO_Idle);
//  212   CRM_Wait4Irq();
        BL       CRM_Wait4Irq
//  213 #endif  /* #if (cPWR_UsePowerDownMode) */
//  214 }  /* PWR_MCUWait(void) =================================================== */
        POP      {R0,R3}
        BX       R3               ;; return
//  215 
//  216 /*****************************************************************************/
//  217 #if (cPWR_UsePowerDownMode)

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  218 static void PWR_CallBeforeSleep(void) 
//  219 {
//  220 #if (cPWR_UpdateMACAClockAtWakeUp)
//  221   mSavedMacaClk = mPWR_MacaClk;
PWR_CallBeforeSleep:
        LDR      R0,??DataTable12_3
        LDR      R1,??DataTable13_1  ;; 0x80004048
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
//  222 #endif /* cPWR_UpdateMACAClockAtWakeUp */  
//  223 }  /* PWR_CallBeforeSleep(void) =================================================== */
        BX       LR               ;; return
//  224 #endif  /* #if (cPWR_UsePowerDownMode) */
//  225 
//  226 /*****************************************************************************/
//  227 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  228 void PWR_MCUSleep(crmSleep_t crmSleep) {
PWR_MCUSleep:
        PUSH     {R2-R4,LR}
        MOVS     R4,R0
//  229 #if (cPWR_UsePowerDownMode)
//  230  crmSleepCtrl_t  crmSleepCtrl;
//  231  
//  232  crmSleepCtrl.sleepType = crmSleep;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+254
        ANDS     R1,R1,R0
        MOVS     R0,R4
        LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
        LSRS     R0,R0,#+31
        ORRS     R0,R0,R1
        MOV      R1,SP
        STRB     R0,[R1, #+0]
//  233  crmSleepCtrl.ramRet = cPWR_RAMRetentionMode;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+6
        ORRS     R1,R1,R0
        MOV      R0,SP
        STRB     R1,[R0, #+0]
//  234  crmSleepCtrl.mcuRet = cPWR_MCURetentionMode;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+8
        ORRS     R1,R1,R0
        MOV      R0,SP
        STRB     R1,[R0, #+0]
//  235  crmSleepCtrl.digPadRet = cPWR_MCUPadRetentionMode;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+16
        ORRS     R1,R1,R0
        MOV      R0,SP
        STRB     R1,[R0, #+0]
//  236  crmSleepCtrl.pfToDoBeforeSleep = PWR_CallBeforeSleep;
        LDR      R0,??DataTable13_2
        STR      R0,[SP, #+4]
//  237  
//  238  CRM_WU_CNTL.extOutPol = mExtOutPol;
        LDR      R0,??DataTable14  ;; 0x80003004
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
        LSRS     R0,R0,#+4
        LDR      R1,??DataTable12
        LDRB     R1,[R1, #+0]
        LSLS     R1,R1,#+28
        ORRS     R1,R1,R0
        LDR      R0,??DataTable14  ;; 0x80003004
        STR      R1,[R0, #+0]
//  239  
//  240  if(crmSleep == gDoze_c)
//  241  {
//  242   mMCU_SetStatus(MCU_Doze);
//  243  }
//  244  
//  245  if(crmSleep == gHibernate_c)
//  246  {
//  247   mMCU_SetStatus(MCU_Hibernate);
//  248  }
//  249  mRADIO_SetStatus(RADIO_Off);
//  250  CRM_GoToSleep(&crmSleepCtrl);
        MOV      R0,SP
        BL       CRM_GoToSleep
//  251 #endif  /* #if (cPWR_UsePowerDownMode) */
//  252 }  /* PWR_MCUSleep(void) =================================================== */
        POP      {R0,R1,R4}
        POP      {R3}
        BX       R3               ;; return
//  253 
//  254 /*****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  255 void PWR_AllOff(void)
//  256 {
PWR_AllOff:
        PUSH     {R7,LR}
//  257   #if (cPWR_UsePowerDownMode)
//  258    /* Disable the wake-up sources in crm */
//  259    CRM_WU_CNTL.extWuEn = 0;
        LDR      R0,??DataTable14  ;; 0x80003004
        LDR      R0,[R0, #+0]
        MOVS     R1,#+240
        BICS     R0,R0,R1
        LDR      R1,??DataTable14  ;; 0x80003004
        STR      R0,[R1, #+0]
//  260    CRM_WU_CNTL.timerWuEn = 0;
        LDR      R0,??DataTable14  ;; 0x80003004
        LDR      R0,[R0, #+0]
        MOVS     R1,#+1
        BICS     R0,R0,R1
        LDR      R1,??DataTable14  ;; 0x80003004
        STR      R0,[R1, #+0]
//  261    CRM_WU_CNTL.rtcWuEn = 0;
        LDR      R0,??DataTable14  ;; 0x80003004
        LDR      R0,[R0, #+0]
        MOVS     R1,#+2
        BICS     R0,R0,R1
        LDR      R1,??DataTable14  ;; 0x80003004
        STR      R0,[R1, #+0]
//  262    /* Enter Hibernate with no wake-up sources. wake-up on Reset only */
//  263    PWR_MCUHibernate();
        MOVS     R0,#+0
        BL       PWR_MCUSleep
//  264   #endif
//  265 }  /* PWR_AllOff(void) =================================================== */
        POP      {R0,R3}
        BX       R3               ;; return
//  266 
//  267 
//  268 /*****************************************************************************/
//  269 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  270 void PWR_RunAgain(void) {
PWR_RunAgain:
        PUSH     {R7,LR}
//  271   #if (cPWR_UsePowerDownMode)
//  272 
//  273    while(CRM_STATUS.sleepSync == 0);
??PWR_RunAgain_0:
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL      ??PWR_RunAgain_0
//  274    
//  275    if(FALSE == gHardwareParameters.gSystemClock24MHz_c)
        LDR      R0,??DataTable14_2
        ADDS     R0,R0,#+35
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??PWR_RunAgain_1
//  276    {
//  277     (*((volatile uint32_t *)(0x80003048))) = 0x00000F78;
        LDR      R0,??DataTable14_3  ;; 0x80003048
        LDR      R1,??DataTable14_4  ;; 0xf78
        STR      R1,[R0, #+0]
//  278     (*((volatile uint32_t *)(0x80009000))) = 0xC0050300;
        LDR      R0,??DataTable14_5  ;; 0x80009000
        LDR      R1,??DataTable14_6  ;; 0xc0050300
        STR      R1,[R0, #+0]
//  279    }
//  280 #if (cPWR_UpdateMACAClockAtWakeUp)
//  281    PWR_MacaTimerUpdate();
??PWR_RunAgain_1:
        BL       PWR_MacaTimerUpdate
//  282 #endif
//  283    CRM_REGS_P->Status = 1;
        LDR      R0,??DataTable14_1  ;; 0x80003018
        MOVS     R1,#+1
        STR      R1,[R0, #+0]
//  284 
//  285     #if (gTMR_EnableLowPowerTimers_d) 
//  286     {
//  287            volatile uint32_t crmSleepTime = CRM_REGS_P->WuCount;
        LDR      R0,??DataTable14_7  ;; 0x80003020
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+0]
//  288            
//  289            crmSleepTime = cPWR_WuTmrTicks2TmrTicks(crmSleepTime);
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
        LSRS     R1,R1,#+31
        CMP      R1,#+0
        BEQ      ??PWR_RunAgain_2
        LDR      R0,??DataTable15  ;; 0x80003000
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+31
        LSRS     R1,R1,#+31
        CMP      R1,#+0
        BEQ      ??PWR_RunAgain_3
        LDR      R0,??DataTable15_1  ;; 0x80003044
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+31
        BPL      ??PWR_RunAgain_3
        LDR      R0,[SP, #+0]
        MOVS     R1,#+5
        MULS     R0,R1,R0
        STR      R0,[SP, #+0]
        B        ??PWR_RunAgain_4
??PWR_RunAgain_3:
        LDR      R0,[SP, #+0]
        MOVS     R1,#+93
        MULS     R0,R1,R0
        STR      R0,[SP, #+0]
        B        ??PWR_RunAgain_4
??PWR_RunAgain_2:
        LDR      R0,[SP, #+0]
        STR      R0,[SP, #+0]
//  290            
//  291            crmSleepTime += notCountedTmrTicksBeforeSleep;
??PWR_RunAgain_4:
        LDR      R0,[SP, #+0]
        LDR      R1,??DataTable15_2
        LDRH     R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[SP, #+0]
//  292            /* Sync. the low power timers */
//  293            TMR_SyncLpmTimers(crmSleepTime);
        LDR      R0,[SP, #+0]
        BL       TMR_SyncLpmTimers
//  294      }  
//  295     #endif /* #if (gTMR_EnableLowPowerTimers_d)  */
//  296 
//  297   CRM_REGS_P->Status = (CRM_REGS_P->Status & (~0xF0)); /* Clear interrupt sources except from KBI */
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,#+240
        BICS     R0,R0,R1
        LDR      R1,??DataTable14_1  ;; 0x80003018
        STR      R0,[R1, #+0]
//  298 
//  299   mMCU_SetStatus(MCU_Running);
//  300   mRADIO_SetStatus(RADIO_Idle);
//  301   #endif  /* #if (cPWR_UsePowerDownMode) */
//  302 }  /* PWR_RunAgain(void) ======================================================*/
        POP      {R0,R3}
        BX       R3               ;; return
//  303 
//  304 
//  305 /*****************************************************************************/
//  306 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  307 bool_t PWR_DeepSleepAllowed(void) {
PWR_DeepSleepAllowed:
        PUSH     {R7,LR}
//  308   #if ( cPWR_UsePowerDownMode)
//  309     #if ( cPWR_DeepSleepMode < cPWR_DeepSleepModeMax)                               /* Normal running mode*/
//  310       if (PWRLib_GetCurrentZigbeeStackPowerState == StackPS_DeepSleep) {
        LDR      R0,??DataTable15_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+124
        BNE      ??PWR_DeepSleepAllowed_0
//  311           if ( Asp_GetMacStateReq() == gAspMacStateIdle_c) {
        BL       Asp_GetMacStateReq
        CMP      R0,#+0
        BNE      ??PWR_DeepSleepAllowed_1
//  312             return TRUE;
        MOVS     R0,#+1
        B        ??PWR_DeepSleepAllowed_2
//  313           } else {
//  314             return FALSE;
??PWR_DeepSleepAllowed_1:
        MOVS     R0,#+0
        B        ??PWR_DeepSleepAllowed_2
//  315           }
//  316       } else {
//  317         return FALSE;
??PWR_DeepSleepAllowed_0:
        MOVS     R0,#+0
??PWR_DeepSleepAllowed_2:
        POP      {R1,R3}
        BX       R3               ;; return
//  318       }
//  319     #else                                                /* Debug mode */
//  320       #error "*** ERROR: cPWR_DeepSleepMode has an unsupported value"
//  321     #endif
//  322   #else                                                      /* Debug mode */
//  323     return TRUE;
//  324   #endif  /* #if (cPWR_UsePowerDownMode)*/
//  325 }  /* PWR_DeepSleepAllowed ==================================================*/
//  326 
//  327 
//  328 /*****************************************************************************/
//  329 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  330 bool_t  PWR_SleepAllowed(void) {  
PWR_SleepAllowed:
        PUSH     {R7,LR}
//  331   #if (cPWR_UsePowerDownMode)
//  332     #if (cPWR_SleepMode < cPWR_SleepModeMax)                               /* Normal running mode*/
//  333       if (( PWRLib_GetCurrentZigbeeStackPowerState == StackPS_Sleep) ||  \ 
//  334           ( PWRLib_GetCurrentZigbeeStackPowerState == StackPS_DeepSleep)) {
        LDR      R0,??DataTable16
        LDRB     R0,[R0, #+0]
        CMP      R0,#+123
        BEQ      ??PWR_SleepAllowed_0
        LDR      R0,??DataTable16
        LDRB     R0,[R0, #+0]
        CMP      R0,#+124
        BNE      ??PWR_SleepAllowed_1
//  335           if (( Asp_GetMacStateReq()==gAspMacStateNotEmpty_c) || \ 
//  336               ( Asp_GetMacStateReq()==gAspMacStateIdle_c)) {
??PWR_SleepAllowed_0:
        BL       Asp_GetMacStateReq
        CMP      R0,#+2
        BEQ      ??PWR_SleepAllowed_2
        BL       Asp_GetMacStateReq
        CMP      R0,#+0
        BNE      ??PWR_SleepAllowed_3
//  337             return TRUE;
??PWR_SleepAllowed_2:
        MOVS     R0,#+1
        B        ??PWR_SleepAllowed_4
//  338           } else {
//  339             return FALSE;
??PWR_SleepAllowed_3:
        MOVS     R0,#+0
        B        ??PWR_SleepAllowed_4
//  340           }
//  341       } else {
//  342         return FALSE;
??PWR_SleepAllowed_1:
        MOVS     R0,#+0
??PWR_SleepAllowed_4:
        POP      {R1,R3}
        BX       R3               ;; return
//  343       }
//  344     #else                                                      /* Debug mode */
//  345       #error "*** ERROR: cPWR_SleepMode has an unsupported value"
//  346     #endif
//  347   #else                                                      /* Debug mode */
//  348     return TRUE;
//  349   #endif  /* #if (cPWR_UsePowerDownMode) else */
//  350 }  /* PWR_SleepAllowed ======================================================*/
//  351 
//  352 
//  353 /*****************************************************************************/
//  354 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  355 PWRLib_WakeupReason_t  PWR_HandleDeepSleep( zbClock24_t  DozeDuration) {
PWR_HandleDeepSleep:
        PUSH     {R0-R4,LR}
        MOVS     R4,R0
//  356   PWRLib_WakeupReason_t  Res;
//  357   Res.AllBits = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  358   
//  359   /* To avoid warnings */
//  360   (void)DozeDuration;
//  361   
//  362   #if (cPWR_UsePowerDownMode)
//  363   
//  364 		  /*---------------------------------------------------------------------------*/
//  365     #if (cPWR_DeepSleepMode==0)
//  366       Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
//  367       /* No code */
//  368 
//  369     /*---------------------------------------------------------------------------*/
//  370     #elif ((cPWR_DeepSleepMode == 1)  || (cPWR_DeepSleepMode == 5))
//  371       #if (gKeyBoardSupported_d == TRUE)        
//  372          /* Disable the other wake-up sources */
//  373          CRM_WU_CNTL.timerWuEn = 0;
//  374          CRM_WU_CNTL.rtcWuEn = 0;
//  375          
//  376          #if(cPWR_DeepSleepMode == 1)
//  377           PWR_MCUHibernate();
//  378           PWRLib_MCU_WakeupReason.Bits.FromHibernate = TRUE;
//  379          #else
//  380           PWR_MCUDoze();
//  381           PWRLib_MCU_WakeupReason.Bits.FromDoze = TRUE;
//  382          #endif
//  383           
//  384          if(CRM_STATUS.extWuEvt)
//  385          {
//  386           PWRLib_MCU_WakeupReason.Bits.FromKBI = TRUE;
//  387          } 
//  388          
//  389          Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;         
//  390          
//  391          PWR_RunAgain();         
//  392          
//  393       #else 
//  394         #error "*** ERROR: gKeyBoardSupported_d has to be set to 1"
//  395       #endif
//  396     /*---------------------------------------------------------------------------*/
//  397     #elif ((cPWR_DeepSleepMode == 2) || (cPWR_DeepSleepMode == 6))
//  398        #if (gKeyBoardSupported_d == TRUE)
//  399           /* Disable the Keyboard wake-up in crm */
//  400           CRM_WU_CNTL.extWuEn = 0;
//  401        #endif     
//  402        
//  403        /* Disable the other wake-up sources */
//  404        CRM_WU_CNTL.rtcWuEn = 0;   
//  405        
//  406        /* setup the Wake-up Timer */
//  407        { 
//  408         crmWuCtrl_t    wuCtrl;
//  409         wuCtrl.wuSource = gTimerWu_c;
//  410         wuCtrl.TIMER_WU_EN  = 1;
//  411         wuCtrl.TIMER_WU_INT_EN = 0;
//  412         wuCtrl.TIMER_WU_TIMEOUT = cPWR_SleepTimeout;
//  413         CRM_WuCntl(&wuCtrl);
//  414        } 
//  415        
//  416        #if(cPWR_DeepSleepMode == 2)
//  417         PWR_MCUHibernate();
//  418         PWRLib_MCU_WakeupReason.Bits.FromHibernate = TRUE;
//  419        #else
//  420         PWR_MCUDoze();
//  421         PWRLib_MCU_WakeupReason.Bits.FromDoze = TRUE;
//  422        #endif       
//  423        
//  424        if( (CRM_STATUS.extWuEvt == 0) && (CRM_STATUS.rtcWuEvt == 0))
//  425        {
//  426          PWRLib_MCU_WakeupReason.Bits.FromTimer = TRUE;
//  427        }
//  428           
//  429        #if (gKeyBoardSupported_d == TRUE)   
//  430           /* restore the Keyboard configuration */
//  431           CRM_WU_CNTL.extWuEn = gKbiWuEN_c;
//  432        #endif                    
//  433 
//  434        Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
//  435 
//  436        PWR_RunAgain();
//  437        if(PWRLib_MCU_WakeupReason.Bits.FromTimer == TRUE)
//  438        {  
//  439         cPWR_DeepSleepWakeupStackProc;          /* User function called only on timeout */
//  440        } 
//  441 
//  442     /*---------------------------------------------------------------------------*/
//  443     #elif ((cPWR_DeepSleepMode==3) || (cPWR_DeepSleepMode==7))
//  444        #if (gKeyBoardSupported_d == TRUE)                 
//  445         /* Disable the other wake-up sources */
//  446         CRM_WU_CNTL.rtcWuEn = 0;   
        LDR      R0,??DataTable14  ;; 0x80003004
        LDR      R0,[R0, #+0]
        MOVS     R1,#+2
        BICS     R0,R0,R1
        LDR      R1,??DataTable14  ;; 0x80003004
        STR      R0,[R1, #+0]
//  447         
//  448         /* setup the Wake-up Timer */
//  449         { 
//  450          crmWuCtrl_t    wuCtrl;
//  451          wuCtrl.wuSource = gTimerWu_c;
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+4]
//  452          wuCtrl.TIMER_WU_EN = 1;
        LDR      R0,[SP, #+8]
        MOVS     R1,#+1
        ORRS     R1,R1,R0
        STR      R1,[SP, #+8]
//  453          wuCtrl.TIMER_WU_INT_EN = 0;
        LDR      R0,[SP, #+8]
        MOVS     R1,#+2
        BICS     R0,R0,R1
        STR      R0,[SP, #+8]
//  454          wuCtrl.TIMER_WU_TIMEOUT = cPWR_SleepTimeout;
        LDR      R0,??DataTable16_1  ;; 0x1c9c38
        STR      R0,[SP, #+12]
//  455          CRM_WuCntl(&wuCtrl);
        ADD      R0,SP,#+4
        BL       CRM_WuCntl
//  456         } 
//  457         
//  458         #if (cPWR_DeepSleepMode==3)
//  459           PWR_MCUHibernate();
//  460           PWRLib_MCU_WakeupReason.Bits.FromHibernate = TRUE;
//  461         #else
//  462           PWR_MCUDoze();
        MOVS     R0,#+1
        BL       PWR_MCUSleep
//  463           PWRLib_MCU_WakeupReason.Bits.FromDoze = TRUE;
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+2
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
//  464         #endif          
//  465           
//  466         if( (CRM_STATUS.extWuEvt == 0) && (CRM_STATUS.rtcWuEvt == 0))
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+4
        LSLS     R0,R0,#+28
        BNE      ??PWR_HandleDeepSleep_0
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        LSLS     R0,R0,#+28
        BMI      ??PWR_HandleDeepSleep_0
//  467         {
//  468          PWRLib_MCU_WakeupReason.Bits.FromTimer = TRUE;
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+32
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
        B        ??PWR_HandleDeepSleep_1
//  469         }
//  470         else
//  471         {
//  472          if(CRM_STATUS.extWuEvt)
??PWR_HandleDeepSleep_0:
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        LSRS     R0,R0,#+4
        LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
        LSRS     R0,R0,#+28
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+0
        BEQ      ??PWR_HandleDeepSleep_1
//  473          {
//  474           PWRLib_MCU_WakeupReason.Bits.FromKBI = TRUE;
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+16
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
//  475          }
//  476         }
//  477 
//  478         Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
??PWR_HandleDeepSleep_1:
        MOV      R0,SP
        LDR      R1,??DataTable16_2
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+0]
//  479 
//  480         PWR_RunAgain();
        BL       PWR_RunAgain
//  481         if(PWRLib_MCU_WakeupReason.Bits.FromTimer == TRUE)
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+31
        LSRS     R1,R1,#+31
        CMP      R1,#+0
        BEQ      ??PWR_HandleDeepSleep_2
//  482         {  
//  483          cPWR_DeepSleepWakeupStackProc;          /* User function called only on timeout */
        BL       DeepSleepWakeupStackProc
//  484         } 
//  485        #else 
//  486         #error "*** ERROR: gKeyBoardSupported_d has to be set to 1"
//  487        #endif
//  488         
//  489    /*---------------------------------------------------------------------------*/
//  490    #elif (cPWR_DeepSleepMode==8)
//  491      #if (gKeyBoardSupported_d == TRUE)                 
//  492         /* Disable the other wake-up sources */
//  493         CRM_WU_CNTL.rtcWuEn = 0;   
//  494         
//  495         /* setup the Wake-up Timer */
//  496         { 
//  497          crmWuCtrl_t    wuCtrl;
//  498          wuCtrl.wuSource = gTimerWu_c;
//  499          wuCtrl.TIMER_WU_EN = 1;
//  500          wuCtrl.TIMER_WU_INT_EN = 0;
//  501          wuCtrl.TIMER_WU_TIMEOUT = cPWR_MACSymbols2WakeUpTimerTicks(mPWR_SleepTimeoutSym);
//  502          CRM_WuCntl(&wuCtrl);
//  503         } 
//  504         
//  505         PWR_MCUDoze();
//  506         PWRLib_MCU_WakeupReason.Bits.FromDoze = TRUE;
//  507         
//  508         if( (CRM_STATUS.extWuEvt == 0) && (CRM_STATUS.rtcWuEvt == 0))
//  509         {
//  510          PWRLib_MCU_WakeupReason.Bits.FromTimer = TRUE;
//  511         }
//  512         else
//  513         {
//  514          if(CRM_STATUS.extWuEvt)
//  515          {
//  516           PWRLib_MCU_WakeupReason.Bits.FromKBI = TRUE;
//  517          }
//  518         }
//  519 
//  520         Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
//  521 
//  522         PWR_RunAgain();
//  523         if(PWRLib_MCU_WakeupReason.Bits.FromTimer == TRUE)
//  524         {  
//  525          cPWR_DeepSleepWakeupStackProc;          /* User function called only on timeout */
//  526         } 
//  527        #else 
//  528         #error "*** ERROR: gKeyBoardSupported_d has to be set to 1"
//  529        #endif
//  530    //---------------------------------------------------------------------------
//  531    #elif (cPWR_DeepSleepMode==4)       
//  532         PWR_AllOff();
//  533 
//  534     //---------------------------------------------------------------------------    
//  535     #else
//  536       #error "*** ERROR: Not a valid cPWR_DeepSleepMode chosen"
//  537     #endif
//  538         
//  539     PWRLib_MCU_WakeupReason.AllBits = 0;
??PWR_HandleDeepSleep_2:
        LDR      R0,??DataTable16_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  540     return Res;
        LDR      R0,[SP, #+0]
        ADD      SP,SP,#+16
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  541     
//  542   #else  /* #if (cPWR_UsePowerDownMode) else */
//  543     PWRLib_MCU_WakeupReason.AllBits = 0;
//  544     return Res;          /*(PWRLib_WakeupReason_t) DozeDuration;*/
//  545   #endif  /* #if (cPWR_UsePowerDownMode) end*/
//  546 }  /* PWR_HandleDeepSleep =====================================================*/
//  547 
//  548 
//  549 /*****************************************************************************/
//  550 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  551 PWRLib_WakeupReason_t  PWR_HandleSleep( zbClock24_t DozeDuration) {
PWR_HandleSleep:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  552   PWRLib_WakeupReason_t   Res;
//  553 
//  554   Res.AllBits = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  555   #if (cPWR_UsePowerDownMode)
//  556     /*---------------------------------------------------------------------------*/
//  557     #if (cPWR_SleepMode==0)
//  558       Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
//  559       PWRLib_MCU_WakeupReason.AllBits = 0;
//  560 
//  561     /*---------------------------------------------------------------------------*/
//  562     #elif (cPWR_SleepMode==1)
//  563         PWR_MCUWait();
        BL       PWR_MCUWait
//  564         PWRLib_MCU_WakeupReason.Bits.FromWait = TRUE;
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+4
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
//  565         
//  566         Res.AllBits = PWRLib_MCU_WakeupReason.AllBits;
        MOV      R0,SP
        LDR      R1,??DataTable16_2
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+0]
//  567     /*---------------------------------------------------------------------------*/
//  568     #else
//  569       #error "*** ERROR: Not a valid cPWR_SleepMode chosen"
//  570     #endif
//  571         
//  572     PWRLib_MCU_WakeupReason.AllBits = 0;
        LDR      R0,??DataTable16_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  573     return Res; 
        LDR      R0,[SP, #+0]
        POP      {R1,R2,R4}
        POP      {R3}
        BX       R3               ;; return
//  574     
//  575   #else  /* #if (cPWR_UsePowerDownMode) else */
//  576     return Res;
//  577   #endif  /* #if (cPWR_UsePowerDownMode) end */
//  578 }  /* PWR_HandleSleep =========================================================*/

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable12:
        DC32     mExtOutPol

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable12_1:
        DC32     mLPMFlag

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable12_2:
        DC32     0x80003050

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable12_3:
        DC32     mSavedMacaClk
//  579 
//  580 
//  581 /************************************************************************************
//  582 *************************************************************************************
//  583 * Very Public functions, recommended for general use
//  584 *************************************************************************************
//  585 ************************************************************************************/
//  586 
//  587 /*****************************************************************************/
//  588 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  589 PWRLib_WakeupReason_t PWR_CheckForAndEnterNewPowerState(PWR_CheckForAndEnterNewPowerState_t NewPowerState, zbClock24_t DozeDuration) {
PWR_CheckForAndEnterNewPowerState:
        PUSH     {R3-R5,LR}
        MOVS     R5,R0
        MOVS     R4,R1
//  590   PWRLib_WakeupReason_t    ReturnValue;
//  591   ReturnValue.AllBits = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  592 
//  593   #if (cPWR_UsePowerDownMode)
//  594 
//  595     if ( NewPowerState == PWR_Run) {
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+77
        BEQ      ??PWR_CheckForAndEnterNewPowerState_0
//  596       /* ReturnValue = 0; */
//  597     }
//  598     else if ( NewPowerState == PWR_OFF) {      
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+81
        BNE      ??PWR_CheckForAndEnterNewPowerState_1
//  599       while (1) 
//  600       {
//  601         PWR_AllOff();
??PWR_CheckForAndEnterNewPowerState_2:
        BL       PWR_AllOff
        B        ??PWR_CheckForAndEnterNewPowerState_2
//  602       }    /* Never returns */
//  603     }
//  604     else if ( NewPowerState == PWR_Reset) {
??PWR_CheckForAndEnterNewPowerState_1:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+80
        BNE      ??PWR_CheckForAndEnterNewPowerState_3
//  605       PWRLib_Reset();                      /* Never returns	 */
        BL       PWRLib_Reset
        B        ??PWR_CheckForAndEnterNewPowerState_0
//  606     }
//  607      
//  608     else if (( NewPowerState == PWR_DeepSleep) && PWR_DeepSleepAllowed()) {
??PWR_CheckForAndEnterNewPowerState_3:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+79
        BNE      ??PWR_CheckForAndEnterNewPowerState_4
        BL       PWR_DeepSleepAllowed
        CMP      R0,#+0
        BEQ      ??PWR_CheckForAndEnterNewPowerState_4
//  609       ReturnValue = PWR_HandleDeepSleep( DozeDuration);
        MOVS     R0,R4
        BL       PWR_HandleDeepSleep
        STR      R0,[SP, #+0]
        B        ??PWR_CheckForAndEnterNewPowerState_0
//  610     } 
//  611     else if (( NewPowerState == PWR_Sleep) && PWR_SleepAllowed()) {
??PWR_CheckForAndEnterNewPowerState_4:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+78
        BNE      ??PWR_CheckForAndEnterNewPowerState_0
        BL       PWR_SleepAllowed
        CMP      R0,#+0
        BEQ      ??PWR_CheckForAndEnterNewPowerState_0
//  612       ReturnValue = PWR_HandleSleep( DozeDuration);
        MOVS     R0,R4
        BL       PWR_HandleSleep
        STR      R0,[SP, #+0]
//  613     }
//  614     else {
//  615       /* ReturnValue = FALSE; */
//  616     }
//  617 
//  618     PWRLib_MCU_WakeupReason.AllBits = 0;                     /* Clear wakeup reason */
??PWR_CheckForAndEnterNewPowerState_0:
        LDR      R0,??DataTable16_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  619   #else
//  620     ReturnValue.AllBits = 0xff | (NewPowerState > 0) | (DozeDuration > 0); 
//  621                               /* To remove warning for variabels in functioncall */
//  622   #endif  /* #if (cPWR_UsePowerDownMode) */
//  623 
//  624   return ReturnValue;
        LDR      R0,[SP, #+0]
        POP      {R1,R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  625 }   /* PWR_CheckForAndEnterNewPowerState ============================================*/

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     0x87651234

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_1:
        DC32     0x80004048

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_2:
        DC32     PWR_CallBeforeSleep
//  626 
//  627 /*****************************************************************************/
//  628 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  629 PWRLib_LVD_VoltageLevel_t   PWRLib_LVD_ReportLevel(void) {
//  630  
//  631   /* TO DO: add code for sampling battery */
//  632   /* the function should return one of the following power levels: 
//  633   PWR_NODEPOWER_LEVEL_100 
//  634   PWR_NODEPOWER_LEVEL_66
//  635   PWR_NODEPOWER_LEVEL_50
//  636   PWR_NODEPOWER_LEVEL_33
//  637   PWR_NODEPOWER_LEVEL_CRITICAL
//  638   */
//  639 
//  640   return PWR_NODEPOWER_LEVEL_100;
PWRLib_LVD_ReportLevel:
        MOVS     R0,#+12
        BX       LR               ;; return
//  641 }  /* PWRLib_LVD_ReportLevel ================================================*/
//  642 
//  643 /*****************************************************************************/
//  644 /* Please see in PWR_Interface.h for description                             */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  645 void PWR_CheckForAndEnterNewPowerState_Init(void) {
PWR_CheckForAndEnterNewPowerState_Init:
        PUSH     {LR}
//  646 #if (cPWR_UsePowerDownMode)
//  647  mMCU_SetStatus( MCU_Running);
//  648  mRADIO_SetStatus(RADIO_Idle);
//  649  PWRLib_SetCurrentZigbeeStackPowerState( StackPS_DeepSleep);
        LDR      R0,??DataTable15_3
        MOVS     R1,#+124
        STRB     R1,[R0, #+0]
//  650  
//  651  PWRLib_MCU_WakeupReason.AllBits = 0;
        LDR      R0,??DataTable16_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  652  if(CRM_STATUS.hibWuEvt == 1)
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
        LSRS     R1,R1,#+31
        CMP      R1,#+0
        BEQ      ??PWR_CheckForAndEnterNewPowerState_Init_0
//  653  {
//  654   PWRLib_MCU_WakeupReason.Bits.FromHibernate = TRUE;  
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+1
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
        B        ??PWR_CheckForAndEnterNewPowerState_Init_1
//  655  }
//  656  else
//  657  {
//  658   if(CRM_STATUS.dozeWuEvt == 1)
??PWR_CheckForAndEnterNewPowerState_Init_0:
        LDR      R0,??DataTable14_1  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
        LSRS     R1,R1,#+31
        CMP      R1,#+0
        BEQ      ??PWR_CheckForAndEnterNewPowerState_Init_2
//  659   {
//  660    PWRLib_MCU_WakeupReason.Bits.FromDoze = TRUE;  
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+2
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
        B        ??PWR_CheckForAndEnterNewPowerState_Init_1
//  661   }
//  662   else
//  663   {
//  664    PWRLib_MCU_WakeupReason.Bits.FromReset = TRUE;  
??PWR_CheckForAndEnterNewPowerState_Init_2:
        LDR      R0,??DataTable16_2
        LDR      R0,[R0, #+0]
        MOVS     R1,#+8
        ORRS     R1,R1,R0
        LDR      R0,??DataTable16_2
        STR      R1,[R0, #+0]
//  665   }
//  666  }
//  667 #endif  /* #if (cPWR_UsePowerDownMode) */
//  668 }   /* PWR_CheckForAndEnterNewPowerState_Init ==================================*/
??PWR_CheckForAndEnterNewPowerState_Init_1:
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14:
        DC32     0x80003004

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_1:
        DC32     0x80003018

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_2:
        DC32     gHardwareParameters

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_3:
        DC32     0x80003048

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_4:
        DC32     0xf78

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_5:
        DC32     0x80009000

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_6:
        DC32     0xc0050300

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable14_7:
        DC32     0x80003020
//  669 
//  670 
//  671 /********************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  672 PWRLib_WakeupReason_t PWR_EnterLowPower(void)
//  673 {
PWR_EnterLowPower:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
//  674   PWRLib_WakeupReason_t ReturnValue;  
//  675   bool_t interruptsEnabled = FALSE;
        MOVS     R0,#+0
        MOVS     R4,R0
//  676 
//  677   ReturnValue.AllBits = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  678   
//  679 #if (cPWR_UsePowerDownMode)  
//  680  /* if Low Power Capability is enabled*/
//  681  #if (gTMR_EnableLowPowerTimers_d)  
//  682    if (TMR_AreAllTimersOff())  /*No timer running*/
        BL       TMR_AreAllTimersOff
        CMP      R0,#+0
        BEQ      ??PWR_EnterLowPower_0
//  683    {
//  684     /* if more low power timers are running, stop the hardware timer
//  685      * and save the spend time in millisecond that wasn't counted.
//  686      */
//  687     notCountedTmrTicksBeforeSleep = TMR_NotCountedTicksBeforeSleep();
        BL       TMR_NotCountedTicksBeforeSleep
        LDR      R1,??DataTable15_2
        STRH     R0,[R1, #+0]
//  688   }
//  689  #endif /* #if (gTMR_EnableLowPowerTimers_d)  */
//  690   
//  691  /* Low Voltage check ... not currently supported */
//  692   
//  693   IntDisableAll();
??PWR_EnterLowPower_0:
        BL       IntDisableAll
//  694   if (TS_PendingEvents() == FALSE)
        BL       TS_PendingEvents
        CMP      R0,#+0
        BNE      ??PWR_EnterLowPower_1
//  695   {		 
//  696     PWRLib_SetCurrentZigbeeStackPowerState(StackPS_DeepSleep);
        LDR      R0,??DataTable16
        MOVS     R1,#+124
        STRB     R1,[R0, #+0]
//  697     if (TMR_AreAllTimersOff())  /*No timer running*/
        BL       TMR_AreAllTimersOff
        CMP      R0,#+0
        BEQ      ??PWR_EnterLowPower_2
//  698     {			
//  699       ReturnValue = PWR_CheckForAndEnterNewPowerState ( PWR_DeepSleep, 0);
        MOVS     R1,#+0
        MOVS     R0,#+79
        BL       PWR_CheckForAndEnterNewPowerState
        STR      R0,[SP, #+0]
        B        ??PWR_EnterLowPower_1
//  700     }else /*timers are running*/
//  701     { 	 
//  702      interruptsEnabled = TRUE;
??PWR_EnterLowPower_2:
        MOVS     R0,#+1
        MOVS     R4,R0
//  703      // Enable the interrupts before entering the Sleep mode. The wake-up from WAIT is possible only if the interrupts are globaly enabled
//  704      IntEnableAll();
        MOVS     R0,#+0
        BL       IntRestoreAll
//  705      ReturnValue = PWR_CheckForAndEnterNewPowerState ( PWR_Sleep, 0);
        MOVS     R1,#+0
        MOVS     R0,#+78
        BL       PWR_CheckForAndEnterNewPowerState
        STR      R0,[SP, #+0]
//  706     }
//  707   } /* enable irq's if there is pending evens */
//  708   if(interruptsEnabled == FALSE)
??PWR_EnterLowPower_1:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+0
        BNE      ??PWR_EnterLowPower_3
//  709   {
//  710    IntEnableAll();  
        MOVS     R0,#+0
        BL       IntRestoreAll
//  711   } 
//  712 #endif  
//  713   
//  714   return ReturnValue;
??PWR_EnterLowPower_3:
        LDR      R0,[SP, #+0]
        POP      {R1,R2,R4}
        POP      {R3}
        BX       R3               ;; return
//  715 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable15:
        DC32     0x80003000

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable15_1:
        DC32     0x80003044

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable15_2:
        DC32     notCountedTmrTicksBeforeSleep

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable15_3:
        DC32     PWRLib_StackPS
//  716 
//  717 /* Please see in PWR_Interface.h for description                                          */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  718 void PWR_SetDozeTimeSymbols(uint32_t dozeTimeSym)
//  719 {
//  720 #if ((cPWR_UsePowerDownMode) && (cPWR_DeepSleepMode == 8))
//  721   if(dozeTimeSym)
//  722   {
//  723    mPWR_SleepTimeoutSym = dozeTimeSym;
//  724   } 
//  725 #else
//  726  (void)dozeTimeSym;
//  727 #endif 
//  728 }
PWR_SetDozeTimeSymbols:
        BX       LR               ;; return
//  729 
//  730 /******************************************************************************
//  731 *******************************************************************************
//  732 * Private functions
//  733 *******************************************************************************
//  734 ******************************************************************************/
//  735 #if (cPWR_UsePowerDownMode) 
//  736 #if (cPWR_UpdateMACAClockAtWakeUp)

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  737 static void PWR_MacaTimerUpdate(void)
//  738 {
PWR_MacaTimerUpdate:
        PUSH     {R4,LR}
//  739 
//  740  if(CRM_STATUS.hibWuEvt)
        LDR      R0,??DataTable16_3  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
        LSRS     R1,R1,#+31
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??PWR_MacaTimerUpdate_0
//  741  {
//  742    if(CRM_SYS_CNTL.xtal32Exists)
        LDR      R0,??DataTable16_4  ;; 0x80003000
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+31
        LSRS     R1,R1,#+31
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??PWR_MacaTimerUpdate_1
//  743    {
//  744     mPWR_MacaClk = mSavedMacaClk + (uint32_t)(CRM_REGS_P->WuCount * mMACA_TIMER_UPDATE_FACTOR_HIB_32K);
        LDR      R0,??DataTable16_5
        LDR      R4,[R0, #+0]
        LDR      R0,??DataTable16_6  ;; 0x80003020
        LDR      R0,[R0, #+0]
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR      R3,??DataTable16_7  ;; 0x401f4000
        BL       __aeabi_dmul
        BL       __aeabi_d2uiz
        ADDS     R0,R4,R0
        LDR      R1,??DataTable16_8  ;; 0x80004048
        STR      R0,[R1, #+0]
        B        ??PWR_MacaTimerUpdate_2
//  745    }
//  746    else
//  747    {
//  748     mPWR_MacaClk = mSavedMacaClk + CRM_REGS_P->WuCount * mMACA_TIMER_UPDATE_FACTOR_HIB_2K;
??PWR_MacaTimerUpdate_1:
        LDR      R0,??DataTable16_5
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable16_6  ;; 0x80003020
        LDR      R1,[R1, #+0]
        MOVS     R2,#+125
        MULS     R1,R2,R1
        ADDS     R0,R0,R1
        LDR      R1,??DataTable16_8  ;; 0x80004048
        STR      R0,[R1, #+0]
        B        ??PWR_MacaTimerUpdate_2
//  749    }
//  750  }
//  751  else
//  752  { 
//  753    if(CRM_STATUS.dozeWuEvt)
??PWR_MacaTimerUpdate_0:
        LDR      R0,??DataTable16_3  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
        LSRS     R1,R1,#+31
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??PWR_MacaTimerUpdate_2
//  754    {
//  755     mPWR_MacaClk = mSavedMacaClk + (uint32_t)(CRM_REGS_P->WuCount * mMACA_TIMER_UPDATE_FACTOR_DOZE);
        LDR      R0,??DataTable16_5
        LDR      R4,[R0, #+0]
        LDR      R0,??DataTable16_6  ;; 0x80003020
        LDR      R0,[R0, #+0]
        BL       __aeabi_ui2d
        ADR      R2,??DataTable16_9
        LDM      R2,{R2,R3}
        BL       __aeabi_dmul
        BL       __aeabi_d2uiz
        ADDS     R0,R4,R0
        LDR      R1,??DataTable16_8  ;; 0x80004048
        STR      R0,[R1, #+0]
//  756    }
//  757  }  
//  758 
//  759 }
??PWR_MacaTimerUpdate_2:
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16:
        DC32     PWRLib_StackPS

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_1:
        DC32     0x1c9c38

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_2:
        DC32     PWRLib_MCU_WakeupReason

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_3:
        DC32     0x80003018

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_4:
        DC32     0x80003000

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_5:
        DC32     mSavedMacaClk

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_6:
        DC32     0x80003020

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_7:
        DC32     0x401f4000

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_8:
        DC32     0x80004048

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable16_9:
        DC32     0x55555555,0x4094D555

        END
//  760 #endif /* cPWR_UpdateMACAClockAtWakeUp */
//  761 #endif /* cPWR_UsePowerDownMode */
//  762 
//  763 /******************************************************************************
//  764 *******************************************************************************
//  765 * Private Debug stuff
//  766 *******************************************************************************
//  767 ******************************************************************************/
// 
//    13 bytes in section .bss
// 1 294 bytes in section .text
// 
// 1 294 bytes of CODE memory
//    13 bytes of DATA memory
//
//Errors: none
//Warnings: none
