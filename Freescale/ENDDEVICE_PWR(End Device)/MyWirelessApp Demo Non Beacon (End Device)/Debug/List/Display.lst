###############################################################################
#                                                                             #
#                                                       23/Nov/2015  18:36:48 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\SW_2015\ #
#                    Copy of MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Display\Display.c                     #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\SW_2015 #
#                    \Copy of MyWirelessApp Demo Non Beacon (End              #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Display\Display.c" -D                 #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\SW_2015 #
#                    \Copy of MyWirelessApp Demo Non Beacon (End              #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\" -lC "C:\Documents and               #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\" -lB "C:\Documents and               #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\SW_2015 #
#                    \Copy of MyWirelessApp Demo Non Beacon (End              #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MacPhy\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Init\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Interface\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Configure\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\UartUtil\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Source\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\TS\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\TS\Source\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and         #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\ZTC\Source\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Interface\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\LibInterface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Display\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Keyboard\" -I "C:\Documents and       #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\NVM\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\TMR\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\SW_2015\Copy of           #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR       #
#                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"      #
#                    --interwork --cpu_mode thumb -On                         #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\SW_2015\ #
#                    Copy of MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\Display.lst                           #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\SW_2015\ #
#                    Copy of MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\Obj\Display.o                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\SW_2015\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\PLM\Source\Display\Display.c
      1          /************************************************************************************
      2          * This is the source file for Display Driver.
      3          *
      4          *
      5          * (c) Copyright 2008, Freescale, Inc.  All rights reserved.
      6          *
      7          *
      8          * No part of this document must be reproduced in any form - including copied,
      9          * transcribed, printed or by any electronic means - without specific written
     10          * permission from Freescale Semiconductor.
     11          ************************************************************************************/
     12          
     13          #include "EmbeddedTypes.h"
     14          #include "Display.h"
     15          #include "LCD_Font.h"
     16          #include "TS_Interface.h"
     17          #include "GPIO_Interface.h"
     18          #include "Delay.h"
     19          #include "FunctionLib.h"
     20          
     21          
     22          #ifndef gZtcIncluded_d
     23          #define gZtcIncluded_d FALSE
     24          #endif
     25          
     26          #ifndef gMacStandAlone_d
     27          #define gMacStandAlone_d FALSE
     28          #endif
     29          
     30          #ifndef gBeeStackIncluded_d
     31          #define gBeeStackIncluded_d FALSE
     32          #endif
     33          
     34          #ifndef ECNetIncluded_d
     35          #define ECNetIncluded_d FALSE
     36          #endif
     37          
     38          #ifndef SynkroIncluded_d
     39          #define SynkroIncluded_d FALSE
     40          #endif
     41          
     42          #ifndef gRF4CEIncluded_d
     43          #define gRF4CEIncluded_d FALSE
     44          #endif 
     45          
     46          #if gMacStandAlone_d
     47          #include "Mac_Globals.h"
     48          #endif
     49          
     50          #if gBeeStackIncluded_d
     51          #include "beestack_globals.h"
     52          #endif
     53          
     54          #if ECNetIncluded_d
     55          #include "ECNet_Globals.h"
     56          #endif
     57          
     58          #if SynkroIncluded_d
     59          #include "NwkGlobals.h"
     60          #endif
     61          
     62          #if gRF4CEIncluded_d
     63          #include "NwkGlobals.h"
     64          #endif 
     65          
     66          #if gZtcIncluded_d
     67          #include "ZtcInterface.h"
     68          #endif
     69          
     70          
     71          
     72          #if (gLCDSupported_d == 1)
     73          
     74          /************************************************************************************
     75          *************************************************************************************
     76          * Private macros
     77          *************************************************************************************
     78          ************************************************************************************/
     79          
     80          #define gLcdBackLightEnabled_d TRUE
     81          
     82          /* pin defines */
     83          
     84          /* D0  = SPI_SS    (GPIO  4) , PORT LO */
     85          /* D1  = SPI_MISO  (GPIO  5) , PORT LO */
     86          /* D2  = SPI_MOSI  (GPIO  6) , PORT LO */
     87          /* D3  = SPI_SCK   (GPIO  7) , PORT LO */
     88          /* D4  = ADC2      (GPIO  32), PORT HI */
     89          /* D5  = ADC3      (GPIO  33), PORT HI */
     90          /* D6  = ADC4      (GPIO  34), PORT HI */
     91          /* D7  = ADC5      (GPIO  35), PORT HI */
     92          #define LCD_D0  gGpioPin4_c
     93          #define LCD_D1  gGpioPin5_c
     94          #define LCD_D2  gGpioPin6_c
     95          #define LCD_D3  gGpioPin7_c
     96          #define LCD_D4  gGpioPin32_c
     97          #define LCD_D5  gGpioPin33_c
     98          #define LCD_D6  gGpioPin34_c
     99          #define LCD_D7  gGpioPin35_c
    100          
    101          #define LCD_DATA_LO_MASK  0x000000F0
    102          #define LCD_DATA_LO_PORT  gGpioPort0_c
    103          #define LCD_DATA_LO_WRITE(x) (x)<<4
    104          #define LCD_DATA_LO_READ(x)  (x)>>4
    105          
    106          #define LCD_DATA_HI_MASK  0x0000000F
    107          #define LCD_DATA_HI_PORT  gGpioPort1_c
    108          #define LCD_DATA_HI_WRITE(x) (x)>>4
    109          #define LCD_DATA_HI_READ(x)  (x)<<4
    110          
    111          /* A0     = UART2_RTS (GPIO  21)   inverted, 0-data, 1-command */
    112          /* RD     = TMR0      (GPIO  8)    double inverted, active high */
    113          /* WR     = TMR1      (GPIO  9)    double inverted, active high */
    114          /* CS     = UART2_CTS (GPIO  20)   double inverted, active high */
    115          /* BL_PWM = TMR2      (GPIO  10)   1 - light, 0 - dark or PWM variable duty cycle */
    116          /* RST    = RX_ON     (GPIO  45)   active low */
    117          /* RST    = UART2_RX  (GPIO  19)   active low */
    118          #define LCD_A0          gGpioPin21_c
    119          #define LCD_RD          gGpioPin8_c
    120          #define LCD_WR          gGpioPin9_c
    121          #define LCD_CS          gGpioPin20_c
    122          #define LCD_BL_PWM      gGpioPin10_c
    123          #define LCD_RSTN        gGpioPin45_c
    124          #define LCD_RSTN_debug  gGpioPin19_c
    125          
    126          
    127          /* pin states */
    128          #define LCD_A0_COMMAND  gGpioPinStateHigh_c
    129          #define LCD_A0_DATA     gGpioPinStateLow_c
    130          #define LCD_CS_ACTIVE   gGpioPinStateHigh_c
    131          #define LCD_CS_INACTIVE gGpioPinStateLow_c
    132          #define LCD_WR_ACTIVE   gGpioPinStateHigh_c
    133          #define LCD_WR_INACTIVE gGpioPinStateLow_c
    134          #define LCD_RD_ACTIVE   gGpioPinStateHigh_c
    135          #define LCD_RD_INACTIVE gGpioPinStateLow_c
    136          #define LCD_BL_ON       gGpioPinStateHigh_c
    137          #define LCD_BL_OFF      gGpioPinStateLow_c
    138          #define LCD_RSTN_IDLE   gGpioPinStateHigh_c
    139          #define LCD_RSTN_RESET  gGpioPinStateLow_c
    140          
    141          #define ON                      1
    142          #define OFF                     0
    143          
    144          #define mFontOffset_c          32
    145          
    146          /* number of columns to be cleared in LCD_Task */
    147          #define mMaxDeleteColumns_c    32
    148          #define mMaxLineNumber_c        8
    149          #define mMaxQueueEntries_c     45
    150          #define mEmptyQueue_c          0xFF
    151          
    152          /* number of characters to be displayed in LCD_Task */
    153          #define mNumberOfCharToWrite_c  3
    154          
    155          /* symbol width in pixels */
    156          #define mSymbolWidth            8
    157          
    158          /************************************************************************************
    159          *************************************************************************************
    160          * Private type definitions
    161          *************************************************************************************
    162          ************************************************************************************/
    163          /* #pragma pack(1) */
    164          
    165          typedef struct displayParams_tag{
    166            uint8_t currentXCoord;
    167            uint8_t currentYCoord;
    168            uint8_t currentLine;
    169            /* Bitmask: 
    170            *       line i is cleared, bit i from writtenLines is 0
    171            *       line i is written, bit i from writtenLines is 1 
    172            */
    173            uint8_t writtenLines;
    174            /* Bitmask: 
    175            *       line i will not be written, bit i from linesToWrite is 0
    176            *       line i will be written, bit i from linesToWrite is 1 
    177            */
    178            uint8_t linesToWrite;  
    179            uint8_t linesWidthWritten[mMaxLineNumber_c];
    180            uint8_t currentFontType;
    181            uint8_t currentStringIndex;
    182            uint8_t currentString[mMaxLineNumber_c][gMAX_LCD_CHARS_c];
    183            uint8_t currentBitmap[mMaxLineNumber_c][gMAX_LCD_CHARS_c];  
    184          }displayParams_t;
    185          
    186          typedef struct lineParams_tag{
    187            uint8_t xCoord;
    188            uint8_t yCoord;
    189            uint8_t page;  
    190          }lineParams_t;
    191          
    192          typedef struct pageParams_tag{
    193            uint8_t xStartCoord;
    194            uint8_t xEndCoord;
    195            uint8_t yCoord;
    196            uint8_t line;
    197          }pageParams_t;
    198          
    199          typedef enum operation_tag{
    200            gLCD_WriteOp_c = 0,
    201            gLCD_ClearDisplayOp_c,
    202            gLCD_ClearLineOp_c,
    203            gLCD_WriteBitmapOp_c,  
    204            gLCD_MaxOp_c = 0xFF
    205          }operation_t;
    206          
    207          typedef struct opLine_tag{
    208            operation_t opQueue;
    209            uint8_t lineQueue;  
    210          }opLine_t;
    211          
    212          typedef struct queue_tag{
    213            uint8_t head;
    214            uint8_t tail;
    215            opLine_t opLine[mMaxQueueEntries_c];
    216          }queue_t;
    217          
    218          /* #pragma pack() */
    219          
    220          /************************************************************************************
    221          *************************************************************************************
    222          * Private prototypes
    223          *************************************************************************************
    224          ************************************************************************************/
    225          
    226          void LCD_Task(event_t events);
    227          void LCD_TaskInit(void);
    228          void LCD_SetBacklight(uint8_t brightnessValue);
    229          void LCD_WritePixel(uint8_t xStartCoord, uint8_t yStartCoord, bool_t mode);
    230          void LCD_WriteCharacter(uint8_t symbol, uint8_t xCoord, uint8_t yCoord);
    231          void LCD_WriteSymbol(uint8_t index, uint8_t xCoord, uint8_t yCoord, uint8_t* bitmap);
    232          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord);
    233          uint8_t LCD_ClearLine(uint8_t line);
    234          
    235          static void ProcessOperation(opLine_t operationAndLine); 
    236          static void SendData(uint8_t data);
    237          static void SetHiZ(void);
    238          static void SetOutput(void);
    239          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord);
    240          static uint8_t ReadData(void);
    241          static uint8_t GetData(void);
    242          static uint8_t GetStrlen(const uint8_t *pString);
    243          
    244          static void     InitQueue(void);
    245          static bool_t   AddToQueue(opLine_t operationLine);
    246          static opLine_t RemoveFromQueue(void);
    247          static bool_t   IsQueueEmpty(void);
    248          static bool_t   IsQueueFull(void);
    249          
    250          /************************************************************************************
    251          *************************************************************************************
    252          * Private memory declarations
    253          *************************************************************************************
    254          ************************************************************************************/
    255          
    256          static displayParams_t mDisplayParams = {
    257            /* currentXCoord */
    258            0x00,
    259            /* currentYCoord */
    260            0x00,
    261            /* currentLine */
    262            0x00,
    263            /* writtenLines */
    264            0xFF,
    265            /* linesToWrite */
    266            0x00,
    267            /* linesWidthWritten */
    268            0x00,
    269            /* currentFontType */
    270            0x00,
    271            /* currentStringIndex */
    272            0x00,  
    273            /* currentString */
    274            0x00,
    275            /* currentBitmap */
    276            0x00
    277          };
    278          
    279          static lineParams_t mLineParams[mMaxLineNumber_c] = {
    280            {0, 0, 0},
    281            {0, 8, 1},
    282            {0, 16, 2},
    283            {0, 24, 3},
    284            {0, 32, 4},
    285            {0, 40, 5},
    286            {0, 48, 6},
    287            {0, 56, 7},
    288          };  
    289          
    290          static bool_t mOperationCompleted = TRUE;
    291          
    292          static queue_t mQueue;
    293          
    294          /* after initialization, all LCD lines must be erased */
    295          static bool_t mIsLcdInitialized = FALSE;
    296          
    297          /* error indicator, used for error reporting */
    298          static volatile lcdError_t mErrorIndicator = gLCD_NoError_c;
    299          
    300          static uint8_t* mReceivedBitmap = NULL;
    301          static uint8_t  mBitmapSpace[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    302          
    303          /******************************************************************************
    304          *******************************************************************************
    305          * Public memory definitions
    306          *******************************************************************************
    307          ******************************************************************************/
    308          
    309          tsTaskID_t gLCDTaskID;
    310          const uint8_t gaHexValue[] = "0123456789ABCDEF";
    311          
    312          const font_t aLCDFont[gLCDNumFonts_c] = 
    313          {
    314            /* character font with fixed width */ 
    315            {gLCDNormalIndex,  gLCDNormalFont,  1},
    316            /* character font with variable width */ 
    317            {gLCDVerdanaIndex, gLCDVerdanaFont, 2}   
    318          };
    319          
    320          /************************************************************************************
    321          *************************************************************************************
    322          * Public functions
    323          *************************************************************************************
    324          ************************************************************************************/
    325          
    326          /******************************************************************************
    327          * This function initializes the display
    328          *
    329          * Interface assumptions:
    330          *
    331          *
    332          * Return value:
    333          * None
    334          *
    335          ******************************************************************************/
    336          void LCD_Init(void)
    337          {
    338          #if ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE))
    339              uint8_t ctr;
    340          #endif /* ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE)) */     
    341          
    342              Gpio_SetPinFunction(LCD_WR, gGpioNormalMode_c);
    343              Gpio_SetPinFunction(LCD_CS, gGpioNormalMode_c);
    344              Gpio_SetPinFunction(LCD_RD, gGpioNormalMode_c);
    345              Gpio_SetPinFunction(LCD_A0, gGpioNormalMode_c);
    346              Gpio_SetPinFunction(LCD_RSTN, gGpioNormalMode_c);
    347              Gpio_SetPinFunction(LCD_RSTN_debug, gGpioNormalMode_c);
    348          
    349              Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
    350              Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
    351              Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
    352              Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
    353              Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
    354              Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
    355          
    356              /* define the LCD pins as output pins */
    357              (void)Gpio_SetPinReadSource(LCD_CS,     gGpioPinReadReg_c);
    358              (void)Gpio_SetPinReadSource(LCD_A0,     gGpioPinReadReg_c);
    359              (void)Gpio_SetPinReadSource(LCD_RD,     gGpioPinReadReg_c);
    360              (void)Gpio_SetPinReadSource(LCD_WR,     gGpioPinReadReg_c);
    361              (void)Gpio_SetPinReadSource(LCD_BL_PWM, gGpioPinReadReg_c);
    362              (void)Gpio_SetPinReadSource(LCD_RSTN,   gGpioPinReadReg_c);
    363              (void)Gpio_SetPinReadSource(LCD_RSTN_debug,   gGpioPinReadReg_c);
    364          
    365              (void)Gpio_SetPinDir(LCD_CS,     gGpioDirOut_c);
    366              (void)Gpio_SetPinDir(LCD_A0,     gGpioDirOut_c);
    367              (void)Gpio_SetPinDir(LCD_RD,     gGpioDirOut_c);
    368              (void)Gpio_SetPinDir(LCD_WR,     gGpioDirOut_c);
    369              (void)Gpio_SetPinDir(LCD_BL_PWM, gGpioDirOut_c);
    370              (void)Gpio_SetPinDir(LCD_RSTN,   gGpioDirOut_c);
    371              (void)Gpio_SetPinDir(LCD_RSTN_debug,   gGpioDirOut_c);
    372          
    373              /* data pins */
    374          #if gLCDGpioPinMode_c
    375              (void)Gpio_SetPinFunction(LCD_D0,      gGpioNormalMode_c);
    376              (void)Gpio_SetPinFunction(LCD_D1,      gGpioNormalMode_c);
    377              (void)Gpio_SetPinFunction(LCD_D2,      gGpioNormalMode_c);
    378              (void)Gpio_SetPinFunction(LCD_D3,      gGpioNormalMode_c);
    379              (void)Gpio_SetPinFunction(LCD_D4,      gGpioNormalMode_c);
    380              (void)Gpio_SetPinFunction(LCD_D5,      gGpioNormalMode_c);
    381              (void)Gpio_SetPinFunction(LCD_D6,      gGpioNormalMode_c);
    382              (void)Gpio_SetPinFunction(LCD_D7,      gGpioNormalMode_c);
    383          
    384              /* define data pins as inputs */
    385              (void)Gpio_EnPinPullup(LCD_D0,      TRUE);
    386              (void)Gpio_EnPinPullup(LCD_D1,      TRUE);
    387              (void)Gpio_EnPinPullup(LCD_D2,      TRUE);
    388              (void)Gpio_EnPinPullup(LCD_D3,      TRUE);
    389              (void)Gpio_EnPinPullup(LCD_D4,      TRUE);
    390              (void)Gpio_EnPinPullup(LCD_D5,      TRUE);
    391              (void)Gpio_EnPinPullup(LCD_D6,      TRUE);
    392              (void)Gpio_EnPinPullup(LCD_D7,      TRUE);
    393          
    394              (void)Gpio_SelectPinPullup(LCD_D0,      gGpioPinPullup_c);
    395              (void)Gpio_SelectPinPullup(LCD_D1,      gGpioPinPullup_c);
    396              (void)Gpio_SelectPinPullup(LCD_D2,      gGpioPinPullup_c);
    397              (void)Gpio_SelectPinPullup(LCD_D3,      gGpioPinPullup_c);
    398              (void)Gpio_SelectPinPullup(LCD_D4,      gGpioPinPullup_c);
    399              (void)Gpio_SelectPinPullup(LCD_D5,      gGpioPinPullup_c);
    400              (void)Gpio_SelectPinPullup(LCD_D6,      gGpioPinPullup_c);
    401              (void)Gpio_SelectPinPullup(LCD_D7,      gGpioPinPullup_c);
    402          
    403              (void)Gpio_EnPinPuKeeper(LCD_D0,      TRUE);
    404              (void)Gpio_EnPinPuKeeper(LCD_D1,      TRUE);
    405              (void)Gpio_EnPinPuKeeper(LCD_D2,      TRUE);
    406              (void)Gpio_EnPinPuKeeper(LCD_D3,      TRUE);
    407              (void)Gpio_EnPinPuKeeper(LCD_D4,      TRUE);
    408              (void)Gpio_EnPinPuKeeper(LCD_D5,      TRUE);
    409              (void)Gpio_EnPinPuKeeper(LCD_D6,      TRUE);
    410              (void)Gpio_EnPinPuKeeper(LCD_D7,      TRUE);
    411          
    412              (void)Gpio_SetPinReadSource(LCD_D0,      gGpioPinReadPad_c);
    413              (void)Gpio_SetPinReadSource(LCD_D1,      gGpioPinReadPad_c);
    414              (void)Gpio_SetPinReadSource(LCD_D2,      gGpioPinReadPad_c);
    415              (void)Gpio_SetPinReadSource(LCD_D3,      gGpioPinReadPad_c);
    416              (void)Gpio_SetPinReadSource(LCD_D4,      gGpioPinReadPad_c);
    417              (void)Gpio_SetPinReadSource(LCD_D5,      gGpioPinReadPad_c);
    418              (void)Gpio_SetPinReadSource(LCD_D6,      gGpioPinReadPad_c);
    419              (void)Gpio_SetPinReadSource(LCD_D7,      gGpioPinReadPad_c);
    420          
    421              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
    422              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
    423              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
    424              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
    425              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
    426              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
    427              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
    428              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
    429          #else /* gLCDGpioPinMode_c */
    430              Gpio_SetPortFunction(LCD_DATA_LO_PORT, gGpioNormalMode_c, LCD_DATA_LO_MASK);
    431              Gpio_SetPortFunction(LCD_DATA_HI_PORT, gGpioNormalMode_c, LCD_DATA_HI_MASK);
    432          
    433              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpEnAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
    434              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpEnAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
    435          
    436              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpSelAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
    437              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpSelAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
    438          
    439              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
    440              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
    441              
    442              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
    443              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
    444              
    445              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
    446              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
    447          #endif /* gLCDGpioPinMode_c */
    448          
    449          
    450            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_RESET);
    451            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_RESET);
    452            DelayUs(10);
    453            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
    454            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
    455            DelayMs(1);
    456          
    457              /* Turn ON the VDD-VSS power keeping the RES pin = LOW for 0.5us */
    458              /* When power is stabilized, relese the RES pin (RES pin = HIGH) */
    459              
    460              /* Default initialized state: 
    461               - Display off
    462          	   - Normal display (COM0 --> COM63)
    463          	   - ADC select: normal (RAM column address n <-> SEGn)
    464          	   - Power control register: Booster circuit OFF, Voltage regulator circuit OFF, Voltage follower circuit OFF
    465          	   - LCD power supply bias rate = 1/9
    466          	   - All-indicator lamps-on OFF
    467          	   - Power saving clear
    468          	   - V5 voltage regulator internal resistors Ra and Rb separation
    469          	   - Output conditions of SEG and COM terminals SEG:V2/V3; COM: V1/V4
    470          	   - Read modify write OFF
    471          	   - Static indicator OFF
    472          	   - Display start line set to first line
    473          	   - Column address set to Address 0
    474          	   - Page address set to Page 0
    475          	   - Common output status normal
    476          	   - V5 voltage regulator internal resistor ratio set mode clear
    477          	   - Electronic volume register set mode clear
    478          	   - Test mode clear 
    479              */
    480          
    481              /* reset display */
    482              LCD_WriteCommand(gLCDResetCommand_c);
    483              DelayUs(10);
    484          
    485              /* set LCD bias to 1/9 */
    486              LCD_WriteCommand(gLCD19BiasCommand_c);
    487          
    488              /* set ADC selection to normal: RAM column address n <-> SEGn */
    489              /* LCD_WriteCommand(gLCDADCNormalCommand_c); */
    490              LCD_WriteCommand(gLCDADCReverseCommand_c);
    491          
    492              /* set scan direction of the COM to normal: COM0 --> COM63 */
    493              LCD_WriteCommand(gLCDComNormalCommand_c);
    494          
    495              /* set the Rb/Ra ratio for V5 to medium (D2D1D0 = 0b100) */
    496              LCD_WriteCommand( gLCDDefaultRatioCommand_c | (gLCDRatioValue_c & 0x07) );
    497          
    498              /* enable the electronic volume register set command */
    499              /* this command must always be followed by an electronic volume register set command */
    500              LCD_WriteCommand(gLCDElectronicVolumeModeSetCommand_c);
    501              
    502              LCD_WriteCommand(gLCDElectronicVolumeInitCommand_c);
    503          
    504          
    505              /* disable booster circuit, disable voltage regulator circuit, disable voltage follower circuit */
    506              LCD_WriteCommand(0x2F);
    507              DelayUs(10);
    508              /** turn ON */
    509              LCD_WriteCommand(gLCDDisplayOnCommand_c);
    510              DelayUs(10);
    511              
    512              /* create LCD task */
    513              LCD_TaskInit();
    514              
    515              /* turn on the backlight */
    516              LCD_SetBacklight(1);
    517              
    518              /* set default font */
    519              (void)LCD_SetFont(gLCD_NormalFont_c);
    520              InitQueue();  
    521              mIsLcdInitialized = FALSE;
    522              /* clear display */
    523          #if ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE))
    524              /* During test mode, the LCD operation queue is not used. */
    525              /* Because of this, LCD_ClearDisplay is not called. */
    526              for(ctr = 0; ctr < gLCDMaxRamDataPages_c; ctr++)
    527              {
    528                LCD_ClearPage(0, gLCDMaxColumns_c, ctr*8);
    529              }
    530          #else
    531              LCD_ClearDisplay();
    532          #endif /* ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE)) */    
    533          }
    534          
    535          /******************************************************************************
    536          * This function clears the display. In case an error occured during add to queue
    537          * operation, the clear display operation will not execute.
    538          *
    539          * Interface assumptions:
    540          *
    541          *
    542          * Return value:
    543          * None
    544          *
    545          ******************************************************************************/
    546          void LCD_ClearDisplay(void)
    547          {
    548            opLine_t operationLine;
    549            
    550            /* clear the error indicator */
    551            mErrorIndicator = gLCD_NoError_c;
    552            
    553            operationLine.opQueue   = gLCD_ClearDisplayOp_c;
    554            operationLine.lineQueue = mMaxLineNumber_c;
    555            
    556            if(TRUE == AddToQueue(operationLine))
    557            {
    558              /* send a clear display event */
    559              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);       
    560            }
    561            else
    562            {
    563              /* LCD queue is full */
    564              mErrorIndicator = gLCD_QueueFull_c;
    565            }  
    566          }
    567          
    568          /******************************************************************************
    569          * This function writes a string to the display. In case an error occured 
    570          * during add to queue operation, the write string operation will not execute.
    571          *
    572          * Interface assumptions:
    573          *
    574          *
    575          * Return value:
    576          * None
    577          *
    578          *
    579          ******************************************************************************/
    580          void LCD_WriteString(uint8_t line, uint8_t *pstr)
    581          {
    582            uint8_t stringWidth = 0;
    583            uint8_t len, i;
    584            uint8_t ctr;
    585            uint8_t auxLine;
    586            const uint8_t error[] = "Wrong line";
    587            opLine_t operationLine;
    588            
    589            /* clear the error indicator */
    590            mErrorIndicator = gLCD_NoError_c;
    591            
    592            /* in case of NULL pointers, just return */  
    593            if(pstr == NULL)
    594            {
    595              return;
    596            }  
    597            
    598            auxLine = line;
    599            
    600            /* in case a character height is bigger then 1, lines must have "height" offset between them */
    601            if(aLCDFont[mDisplayParams.currentFontType].fontHeight > 1)
    602            {
    603              switch(auxLine)
    604              {
    605                case 0:
    606                case 1:
    607                case 2:
    608                case 3:        
    609                  auxLine *= aLCDFont[mDisplayParams.currentFontType].fontHeight;
    610                  break;      
    611                default:
    612                  auxLine = aLCDFont[mDisplayParams.currentFontType].fontHeight;
    613                  pstr = (uint8_t*)error; 
    614                  break;      
    615              }        
    616            }
    617            else
    618            {
    619              if(line >= gLCDMaxRamDataPages_c)   
    620              {
    621                auxLine = 1;
    622                pstr = (uint8_t*)error; 
    623              }
    624            }
    625            
    626            len = GetStrlen(pstr);
    627          
    628            FLib_MemCpy(&mDisplayParams.currentString[auxLine], pstr, len);
    629            
    630            /* Clear the rest of the line */
    631            if(len < gMAX_LCD_CHARS_c)
    632            {
    633              for(ctr = len; ctr < gMAX_LCD_CHARS_c;ctr++)
    634              {
    635                mDisplayParams.currentString[auxLine][ctr]=' ';      
    636              }
    637            }
    638          
    639            /* compute the width (in pixels) of the string that will be written */
    640            for(i=0; i<gMAX_LCD_CHARS_c; i++)
    641            {
    642              stringWidth += (aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[auxLine][i] - mFontOffset_c + 1] - \
    643                               aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[auxLine][i] - mFontOffset_c]);    
    644            }
    645            /* if the width (in pixels) of the string that was written before on the same line is bigger than 
    646             * the width of the string that is going to be written,
    647             *  erase the line before write the string  */
    648            if(stringWidth >= mDisplayParams.linesWidthWritten[auxLine])
    649            {
    650              /* mark auxLine as a line to be written */
    651              for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
    652              {
    653                mDisplayParams.linesToWrite |= (1<<(auxLine+i));     
    654              }  
    655            }
    656            else
    657            {
    658              /* add clear line operation in mQueue */
    659              /* add auxLine as a line to be cleared in mQueue */ 
    660              for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
    661              {
    662                operationLine.opQueue   = gLCD_ClearLineOp_c;
    663                operationLine.lineQueue = auxLine + i;  
    664                if(FALSE == AddToQueue(operationLine))
    665                {
    666                  /* queue is full, report an error */
    667                  mErrorIndicator = gLCD_QueueFull_c;
    668                  return;
    669                }
    670              }  
    671            }
    672          
    673            /* add write string operation in mQueue */
    674            /* add auxLine as a line to be written in mQueue */ 
    675            operationLine.opQueue   = gLCD_WriteOp_c;
    676            operationLine.lineQueue = auxLine;  
    677          
    678            if(TRUE == AddToQueue(operationLine))
    679            {
    680              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);  
    681            }  
    682            else
    683            {
    684              /* queue is full, report an error */
    685              mErrorIndicator = gLCD_QueueFull_c;
    686              return;        
    687            }
    688          }
    689          
    690          /******************************************************************************
    691          * This function writes a bitmap to a line of the display. In case an error occured 
    692          * during add to queue operation, the write string operation will not execute.
    693          *
    694          * Interface assumptions:
    695          *
    696          *
    697          * Return value:
    698          * None
    699          *
    700          *
    701          ******************************************************************************/
    702          void LCD_WriteBitmap(                      
    703            uint8_t *pstr,	  /* IN: Pointer to symbol index list to display */
    704            uint8_t len,      /* IN: Length in bytes of the symbol index list */
    705            uint8_t line,     /* IN: Line in display */
    706            uint8_t *bitmap 	/* IN: Pointer to symbol table */   
    707          )
    708          {
    709            uint8_t symbolWidth = 0;
    710            uint8_t ctr;
    711            opLine_t operationLine;
    712            const uint8_t error[] = "Wrong line";
    713            
    714            /* in case of NULL pointers, just return */  
    715            if((pstr == NULL) || (bitmap == NULL))
    716            {
    717              return;
    718            }
    719            
    720            /* in case of wrong line number, print an error message */
    721            if(line >= gLCDMaxRamDataPages_c)
    722            {
    723              LCD_WriteString(1, (uint8_t *)&error);
    724              return;
    725            }
    726            
    727            /* validate the number of symbols to display */
    728            /* only 16 symbols may be displayed */
    729            if(len > gMAX_LCD_CHARS_c)
    730            {
    731              len = gMAX_LCD_CHARS_c;
    732            }
    733           
    734            /* clear the error indicator */
    735            mErrorIndicator = gLCD_NoError_c;
    736            /* retain the start address of the bitmap */
    737            mReceivedBitmap = bitmap;
    738          
    739            FLib_MemCpy(&mDisplayParams.currentBitmap[line], pstr, len);
    740            
    741            /* Clear the rest of the line */
    742            if(len < gMAX_LCD_CHARS_c)
    743            {
    744              for(ctr = len; ctr < gMAX_LCD_CHARS_c;ctr++)
    745              {
    746                mDisplayParams.currentBitmap[line][ctr] = 0xFF;      
    747              }
    748            }
    749          
    750            /* compute the width (in pixels) of the symbols that will be written */
    751            symbolWidth = gMAX_LCD_CHARS_c * mSymbolWidth;
    752          
    753            /* if the width (in pixels) of the symbols that were written before on the same line is bigger than 
    754             * the width of the symbols that are going to be written,
    755             *  erase the line before writing the symbols  */
    756            if(symbolWidth >= mDisplayParams.linesWidthWritten[line])
    757            {
    758              /* mark line as a line to be written */
    759              mDisplayParams.linesToWrite |= (1<<line);         
    760            }
    761            else
    762            {
    763              /* add clear line operation in mQueue */
    764              /* add line as a line to be cleared in mQueue */ 
    765              operationLine.opQueue   = gLCD_ClearLineOp_c;
    766              operationLine.lineQueue = line;  
    767              if(FALSE == AddToQueue(operationLine))
    768              {
    769                /* queue is full, report an error */
    770                mErrorIndicator = gLCD_QueueFull_c;
    771                return;
    772              }
    773            }
    774          
    775            /* add write bitmap operation in mQueue */
    776            /* add line as a line to be written in mQueue */ 
    777            operationLine.opQueue   = gLCD_WriteBitmapOp_c;
    778            operationLine.lineQueue = line;  
    779          
    780            if(TRUE == AddToQueue(operationLine))
    781            {
    782              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);  
    783            }  
    784            else
    785            {
    786              /* queue is full, report an error */
    787              mErrorIndicator = gLCD_QueueFull_c;
    788              return;        
    789            }
    790          }
    791          
    792          /******************************************************************************
    793          * This function write a string and a value in decimal or hexdecimal
    794          * to the display
    795          *
    796          * Interface assumptions:
    797          * The pstr must be zero-terminated.
    798          *
    799          * Return value:
    800          * None
    801          *
    802          *
    803          ******************************************************************************/
    804          void LCD_WriteStringValue
    805            (
    806            uint8_t *pstr,     /* IN: Pointer to text string */
    807            uint16_t value,    /* IN: Value */
    808            uint8_t line, 	   /* IN: Line in display */
    809            LCD_t numberFormat /* IN: Value to show in HEX or DEC */
    810            )
    811          {
    812          
    813            int16_t divDec=10000, divHex=16;
    814            uint8_t loop=5, i=0,counter=0, aH[6], aHex[6];
    815            uint8_t aDec[6], aString[17];
    816            
    817            /* clear the error indicator */
    818            mErrorIndicator = gLCD_NoError_c;
    819          
    820           if(numberFormat == gLCD_DecFormat_c) {
    821              if(value < 100) {
    822                loop = 2;
    823                divDec = 10;
    824              }
    825              else if(value >= 100 && value <1000) {
    826                loop = 3;
    827                divDec = 100;
    828              }
    829              else if(value >= 1000 && value <9999) {
    830                loop = 4;
    831                divDec = 1000;
    832              }
    833          
    834              for(i=0; i<loop; i++) {
    835                if((value/divDec)!= 0) {
    836                  aDec[counter++] = (value/divDec) + 0x30;
    837                  value = value % divDec;
    838                }
    839                else {
    840                  aDec[counter++] = 0x30;
    841                }
    842                divDec = divDec/10;
    843              }
    844              aDec[counter]='\0';
    845              counter=0;
    846              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
    847                aString[counter++]=*pstr;
    848                pstr++;
    849              }
    850              i=0;
    851              while (aDec[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
    852                aString[counter++]=aDec[i++];
    853              }
    854              aString[counter]='\0';
    855              LCD_WriteString( line, aString );
    856            }
    857            else if(numberFormat == gLCD_HexFormat_c) {
    858              do{
    859                aH[i]=gaHexValue[value % divHex];
    860                value=value / divHex;
    861                i++;
    862              }
    863              while(value > 15);
    864              aH[i]=gaHexValue[value];
    865              counter=0;
    866              while(i > 0){
    867                aHex[counter++]=aH[i--];
    868              }
    869          
    870              aHex[counter++]=aH[0];
    871              aHex[counter]='\0';
    872          
    873              counter=0;
    874              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
    875                aString[counter++]=*pstr;
    876                pstr++;
    877              }
    878              i=0;
    879              while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
    880                aString[counter++]=aHex[i++];
    881              }
    882              aString[counter]='\0';
    883              LCD_WriteString( line, aString );
    884            }
    885            else {
    886              LCD_WriteString( line, "Format unknow" );
    887            }
    888          }
    889          
    890          /******************************************************************************
    891          * This functions allows to write raw bytes to the LCD, the maximum number of bytes
    892          *	capable per line is 8, this functions transfors every hex simbol in a byte to a char.
    893          *
    894          * Interface assumptions:
    895          *	IN: The pointer to the label to print with the bytes.
    896          *	IN: The bytes to print.
    897          *	IN: The line in the LCD where the bytes with the label.
    898          *	IN: The number of bytes to print in the LCD.
    899          *
    900          * Return value:
    901          * None
    902          *
    903          *
    904          ******************************************************************************/
    905          void LCD_WriteBytes
    906          (
    907          	uint8_t   *pstr,   /* IN: The pointer to the label to print with the bytes. */
    908          	uint8_t   *value,  /* IN: The bytes to print in hex. */
    909          	uint8_t   line,    /* IN: The line in the LCD where the bytes with the label. */
    910          	uint8_t   length   /* IN: The number of bytes to print in the LCD. */
    911          )
    912          {
    913          
    914          	uint8_t i=0,counter=0, cIndex,auxIndex;
    915          	uint8_t aString[17];
    916          
    917          	uint8_t  hexIndex;
    918          	uint8_t aHex[gMAX_LCD_CHARS_c]={'S','i','z','e',' ','N','o','t',' ','V','a','l','i','d','*','*'};
    919          
    920            /* clear the error indicator */
    921            mErrorIndicator = gLCD_NoError_c;
    922            
    923          	counter=0;
    924          	while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c )
    925          	{
    926          		aString[counter++]=*pstr;
    927          		pstr++;
    928          	}
    929          	if ((((length*2)+counter) <= gMAX_LCD_CHARS_c) && ((length*2) > 0))
    930          	{
    931          		for (cIndex =0,auxIndex = 0; cIndex < length; cIndex++,auxIndex+=2)
    932          		{
    933          			hexIndex = value[cIndex]&0xf0;
    934          			hexIndex = hexIndex>>4;
    935          			aHex[auxIndex] = gaHexValue[hexIndex];
    936          			hexIndex = value[cIndex] & 0x0f;
    937          			aHex[auxIndex + 1] = gaHexValue[hexIndex];
    938          		}
    939          		aHex[(length * 2)]='\0';
    940          	}
    941          	else
    942          		counter = 0;
    943          
    944          	i=0;
    945          	while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c )
    946          		aString[counter++]=aHex[i++];
    947          
    948          	aString[counter]='\0';
    949          	LCD_WriteString( line, aString );
    950          }
    951          
    952          /******************************************************************************
    953          * This function sends a command to the display controller
    954          *
    955          * Interface assumptions:
    956          *
    957          *
    958          * Return value:
    959          * None
    960          *
    961          *
    962          ******************************************************************************/
    963          void LCD_WriteCommand(uint8_t command)
    964          {
    965            /* clear the error indicator */
    966            mErrorIndicator = gLCD_NoError_c;
    967            
    968            Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
    969            SetOutput();
    970            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
    971            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
    972            SendData(command);
    973            DelayUs(1);
    974            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
    975            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
    976            SetHiZ();
    977            DelayUs(1);
    978          }
    979          
    980          /******************************************************************************
    981          * This function sends a data to the display controller
    982          *
    983          * Interface assumptions:
    984          *
    985          *
    986          * Return value:
    987          * None
    988          *
    989          *
    990          ******************************************************************************/
    991          void LCD_WriteData(uint8_t data)
    992          {
    993            /* clear the error indicator */
    994            mErrorIndicator = gLCD_NoError_c;
    995          
    996            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
    997            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
    998            SetOutput();
    999            SendData(data);
   1000            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
   1001            DelayUs(1);
   1002            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   1003            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   1004            SetHiZ();
   1005            DelayUs(1);  
   1006           
   1007          }
   1008          
   1009          /******************************************************************************
   1010          * This function sets the font received as parameter as default font
   1011          *
   1012          * Interface assumptions:
   1013          *
   1014          *
   1015          * Return value:
   1016          *      TRUE:  when the font is correctly set
   1017          *      FALSE: when an unsupported font is received as parameter
   1018          * char
   1019          *
   1020          *
   1021          ******************************************************************************/
   1022          bool_t LCD_SetFont(lcdFontType_t font)
   1023          {
   1024            /* clear the error indicator */
   1025            mErrorIndicator = gLCD_NoError_c;
   1026          
   1027            if(gLCDNumFonts_c > font)
   1028            {
   1029              mDisplayParams.currentFontType = font;
   1030              return TRUE;
   1031            }
   1032            else
   1033            {
   1034              return FALSE;
   1035            }
   1036          }
   1037          
   1038          /******************************************************************************
   1039          * This function checks if an error occured during an interface function call.
   1040          * User must always call this function to verify if an interface function executed 
   1041          * successufully.
   1042          *
   1043          * Interface assumptions:
   1044          *
   1045          *
   1046          * Return value:  lcdError_t
   1047          *      gLCD_NoError_c:   no error
   1048          *      gLCD_QueueFull_c: queue is full
   1049          *
   1050          *
   1051          ******************************************************************************/
   1052          lcdError_t LCD_CheckError(void)
   1053          {
   1054            return mErrorIndicator;
   1055          }
   1056          
   1057          /************************************************************************************
   1058          *************************************************************************************
   1059          * Private functions
   1060          *************************************************************************************
   1061          ************************************************************************************/
   1062          
   1063          /******************************************************************************
   1064          * LCD task
   1065          *
   1066          * Interface assumptions:
   1067          *
   1068          *
   1069          * Return value:
   1070          * None
   1071          *
   1072          *
   1073          ******************************************************************************/
   1074          void LCD_Task(event_t events)
   1075          {
   1076            static opLine_t mOperationLine;
   1077            (void)events;
   1078          
   1079            /* pop a new operation from the queue, only if the precedent operation was finished */
   1080            if(mOperationCompleted)
   1081            {
   1082              mOperationLine = RemoveFromQueue();     
   1083            }
   1084          
   1085            ProcessOperation(mOperationLine);  
   1086          
   1087            if(!IsQueueEmpty())
   1088            {
   1089              /* prepare for next operation */
   1090              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);     
   1091            }
   1092            
   1093          } 
   1094          
   1095          /******************************************************************************
   1096          * This function initializes the LCD Task
   1097          *
   1098          * Interface assumptions:
   1099          *
   1100          *
   1101          * Return value:
   1102          * None
   1103          *
   1104          *
   1105          ******************************************************************************/
   1106          void LCD_TaskInit(void)
   1107          {
   1108            gLCDTaskID = TS_CreateTask(gTsLCDTaskPriority_c, LCD_Task);
   1109          }
   1110          
   1111          /******************************************************************************
   1112          * This function enables/disables the backlight
   1113          *
   1114          * Interface assumptions:
   1115          *   0 - disable backlight
   1116          *   >0 - enables backlight
   1117          *
   1118          *
   1119          * Return value:
   1120          * None
   1121          *
   1122          *
   1123          ******************************************************************************/
   1124          void LCD_SetBacklight(uint8_t brightnessValue)
   1125          {
   1126          #ifdef gLcdBackLightEnabled_d
   1127          /* this was removed due to electrical influence on RF TX */
   1128              GpioPinState_t backLightState;
   1129              backLightState = (0 != brightnessValue) ? gGpioPinStateHigh_c : gGpioPinStateLow_c;
   1130              Gpio_SetPinData(LCD_BL_PWM,  backLightState);
   1131          #else
   1132              (void)brightnessValue;
   1133          #endif /* gLcdBackLightEnabled_d */
   1134          }
   1135          
   1136          /******************************************************************************
   1137          * This function sets/ clears the pixel from (XStartCoord, YStartCoord)
   1138          *
   1139          * Interface assumptions:
   1140          *
   1141          *
   1142          * Return value:
   1143          * None
   1144          *
   1145          *
   1146          ******************************************************************************/
   1147          void LCD_WritePixel(uint8_t xStartCoord, uint8_t yStartCoord, bool_t mode)
   1148          {
   1149            uint8_t page;
   1150            uint8_t read;
   1151          
   1152            if (xStartCoord>=gLCDMaxColumns_c || yStartCoord>=gLCDMaxLines_c)
   1153            {
   1154              return; /* if pixel out of screen exit */
   1155            }
   1156          
   1157            page = yStartCoord >> 3;
   1158            yStartCoord %= 8;
   1159          
   1160            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   1161            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   1162            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   1163            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));       
   1164          
   1165            read = ReadData(); // Dummy read
   1166            read = ReadData();
   1167          
   1168            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   1169            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   1170            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   1171            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));
   1172          
   1173            if( TRUE == mode )
   1174            {
   1175              LCD_WriteData((read | (1 << yStartCoord)));
   1176            }
   1177            else
   1178            {  
   1179              LCD_WriteData((read & ~(1 << yStartCoord)));  
   1180            }
   1181          }
   1182          
   1183          /******************************************************************************
   1184          * This function displays a character starting with xCoord and yCoord
   1185          *
   1186          * Interface assumptions:
   1187          *  yCoord is a multiple of 8
   1188          *
   1189          *
   1190          * Return value:
   1191          * None
   1192          *
   1193          *
   1194          ******************************************************************************/
   1195          void LCD_WriteCharacter(uint8_t symbol, uint8_t xCoord, uint8_t yCoord)
   1196          {
   1197            uint16_t arrayLocation=0; 
   1198            uint8_t i, maxLength;
   1199           
   1200            /* if pixel out of screen, exit */
   1201            if((xCoord >= gLCDMaxColumns_c) && (yCoord >= gLCDMaxLines_c))
   1202            {
   1203              return;
   1204            }
   1205              
   1206            arrayLocation = symbol - mFontOffset_c;
   1207            maxLength = aLCDFont[mDisplayParams.currentFontType].fontHeight;
   1208            /* each character has: 
   1209            *  (aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation+1] - 
   1210            *   aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation]) pixels as width 
   1211            *  (aLCDFont[mDisplayParams.currentFontType].fontHeight * 8) pixels as height 
   1212            */
   1213            while(maxLength > 0)
   1214            {
   1215              maxLength--;      
   1216              InitDisplayWrite(xCoord,yCoord);        
   1217              /* mark line as written */
   1218              mDisplayParams.writtenLines |= (1<<(yCoord>>3));   
   1219              for(i = 0;
   1220                  i < ((aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation+1] - 
   1221                        aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]) *
   1222                        aLCDFont[mDisplayParams.currentFontType].fontHeight);
   1223                  i += aLCDFont[mDisplayParams.currentFontType].fontHeight)        
   1224              {
   1225                /* in case the character is representd on multiple lines,
   1226                 * (aLCDFont[mDisplayParams.currentFontType].fontHeight > 1),
   1227                 * display first the upper part of the character and after the lower part 
   1228                 */
   1229                LCD_WriteData(aLCDFont[mDisplayParams.currentFontType].pFontCharTable[aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]*aLCDFont[mDisplayParams.currentFontType].fontHeight + i + maxLength]);
   1230              }
   1231              yCoord += 8;
   1232            }    
   1233          }
   1234          
   1235          /******************************************************************************
   1236          * This function displays a symbol starting with xCoord and yCoord
   1237          *
   1238          * Interface assumptions:
   1239          *  yCoord is a multiple of 8
   1240          *
   1241          *
   1242          * Return value:
   1243          * None
   1244          *
   1245          *
   1246          ******************************************************************************/
   1247          void LCD_WriteSymbol(uint8_t index, uint8_t xCoord, uint8_t yCoord, uint8_t* bitmap)
   1248          { 
   1249            uint8_t i;
   1250           
   1251            /* if pixel out of screen, exit */
   1252            if((xCoord >= gLCDMaxColumns_c) && (yCoord >= gLCDMaxLines_c))
   1253            {
   1254              return;
   1255            }
   1256            /* if gsBitmap is NULL, exit */
   1257            if(bitmap == NULL)
   1258            {
   1259              return;
   1260            }  
   1261          
   1262            /* each symbol has: 
   1263            *  8 pixels as width 
   1264            *  8 pixels as height 
   1265            */    
   1266            InitDisplayWrite(xCoord,yCoord);        
   1267            /* mark line as written */
   1268            mDisplayParams.writtenLines |= (1<<(yCoord>>3));   
   1269            for(i = 0; i < mSymbolWidth; i++)        
   1270            {
   1271              /* write the symbol */
   1272              LCD_WriteData(bitmap[index * mSymbolWidth + i]);
   1273            }
   1274          }
   1275          
   1276          /****************************************************************************************
   1277          * This function clears the pixels between startXCoord and endXCoord within a single page
   1278          * (page located at yCoord)
   1279          *
   1280          * Interface assumptions:
   1281          *
   1282          *
   1283          * Return value:
   1284          * None
   1285          *
   1286          *
   1287          ******************************************************************************/
   1288          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord)
   1289          {
   1290            uint8_t i;
   1291            
   1292            InitDisplayWrite(startXCoord, yCoord);
   1293            for(i = startXCoord; i < endXCoord; i++)
   1294            {
   1295              LCD_WriteData(OFF);    
   1296            }    
   1297          }
   1298          
   1299          /****************************************************************************************
   1300          * This function clears an entire LCD line
   1301          *
   1302          * Interface assumptions:
   1303          *     char line = 0..7
   1304          *
   1305          *
   1306          * Return value:
   1307          *     TRUE if the line was cleared
   1308          *     FALSE if the line is not cleared yet
   1309          *     0xFF  if the line parameter is not valid
   1310          * None
   1311          *
   1312          *
   1313          ******************************************************************************/
   1314          uint8_t LCD_ClearLine(uint8_t line)
   1315          {
   1316            static pageParams_t pageToDelete;
   1317            static bool_t isPageDeleted = TRUE;
   1318            
   1319            if(line < gLCDMaxRamDataPages_c)
   1320            {
   1321              /* save the page coordinates */
   1322              if(isPageDeleted)
   1323              {
   1324                pageToDelete.xStartCoord = mLineParams[line].xCoord;
   1325                pageToDelete.xEndCoord   = gLCDMaxColumns_c;
   1326                pageToDelete.yCoord      = mLineParams[line].yCoord;
   1327                pageToDelete.line        = line; 
   1328              }
   1329              
   1330              /* delete only mMaxDeleteColumns_c columns once because of time constraints */
   1331              if(((pageToDelete.xEndCoord - pageToDelete.xStartCoord) >= mMaxDeleteColumns_c))
   1332              {
   1333                /* the page will be deleted with (gLCDMaxColumns_c/mMaxDeleteColumns_c) consecutive operations */
   1334                isPageDeleted            = FALSE;
   1335                TS_SendEvent(gLCDTaskID, gLCDOpEvt_c); 
   1336                LCD_ClearPage(pageToDelete.xStartCoord, 
   1337                              pageToDelete.xStartCoord + mMaxDeleteColumns_c, 
   1338                              pageToDelete.yCoord); 
   1339                /* compute the new xStartCoord for the current page */
   1340                pageToDelete.xStartCoord = pageToDelete.xStartCoord + mMaxDeleteColumns_c;        
   1341                return FALSE;  
   1342              }
   1343              else
   1344              {    
   1345                LCD_ClearPage(pageToDelete.xStartCoord, 
   1346                              pageToDelete.xEndCoord, 
   1347                              pageToDelete.yCoord);
   1348                isPageDeleted            = TRUE;
   1349                return TRUE;  
   1350              } 
   1351            }
   1352            else
   1353            {
   1354              return 0xFF;
   1355            }
   1356          }
   1357          
   1358          /******************************************************************************
   1359          * This function process an LCD operation (clear, write string).
   1360          *
   1361          * Interface assumptions:
   1362          *
   1363          *
   1364          * Return value:
   1365          * None
   1366          *
   1367          *
   1368          ******************************************************************************/
   1369          static void ProcessOperation(opLine_t operationAndLine)
   1370          {
   1371            static uint8_t linesToClear = 0x00;
   1372            uint8_t line, i, deleteWriteLines = 0xFF;
   1373            switch(operationAndLine.opQueue)
   1374            {  
   1375              case gLCD_WriteOp_c:  
   1376                if(mOperationCompleted)
   1377                {
   1378                  line = operationAndLine.lineQueue;
   1379                  /* initialize the start coordinates for the string to be written */ 
   1380                  mDisplayParams.currentLine = line;
   1381                  mDisplayParams.currentXCoord = mLineParams[line].xCoord;;  
   1382                  mDisplayParams.currentYCoord = mLineParams[line].yCoord; 
   1383                  mDisplayParams.currentStringIndex = 0;
   1384                  mOperationCompleted               = FALSE;  
   1385                }      
   1386                /* display only mNumberOfCharToWrite_c characters once because of time constraints */
   1387                for(i = 0; ((i < mNumberOfCharToWrite_c)&&(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)); i++)
   1388                {
   1389                  /* display the character at the currentStringIndex in the currentString */
   1390                  LCD_WriteCharacter(mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex], 
   1391                                     mDisplayParams.currentXCoord, 
   1392                                     mDisplayParams.currentYCoord);             
   1393                  /* compute X coordinate for the next character */
   1394                  mDisplayParams.currentXCoord += (aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] - mFontOffset_c + 1] - 
   1395                                                   aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] - mFontOffset_c]);
   1396                  mDisplayParams.currentStringIndex++;  
   1397                }
   1398                  
   1399                /* have we displayed the last character from the buffer? */
   1400                if(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)
   1401                {
   1402                  TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);
   1403                }
   1404                else
   1405                { /* reset display parameters */      
   1406                  mDisplayParams.linesWidthWritten[mDisplayParams.currentLine] = mDisplayParams.currentXCoord;
   1407                  mDisplayParams.currentStringIndex = 0;       
   1408                  for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
   1409                  { 
   1410                    /* clear the bitmask bit from linesToWrite because line was written  */
   1411                    mDisplayParams.linesToWrite &=(~(1<<(mDisplayParams.currentLine+i)));
   1412                    /* mark line as written */
   1413                    mDisplayParams.writtenLines |= (1<<(mDisplayParams.currentLine+i)); 
   1414                  }        
   1415                  mDisplayParams.currentLine        = mMaxLineNumber_c;
   1416                  mOperationCompleted               = TRUE;        
   1417                }          
   1418                break;
   1419                
   1420              case gLCD_ClearDisplayOp_c:
   1421                if(mOperationCompleted)
   1422                {
   1423                  /* determine the lines that were written and need to be cleared */   
   1424                  linesToClear = mDisplayParams.writtenLines;  
   1425                  if(mIsLcdInitialized == TRUE)
   1426                  {
   1427                    /* determine if there are lines that need to be erased and after need to be written */
   1428                    deleteWriteLines = linesToClear & mDisplayParams.linesToWrite;
   1429                    if(deleteWriteLines)
   1430                    { /* if there are */
   1431                      /* mark that lines as deleted and jump over them */
   1432                      linesToClear &= ~(deleteWriteLines);  
   1433                    }
   1434                  }
   1435                  mOperationCompleted               = FALSE;
   1436                }
   1437                
   1438                line = 0;
   1439                /* find the first written line */
   1440                while((!((linesToClear>>line)&0x01))&&(line<mMaxLineNumber_c))
   1441                {
   1442                  line++;
   1443                }
   1444                if(line!= mMaxLineNumber_c)
   1445                {
   1446                  /* in case at least a line is written */
   1447                  if(TRUE == LCD_ClearLine(line))
   1448                  {
   1449                    /* mark line as cleared */
   1450                    mDisplayParams.writtenLines &= ~(1 << line);
   1451                    linesToClear &= ~(1 << line);
   1452                    /* check if there are other lines written */
   1453                    if(linesToClear)
   1454                    {
   1455                      /* prepare clearing the other line(s) */
   1456                      TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);          
   1457                    }
   1458                    else
   1459                    {
   1460                      mOperationCompleted = TRUE;
   1461                      mIsLcdInitialized   = TRUE;
   1462                    }          
   1463                  }
   1464                }
   1465                else
   1466                {
   1467                  mOperationCompleted = TRUE;   
   1468                  mIsLcdInitialized   = TRUE;
   1469                }
   1470                break; 
   1471                
   1472              case gLCD_ClearLineOp_c:      
   1473                if(mOperationCompleted)
   1474                {
   1475                  /* start the operation */
   1476                  mOperationCompleted               = FALSE;
   1477                }
   1478                /* check if the operation is finished */
   1479                if(TRUE == LCD_ClearLine(operationAndLine.lineQueue))
   1480                {
   1481                  /* mark line as cleared */
   1482                  mDisplayParams.writtenLines &= ~(1 << operationAndLine.lineQueue);
   1483                  /* stop the operation */ 
   1484                  mOperationCompleted = TRUE;          
   1485                }
   1486                break;
   1487                
   1488              case gLCD_WriteBitmapOp_c:  
   1489                if(mOperationCompleted)
   1490                {
   1491                  line = operationAndLine.lineQueue;
   1492                  /* initialize the start coordinates for the string to be written */ 
   1493                  mDisplayParams.currentLine = line;
   1494                  mDisplayParams.currentXCoord = mLineParams[line].xCoord;;  
   1495                  mDisplayParams.currentYCoord = mLineParams[line].yCoord; 
   1496                  mDisplayParams.currentStringIndex = 0;
   1497                  mOperationCompleted               = FALSE;  
   1498                }      
   1499                /* display only mNumberOfCharToWrite_c characters once because of time constraints */
   1500                for(i = 0; ((i < mNumberOfCharToWrite_c)&&(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)); i++)
   1501                {
   1502                  /* display the character at the currentStringIndex in the currentBitmap */
   1503                  /* in case space must be inserted, use mBitmapSpace as bitmap and 0 as index */
   1504                  if(mDisplayParams.currentBitmap[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] != 0xFF)
   1505                  {
   1506                    LCD_WriteSymbol(mDisplayParams.currentBitmap[mDisplayParams.currentLine][mDisplayParams.currentStringIndex], 
   1507                                    mDisplayParams.currentXCoord, 
   1508                                    mDisplayParams.currentYCoord,
   1509                                    mReceivedBitmap); 
   1510                  }
   1511                  else
   1512                  {
   1513                    LCD_WriteSymbol(0x00, 
   1514                                    mDisplayParams.currentXCoord, 
   1515                                    mDisplayParams.currentYCoord,
   1516                                    mBitmapSpace); 
   1517                  }          
   1518                  /* compute X coordinate for the next character */
   1519                  mDisplayParams.currentXCoord += (mSymbolWidth);
   1520                  mDisplayParams.currentStringIndex++;  
   1521                }
   1522                  
   1523                /* have we displayed the last character from the buffer? */
   1524                if(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)
   1525                {
   1526                  TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);
   1527                }
   1528                else
   1529                { /* reset display parameters */      
   1530                  mDisplayParams.linesWidthWritten[mDisplayParams.currentLine] = mDisplayParams.currentXCoord;
   1531                  mDisplayParams.currentStringIndex = 0;       
   1532                  /* clear the bitmask bit from linesToWrite because line was written  */
   1533                  mDisplayParams.linesToWrite &=(~(1<<mDisplayParams.currentLine));
   1534                  /* mark line as written */
   1535                  mDisplayParams.writtenLines |= (1<<mDisplayParams.currentLine);        
   1536                  mDisplayParams.currentLine        = mMaxLineNumber_c;
   1537                  mOperationCompleted               = TRUE;        
   1538                }          
   1539                break;
   1540          
   1541              default: 
   1542                break;    
   1543            }    
   1544          }
   1545          
   1546          /******************************************************************************
   1547          * This function sets a certain value to the LCD DATA pins
   1548          *
   1549          * Interface assumptions:
   1550          *
   1551          *
   1552          * Return value:
   1553          * None
   1554          *
   1555          *
   1556          ******************************************************************************/
   1557          static void SendData(uint8_t data)
   1558          {
   1559          #if gLCDGpioPinMode_c
   1560              /* bit |7|6|5|4|3|2|1|0| */
   1561              (void)Gpio_SetPinData(LCD_D0, (data & 0x01)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1562              (void)Gpio_SetPinData(LCD_D1, (data & 0x02)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1563              (void)Gpio_SetPinData(LCD_D2, (data & 0x04)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1564              (void)Gpio_SetPinData(LCD_D3, (data & 0x08)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1565              (void)Gpio_SetPinData(LCD_D4, (data & 0x10)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1566              (void)Gpio_SetPinData(LCD_D5, (data & 0x20)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1567              (void)Gpio_SetPinData(LCD_D6, (data & 0x40)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1568              (void)Gpio_SetPinData(LCD_D7, (data & 0x80)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1569          #else /* gLCDGpioPinMode_c */    
   1570              Gpio_SetPortData(LCD_DATA_LO_PORT, LCD_DATA_LO_WRITE(data), LCD_DATA_LO_MASK); 
   1571              Gpio_SetPortData(LCD_DATA_HI_PORT, LCD_DATA_HI_WRITE(data), LCD_DATA_HI_MASK);
   1572              
   1573          #endif /* gLCDGpioPinMode_c */     
   1574          }
   1575          
   1576          /******************************************************************************
   1577          * This function sets the LCD DATA pins as inputs
   1578          *
   1579          * Interface assumptions:
   1580          *
   1581          *
   1582          * Return value:
   1583          * None
   1584          *
   1585          *
   1586          ******************************************************************************/
   1587          static void SetHiZ(void)
   1588          {
   1589              /* change data pins direction back to input */
   1590          #if gLCDGpioPinMode_c
   1591              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
   1592              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
   1593              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
   1594              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
   1595              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
   1596              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
   1597              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
   1598              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
   1599          #else /* gLCDGpioPinMode_c */ 
   1600              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK); 
   1601              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK); 
   1602              
   1603          #endif /* gLCDGpioPinMode_c */
   1604          
   1605          }
   1606          
   1607          /******************************************************************************
   1608          * This function sets the LCD DATA pins as outputs
   1609          *
   1610          * Interface assumptions:
   1611          *
   1612          *
   1613          * Return value:
   1614          * None
   1615          *
   1616          *
   1617          ******************************************************************************/
   1618          static void SetOutput(void)
   1619          {
   1620            /* change data pins direction to output */
   1621          #if gLCDGpioPinMode_c
   1622            (void)Gpio_SetPinDir(LCD_D0,      gGpioDirOut_c);
   1623            (void)Gpio_SetPinDir(LCD_D1,      gGpioDirOut_c);
   1624            (void)Gpio_SetPinDir(LCD_D2,      gGpioDirOut_c);
   1625            (void)Gpio_SetPinDir(LCD_D3,      gGpioDirOut_c);
   1626            (void)Gpio_SetPinDir(LCD_D4,      gGpioDirOut_c);
   1627            (void)Gpio_SetPinDir(LCD_D5,      gGpioDirOut_c);
   1628            (void)Gpio_SetPinDir(LCD_D6,      gGpioDirOut_c);
   1629            (void)Gpio_SetPinDir(LCD_D7,      gGpioDirOut_c);
   1630          #else /* gLCDGpioPinMode_c */
   1631             
   1632              Gpio_SetPortDir(LCD_DATA_LO_PORT, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);      
   1633              Gpio_SetPortDir(LCD_DATA_HI_PORT, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);         
   1634              
   1635          #endif /* gLCDGpioPinMode_c */
   1636          
   1637          }
   1638          
   1639          /******************************************************************************
   1640          * This function initilizes the display for a data write (line, page, column)
   1641          *
   1642          * Interface assumptions:
   1643          *
   1644          *
   1645          * Return value:
   1646          * None
   1647          *
   1648          *
   1649          ******************************************************************************/
   1650          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord)
   1651          {
   1652          
   1653            uint8_t page;  
   1654            
   1655            page = yStartCoord >> 3;
   1656          
   1657            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   1658            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   1659            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   1660            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));         
   1661          }
   1662          
   1663          /******************************************************************************
   1664          * This function reads the current location from display data RAM
   1665          *
   1666          * Interface assumptions:
   1667          *
   1668          *
   1669          * Return value:
   1670          * None
   1671          *
   1672          *
   1673          ******************************************************************************/
   1674          static uint8_t ReadData(void)
   1675          {
   1676            uint8_t ReturnValue;
   1677            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
   1678            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   1679            DelayUs(1);
   1680            Gpio_SetPinData(LCD_RD, LCD_RD_ACTIVE);
   1681            DelayUs(1);
   1682            ReturnValue = GetData();
   1683            Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
   1684            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   1685            DelayUs(1);
   1686            return ReturnValue;
   1687          }
   1688          
   1689          /******************************************************************************
   1690          * This function sets the data from the current RAM display location
   1691          * to LCD DATA pins
   1692          *
   1693          * Interface assumptions:
   1694          *
   1695          *
   1696          * Return value:
   1697          * unsigned 8 bit
   1698          *
   1699          *
   1700          ******************************************************************************/
   1701          static uint8_t GetData(void)
   1702          {
   1703              uint8_t        ReturnValue = 0;
   1704          #if gLCDGpioPinMode_c
   1705              GpioPinState_t Bitdata;
   1706              /* bit |7|6|5|4|3|2|1|0| */
   1707              Gpio_GetPinData(LCD_D7, &Bitdata);
   1708              ReturnValue = (Bitdata)? (1<<7) : 0;
   1709              Gpio_GetPinData(LCD_D6, &Bitdata);
   1710              ReturnValue |= (Bitdata)? (1<<6) : 0;
   1711              Gpio_GetPinData(LCD_D5, &Bitdata);
   1712              ReturnValue |= (Bitdata)? (1<<5) : 0;
   1713              Gpio_GetPinData(LCD_D4, &Bitdata);
   1714              ReturnValue |= (Bitdata)? (1<<4) : 0;
   1715              Gpio_GetPinData(LCD_D3, &Bitdata);
   1716              ReturnValue |= (Bitdata)? (1<<3) : 0;
   1717              Gpio_GetPinData(LCD_D2, &Bitdata);
   1718              ReturnValue |= (Bitdata)? (1<<2) : 0;
   1719              Gpio_GetPinData(LCD_D1, &Bitdata);
   1720              ReturnValue |= (Bitdata)? (1<<1) : 0;
   1721              Gpio_GetPinData(LCD_D0, &Bitdata);
   1722              ReturnValue |= (Bitdata)? (1<<0) : 0;
   1723              
   1724          #else /* gLCDGpioPinMode_c */
   1725              uint32_t temp;
   1726              Gpio_GetPortData(LCD_DATA_LO_PORT, &temp);
   1727              ReturnValue = LCD_DATA_LO_READ(LCD_DATA_LO_MASK & temp);
   1728              Gpio_GetPortData(LCD_DATA_HI_PORT, &temp);
   1729              ReturnValue |= LCD_DATA_HI_READ(LCD_DATA_HI_MASK & temp);
   1730          
   1731          #endif /* gLCDGpioPinMode_c */
   1732              
   1733              return ReturnValue;
   1734          }
   1735          
   1736          /******************************************************************************
   1737          * This function gets the length of a string and return the length
   1738          *
   1739          * Interface assumptions:
   1740          *
   1741          *
   1742          * Return value:
   1743          * char
   1744          *
   1745          *
   1746          ******************************************************************************/
   1747          static uint8_t GetStrlen
   1748            (
   1749            const uint8_t *pString /* IN: Pointer to text string */
   1750            )
   1751          {
   1752            int8_t count=0, length=0;
   1753          
   1754            while (*pString != '\0' && count <gMAX_LCD_CHARS_c ) {
   1755              count++;
   1756              length++;
   1757              pString++;
   1758            }
   1759          
   1760            /* Check boundries */
   1761            if ( length > gMAX_LCD_CHARS_c ) {
   1762              length = gMAX_LCD_CHARS_c;
   1763            }
   1764          
   1765            return length;
   1766          }
   1767          
   1768          /******************************************************************************
   1769          * This function initializes the operation queue
   1770          *
   1771          * Interface assumptions:
   1772          *
   1773          *
   1774          * Return value: NONE
   1775          *
   1776          *
   1777          ******************************************************************************/
   1778          static void InitQueue(void)
   1779          {
   1780            uint8_t i;
   1781            
   1782            mQueue.head = 0;
   1783            mQueue.tail = 0;
   1784            for(i=0; i<mMaxQueueEntries_c; i++)
   1785            {
   1786              mQueue.opLine[i].opQueue   = (operation_t)mEmptyQueue_c;    
   1787              mQueue.opLine[i].lineQueue = mEmptyQueue_c;   
   1788            }
   1789          }
   1790          
   1791          /******************************************************************************
   1792          * This function adds an element to the queue
   1793          *
   1794          * Interface assumptions:
   1795          *
   1796          *
   1797          * Return value:
   1798          *  TRUE  - if the operation was successuful
   1799          *  FALSE - if the queue is full and the element could not be added   
   1800          *
   1801          *
   1802          ******************************************************************************/
   1803          static bool_t AddToQueue(opLine_t operationLine)
   1804          {
   1805            if(!IsQueueFull())
   1806            { 
   1807              mQueue.opLine[mQueue.tail].opQueue   = operationLine.opQueue;   
   1808              mQueue.opLine[mQueue.tail].lineQueue = operationLine.lineQueue;   
   1809              if(++mQueue.tail == mMaxQueueEntries_c)
   1810              {
   1811                mQueue.tail = 0;      
   1812              }
   1813              return TRUE;
   1814            }
   1815            else
   1816            {
   1817              return FALSE;    
   1818            }  
   1819          }  
   1820          
   1821          /******************************************************************************
   1822          * This function removes an element from the queue
   1823          *
   1824          * Interface assumptions:
   1825          *
   1826          *
   1827          * Return value:
   1828          *  value from the queue  - if the operation was successuful
   1829          *  mEmptyQueue_c, mEmptyQueue_c - if the queue is empty and the element could not be removed   
   1830          *
   1831          *
   1832          ******************************************************************************/
   1833          static opLine_t RemoveFromQueue(void)
   1834          {
   1835            opLine_t returnValue = {(operation_t)mEmptyQueue_c, mEmptyQueue_c};
   1836            if(!IsQueueEmpty())
   1837            {
   1838              returnValue.opQueue   = mQueue.opLine[mQueue.head].opQueue;
   1839              returnValue.lineQueue = mQueue.opLine[mQueue.head].lineQueue;
   1840              mQueue.opLine[mQueue.head].opQueue   = (operation_t)mEmptyQueue_c;
   1841              mQueue.opLine[mQueue.head].lineQueue = mEmptyQueue_c;
   1842              if(++mQueue.head == mMaxQueueEntries_c)
   1843              {
   1844                mQueue.head = 0;      
   1845              }    
   1846            }
   1847            return  returnValue;
   1848          }  
   1849          
   1850          /******************************************************************************
   1851          * This function checks if the mQueue queue is empty
   1852          *
   1853          * Interface assumptions:
   1854          *
   1855          *
   1856          * Return value:
   1857          *  TRUE  - if the queue is empty
   1858          *  FALSE - otherwise   
   1859          *
   1860          *
   1861          ******************************************************************************/
   1862          static bool_t IsQueueEmpty(void)
   1863          {
   1864            if((mQueue.head == mQueue.tail)&&
   1865               (mQueue.opLine[mQueue.head].opQueue   == mEmptyQueue_c)&&
   1866               (mQueue.opLine[mQueue.head].lineQueue == mEmptyQueue_c))
   1867            {
   1868              return TRUE;      
   1869            }
   1870            else
   1871            {
   1872              return FALSE;
   1873            }  
   1874          }  
   1875          
   1876          /******************************************************************************
   1877          * This function checks if the mQueue queue is full
   1878          *
   1879          * Interface assumptions:
   1880          *
   1881          *
   1882          * Return value:
   1883          *  TRUE  - if the queue is full
   1884          *  FALSE - otherwise   
   1885          *
   1886          *
   1887          ******************************************************************************/
   1888          static bool_t IsQueueFull(void)
   1889          {
   1890            if((mQueue.head == mQueue.tail)&&
   1891               (mQueue.opLine[mQueue.head].opQueue   != mEmptyQueue_c)&&
   1892               (mQueue.opLine[mQueue.head].lineQueue != mEmptyQueue_c))
   1893            {
   1894              return TRUE;   
   1895            }
   1896            else
   1897            {
   1898              return FALSE;
   1899            }  
   1900          }  
   1901          
   1902          #endif /* (gLCDSupported_d == 1) */


 
 
 0 bytes of memory

Errors: none
Warnings: none
