###############################################################################
#                                                                             #
#                                                       08/Dec/2015  22:02:17 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Source\MApp.c                        #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Source\MApp.c" -D                    #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\" -lC "C:\Documents and               #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\List\" -lB "C:\Documents and   #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\List\" --diag_suppress         #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\Obj\" --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MacPhy\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Init\" -I "C:\Documents  #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Interface\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Configure\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\UartUtil\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\TS\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\SSM\TS\Source\" -I "C:\Documents     #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and         #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\SSM\ZTC\Source\" -I "C:\Documents    #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Interface\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\LibInterface\" -I "C:\Documents  #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Display\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\Source\Keyboard\" -I             #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\NVM\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\Source\TMR\" -I "C:\Documents    #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR       #
#                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"      #
#                    --interwork --cpu_mode thumb -On                         #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\MApp.lst                              #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\Obj\MApp.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\Application\Source\MApp.c
      1          /*****************************************************************************
      2          * MyWirelessApp Demo Non Beacon End Device application.
      3          *
      4          * (c) Copyright 2008, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          
     13          #include "MApp.h"
     14          #include "NVM_Interface.h"
     15          
     16          /************************************************************************************
     17          *************************************************************************************
     18          * Private macros
     19          *************************************************************************************
     20          ************************************************************************************/
     21          
     22          /* If there are too many pending packets to be send over the air, */
     23          /* receive mMaxKeysToReceive_c chars. */
     24          /* The chars will be send over the air when there are no pending packets*/
     25          #define mMaxKeysToReceive_c 32
     26          
     27          /************************************************************************************
     28          *************************************************************************************
     29          * Private prototypes
     30          *************************************************************************************
     31          ************************************************************************************/
     32          
     33          /* Forward declarations of helper functions */
     34          static void    UartRxCallBack(void);
     35          static uint8_t App_StartScan(uint8_t scanType);
     36          static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
     37          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
     38          static uint8_t App_SendAssociateRequest(void);
     39          static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
     40          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
     41          static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
     42          static void    App_TransmitUartData(void);
     43          static void    AppPollWaitTimeout(uint8_t tmr);
     44          static void    App_HandleKeys( key_event_t events );
     45          static uint8_t App_SetParam(uint8_t attribute, uint8_t *pValue);
     46          static uint8_t App_GetParam(uint8_t attribute, uint8_t *pValue);
     47          
     48          /************************************************************************************
     49          *************************************************************************************
     50          * Private type definitions
     51          *************************************************************************************
     52          ************************************************************************************/
     53          
     54          
     55          /************************************************************************************
     56          *************************************************************************************
     57          * Private memory declarations
     58          *************************************************************************************
     59          ************************************************************************************/
     60          
     61          /* Information about the PAN we are part of */

   \                                 In section .bss, align 4
     62          static panDescriptor_t mCoordInfo;
   \                     mCoordInfo:
   \   00000000                      DS8 24
     63          
     64          /* This is either the short address assigned by the PAN coordinator
     65             during association, or our own extended MAC address. */

   \                                 In section .bss, align 4
     66          static uint8_t maMyAddress[8];
   \                     maMyAddress:
   \   00000000                      DS8 8
     67          /* The devices address mode. If 2, then maMyAddress contains the short
     68             address assigned by the PAN coordinator. If 3, then maMyAddress is
     69             equal to the extended address. */

   \                                 In section .bss, align 1
     70          static uint8_t mAddrMode;
   \                     mAddrMode:
   \   00000000                      DS8 1
     71          
     72          /* Data request packet for sending UART input to the coordinator */

   \                                 In section .bss, align 4
     73          static nwkToMcpsMessage_t *mpPacket;
   \                     mpPacket:
   \   00000000                      DS8 4
     74          
     75          /* The MSDU handle is a unique data packet identifier */

   \                                 In section .bss, align 1
     76          static uint8_t mMsduHandle;
   \                     mMsduHandle:
   \   00000000                      DS8 1
     77          
     78          /* Number of pending data packets */

   \                                 In section .bss, align 1
     79          static uint8_t mcPendingPackets;
   \                     mcPendingPackets:
   \   00000000                      DS8 1
     80          
     81          /* Signals that an MLME-Poll request is pending, and that we must wait for 
     82             the MLME-Poll confirm message before sending the next poll request. */

   \                                 In section .bss, align 1
     83          static bool_t mWaitPollConfirm;
   \                     mWaitPollConfirm:
   \   00000000                      DS8 1
     84          
     85          //WSNProject

   \                                 In section .bss, align 1
     86          static bool_t dataSet;
   \                     dataSet:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     87          static bool_t dataGet;
   \                     dataGet:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     88          static uint8_t dataUGet;
   \                     dataUGet:
   \   00000000                      DS8 1
     89          
     90          /* Time between MLME-Poll requests */

   \                                 In section .bss, align 2
     91          static uint16_t mPollInterval;
   \                     mPollInterval:
   \   00000000                      DS8 2
     92          
     93          /* Application input queues */

   \                                 In section .bss, align 4
     94          static anchor_t mMlmeNwkInputQueue;
   \                     mMlmeNwkInputQueue:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     95          static anchor_t mMcpsNwkInputQueue;
   \                     mMcpsNwkInputQueue:
   \   00000000                      DS8 8
     96          

   \                                 In section .data, align 1
     97          static tmrTimerID_t mTimer_c = gTmrInvalidTimerID_c;
   \                     mTimer_c:
   \   00000000   FF                 DC8 255
     98          
     99          /************************************************************************************
    100          *************************************************************************************
    101          * Public memory declarations
    102          *************************************************************************************
    103          ************************************************************************************/
    104          
    105          /* The current state of the applications state machine */

   \                                 In section .bss, align 1
    106          uint8_t gState;
   \                     gState:
   \   00000000                      DS8 1
    107          
    108          /* This data set contains application variables to be preserved across resets */

   \                                 In section .rodata, align 4
    109          NvDataItemDescription_t const gaNvAppDataSet[] = {
   \                     gaNvAppDataSet:
   \   00000000   00000000           DC32 0H
   \   00000004   0000               DC16 0
   \   00000006   0000               DC8 0, 0
    110            {NULL, 0}       /* Required end-of-table marker. */
    111          };
    112          
    113          /************************************************************************************
    114          *************************************************************************************
    115          * Public functions
    116          *************************************************************************************
    117          ************************************************************************************/
    118          
    119          void DeepSleepWakeupStackProc(void);
    120          
    121          /*****************************************************************************
    122          * Initialization function for the App Task. This is called during
    123          * initialization and should contain any application specific initialization
    124          * (ie. hardware initialization/setup, table initialization, power up
    125          * notificaiton.
    126          *
    127          * Interface assumptions: None
    128          *
    129          * Return value: None
    130          *
    131          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          void MApp_init(void)
    133          { 
   \                     MApp_init:
   \   00000000   80B5               PUSH     {R7,LR}
    134            
    135            /* The initial application state */
    136            gState = stateInit;  
   \   00000002   ....               LDR      R0,??DataTable0
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
    137            /* Reset number of pending packets */
    138            mcPendingPackets = 0;
   \   00000008   ....               LDR      R0,??DataTable0_1
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0170               STRB     R1,[R0, #+0]
    139            
    140            /* Allow sending a poll request */  
    141            mWaitPollConfirm = FALSE;    
   \   0000000E   ....               LDR      R0,??DataTable0_2
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   0170               STRB     R1,[R0, #+0]
    142            
    143            /* Initialize the poll interval */
    144            mPollInterval = mDefaultValueOfPollIntervalSlow_c;
   \   00000014   ....               LDR      R0,??DataTable0_3
   \   00000016   CD21               MOVS     R1,#+205
   \   00000018   8900               LSLS     R1,R1,#+2        ;; #+820
   \   0000001A   0180               STRH     R1,[R0, #+0]
    145          
    146            /* Initialize the MAC 802.15.4 extended address */
    147            Init_MacExtendedAddress();
   \   0000001C   ........           BL       Init_MacExtendedAddress
    148            mTimer_c = TMR_AllocateTimer();
   \   00000020   ........           BL       TMR_AllocateTimer
   \   00000024   ....               LDR      R1,??DataTable0_4
   \   00000026   0870               STRB     R0,[R1, #+0]
    149            /* register keyboard callback function */
    150            KBD_Init(App_HandleKeys);
   \   00000028   ....               LDR      R0,??DataTable0_5
   \   0000002A   ........           BL       KBD_Init
    151            /* initialize LCD Module */
    152            LCD_Init();
    153            /* initialize LED Module */
    154            LED_Init();
   \   0000002E   ........           BL       LED_Init
    155            /* Initialize the UART so that we can print out status messages */
    156            UartX_SetBaud(gUartDefaultBaud_c);
   \   00000032   9620               MOVS     R0,#+150
   \   00000034   C001               LSLS     R0,R0,#+7        ;; #+19200
   \   00000036   ........           BL       Uart1_SetBaud
    157            UartX_SetRxCallBack(UartRxCallBack);
   \   0000003A   ....               LDR      R0,??DataTable0_6
   \   0000003C   ........           BL       Uart1_SetRxCallBack
    158            /* Prepare input queues.*/
    159            MSG_InitQueue(&mMlmeNwkInputQueue); 
   \   00000040   ....               LDR      R0,??DataTable0_7
   \   00000042   ........           BL       List_ClearAnchor
    160            MSG_InitQueue(&mMcpsNwkInputQueue);
   \   00000046   ....               LDR      R0,??DataTable0_8
   \   00000048   ........           BL       List_ClearAnchor
    161            /* Enable MCU interrupts */
    162            IntEnableAll();
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   ........           BL       IntRestoreAll
    163            /*signal app ready*/  
    164            Led1Flashing();
   \   00000052   0120               MOVS     R0,#+1
   \   00000054   ........           BL       LED_StartFlash
    165            Led2Flashing();
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   ........           BL       LED_StartFlash
    166            Led3Flashing();
   \   0000005E   0420               MOVS     R0,#+4
   \   00000060   ........           BL       LED_StartFlash
    167            Led4Flashing();
   \   00000064   0820               MOVS     R0,#+8
   \   00000066   ........           BL       LED_StartFlash
    168              
    169            UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
   \   0000006A   0121               MOVS     R1,#+1
   \   0000006C   ....               LDR      R0,??DataTable0_9
   \   0000006E   ........           BL       UartUtil_Print
    170            LCD_ClearDisplay();
    171            LCD_WriteString(1,"Press any key");
   \   00000072   ....               LDR      R0,??DataTable0_10
    172            LCD_WriteString(2,"to start.");
   \   00000074   ....               LDR      R0,??DataTable2
    173          }
   \   00000076   09BC               POP      {R0,R3}
   \   00000078   1847               BX       R3               ;; return
    174          
    175          /*****************************************************************************
    176          *Mac Application Task event processor.  This function is called to
    177          * process all events for the task. Events include timers, messages and any
    178          * other user defined events
    179          *
    180          * Interface assumptions: None
    181          *
    182          * Return value: None
    183          *****************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    184          void AppTask(event_t events) 
    185          { 
   \                     AppTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    186          
    187            /* Pointer for storing the messages from MLME, MCPS, and ASP. */
    188            void *pMsgIn;
    189            /* Stores the status code returned by some functions. */
    190            uint8_t rc;  
    191            pMsgIn = NULL;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
    192            
    193            /* Dequeue the MLME message */
    194            if (events & gAppEvtMessageFromMLME_c)
   \   00000008   7007               LSLS     R0,R6,#+29
   \   0000000A   1DD5               BPL      ??AppTask_0
    195            {
    196              /* Get the message from MLME */
    197              pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
   \   0000000C   ....               LDR      R0,??DataTable2_1
   \   0000000E   ........           BL       List_RemoveHead
   \   00000012   0400               MOVS     R4,R0
    198              
    199              /* Any time a beacon might arrive. Always handle the beacon frame first */
    200              if (pMsgIn)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   17D0               BEQ      ??AppTask_0
    201              {               
    202                rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
   \   00000018   0421               MOVS     R1,#+4
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       App_WaitMsg
   \   00000020   0500               MOVS     R5,R0
    203                if(rc == errorNoError)
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   002D               CMP      R5,#+0
   \   00000028   0ED1               BNE      ??AppTask_0
    204                {
    205                  /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
    206                  /* ALSO the application can use the beacon payload.*/
    207                  MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   1030               ADDS     R0,R0,#+16
   \   0000002E   ........           BL       __aeabi_uread4
   \   00000032   ........           BL       MM_Free
   \   00000036   2100               MOVS     R1,R4
   \   00000038   1031               ADDS     R1,R1,#+16
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   ........           BL       __aeabi_uwrite4
    208                  UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ....               LDR      R0,??DataTable2_2
   \   00000044   ........           BL       UartUtil_Print
    209                }
    210              }
    211            }
    212            
    213            /* The application state machine */
    214            switch(gState)
   \                     ??AppTask_0:
   \   00000048   ....               LDR      R0,??DataTable1
   \   0000004A   0078               LDRB     R0,[R0, #+0]
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   0BD0               BEQ      ??AppTask_1
   \   00000050   0228               CMP      R0,#+2
   \   00000052   29D0               BEQ      ??AppTask_2
   \   00000054   15D3               BCC      ??AppTask_3
   \   00000056   0428               CMP      R0,#+4
   \   00000058   00D1               BNE      .+4
   \   0000005A   A9E0               B        ??AppTask_4
   \   0000005C   00D2               BCS      .+4
   \   0000005E   90E0               B        ??AppTask_5
   \   00000060   0528               CMP      R0,#+5
   \   00000062   00D1               BNE      .+4
   \   00000064   F4E0               B        ??AppTask_6
   \   00000066   01E1               B        ??AppTask_7
    215            {
    216            case stateInit:    
    217              /* Print a welcome message to the UART */
    218              UartUtil_Print("MyWirelessApp Demo Non Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
   \                     ??AppTask_1:
   \   00000068   0121               MOVS     R1,#+1
   \   0000006A   ....               LDR      R0,??DataTable3
   \   0000006C   ........           BL       UartUtil_Print
    219              /* Goto Active Scan state. */
    220              gState = stateScanActiveStart;
   \   00000070   ....               LDR      R0,??DataTable1
   \   00000072   0121               MOVS     R1,#+1
   \   00000074   0170               STRB     R1,[R0, #+0]
    221              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
   \   00000076   0121               MOVS     R1,#+1
   \   00000078   ....               LDR      R0,??DataTable3_1
   \   0000007A   0078               LDRB     R0,[R0, #+0]
   \   0000007C   ........           BL       TS_SendEvent
   \   00000080   F4E0               B        ??AppTask_7
    222              break;
    223              
    224            case stateScanActiveStart:
    225              /* Start the Active scan, and goto wait for confirm state. */
    226              UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
   \                     ??AppTask_3:
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   7148               LDR      R0,??AppTask_8
   \   00000086   ........           BL       UartUtil_Print
    227              /*print a message on the LCD also*/
    228              LCD_ClearDisplay();
    229              LCD_WriteString(1,"Start scanning");
   \   0000008A   8E48               LDR      R0,??AppTask_9
    230              LCD_WriteString(2,"for coordinator");  
   \   0000008C   ....               LDR      R0,??DataTable1_1
    231              rc = App_StartScan(gScanModeActive_c);
   \   0000008E   0120               MOVS     R0,#+1
   \   00000090   ........           BL       App_StartScan
   \   00000094   0500               MOVS     R5,R0
    232              if(rc == errorNoError)
   \   00000096   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000098   2D0E               LSRS     R5,R5,#+24
   \   0000009A   002D               CMP      R5,#+0
   \   0000009C   00D0               BEQ      .+4
   \   0000009E   E5E0               B        ??AppTask_7
    233              {
    234                gState = stateScanActiveWaitConfirm;
   \   000000A0   ....               LDR      R0,??DataTable1
   \   000000A2   0221               MOVS     R1,#+2
   \   000000A4   0170               STRB     R1,[R0, #+0]
   \   000000A6   E1E0               B        ??AppTask_7
    235              }
    236              break;
    237              
    238            case stateScanActiveWaitConfirm:
    239              /* Stay in this state until the Scan confirm message
    240                 arrives, and then goto the associate state. */
    241              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_2:
   \   000000A8   7007               LSLS     R0,R6,#+29
   \   000000AA   00D4               BMI      .+4
   \   000000AC   DEE0               B        ??AppTask_7
    242              {
    243                if (pMsgIn)
   \   000000AE   002C               CMP      R4,#+0
   \   000000B0   00D1               BNE      .+4
   \   000000B2   DBE0               B        ??AppTask_7
    244                {                     
    245                  rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
   \   000000B4   0B21               MOVS     R1,#+11
   \   000000B6   2000               MOVS     R0,R4
   \   000000B8   ........           BL       App_WaitMsg
   \   000000BC   0500               MOVS     R5,R0
    246                  if(rc == errorNoError)
   \   000000BE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000C0   2D0E               LSRS     R5,R5,#+24
   \   000000C2   002D               CMP      R5,#+0
   \   000000C4   00D0               BEQ      .+4
   \   000000C6   D1E0               B        ??AppTask_7
    247                  {
    248                    rc = App_HandleScanActiveConfirm(pMsgIn);
   \   000000C8   2000               MOVS     R0,R4
   \   000000CA   ........           BL       App_HandleScanActiveConfirm
   \   000000CE   0500               MOVS     R5,R0
    249                    if(rc == errorNoError)
   \   000000D0   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000D2   2D0E               LSRS     R5,R5,#+24
   \   000000D4   002D               CMP      R5,#+0
   \   000000D6   4DD1               BNE      ??AppTask_10
    250                    {
    251                      UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
   \   000000D8   0121               MOVS     R1,#+1
   \   000000DA   ....               LDR      R0,??DataTable2_3
   \   000000DC   ........           BL       UartUtil_Print
    252                      UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
   \   000000E0   0121               MOVS     R1,#+1
   \   000000E2   ....               LDR      R0,??DataTable2_4
   \   000000E4   ........           BL       UartUtil_Print
    253                      UartUtil_Print("\n\rAddress...........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
   \   000000E8   0121               MOVS     R1,#+1
   \   000000EA   ....               LDR      R0,??DataTable2_5
   \   000000EC   ........           BL       UartUtil_Print
   \   000000F0   ....               LDR      R0,??DataTable2_6
   \   000000F2   807A               LDRB     R0,[R0, #+10]
   \   000000F4   0228               CMP      R0,#+2
   \   000000F6   01D1               BNE      ??AppTask_11
   \   000000F8   0221               MOVS     R1,#+2
   \   000000FA   00E0               B        ??AppTask_12
   \                     ??AppTask_11:
   \   000000FC   0821               MOVS     R1,#+8
   \                     ??AppTask_12:
   \   000000FE   0022               MOVS     R2,#+0
   \   00000100   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000102   090E               LSRS     R1,R1,#+24
   \   00000104   ....               LDR      R0,??DataTable2_6
   \   00000106   ........           BL       UartUtil_PrintHex
    254                      UartUtil_Print("\n\rPAN ID............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
   \   0000010A   0121               MOVS     R1,#+1
   \   0000010C   ....               LDR      R0,??DataTable2_7
   \   0000010E   ........           BL       UartUtil_Print
   \   00000112   0022               MOVS     R2,#+0
   \   00000114   0221               MOVS     R1,#+2
   \   00000116   ....               LDR      R0,??DataTable2_6
   \   00000118   0830               ADDS     R0,R0,#+8
   \   0000011A   ........           BL       UartUtil_PrintHex
    255                      UartUtil_Print("\n\rLogical Channel...0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
   \   0000011E   0121               MOVS     R1,#+1
   \   00000120   ....               LDR      R0,??DataTable3_2
   \   00000122   ........           BL       UartUtil_Print
   \   00000126   0022               MOVS     R2,#+0
   \   00000128   0121               MOVS     R1,#+1
   \   0000012A   ....               LDR      R0,??DataTable2_6
   \   0000012C   0B30               ADDS     R0,R0,#+11
   \   0000012E   ........           BL       UartUtil_PrintHex
    256                      UartUtil_Print("\n\rBeacon Spec.......0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
   \   00000132   0121               MOVS     R1,#+1
   \   00000134   ....               LDR      R0,??DataTable3_3
   \   00000136   ........           BL       UartUtil_Print
   \   0000013A   0022               MOVS     R2,#+0
   \   0000013C   0221               MOVS     R1,#+2
   \   0000013E   ....               LDR      R0,??DataTable2_6
   \   00000140   0F30               ADDS     R0,R0,#+15
   \   00000142   ........           BL       UartUtil_PrintHex
    257                      UartUtil_Print("\n\rLink Quality......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
   \   00000146   0121               MOVS     R1,#+1
   \   00000148   ....               LDR      R0,??DataTable3_4
   \   0000014A   ........           BL       UartUtil_Print
   \   0000014E   0022               MOVS     R2,#+0
   \   00000150   0121               MOVS     R1,#+1
   \   00000152   ....               LDR      R0,??DataTable2_6
   \   00000154   1230               ADDS     R0,R0,#+18
   \   00000156   ........           BL       UartUtil_PrintHex
    258                      UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
   \   0000015A   0121               MOVS     R1,#+1
   \   0000015C   ....               LDR      R0,??DataTable3_5
   \   0000015E   ........           BL       UartUtil_Print
    259          
    260                      gState = stateAssociate;
   \   00000162   ....               LDR      R0,??DataTable1
   \   00000164   0321               MOVS     R1,#+3
   \   00000166   0170               STRB     R1,[R0, #+0]
    261                      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   00000168   0121               MOVS     R1,#+1
   \   0000016A   ....               LDR      R0,??DataTable3_1
   \   0000016C   0078               LDRB     R0,[R0, #+0]
   \   0000016E   ........           BL       TS_SendEvent
   \   00000172   7BE0               B        ??AppTask_7
    262                    }
    263                    else
    264          		      {
    265                      UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
   \                     ??AppTask_10:
   \   00000174   0121               MOVS     R1,#+1
   \   00000176   ....               LDR      R0,??DataTable3_6
   \   00000178   ........           BL       UartUtil_Print
    266                      /*print a message on the LCD also*/
    267                      LCD_ClearDisplay();
    268                      LCD_WriteString(1,"No coordinator");
   \   0000017C   ....               LDR      R0,??DataTable3_7
    269                      LCD_WriteString(2,"found.");
   \   0000017E   ....               LDR      R0,??DataTable3_8
   \   00000180   74E0               B        ??AppTask_7
    270          		      }
    271          		    }
    272                }
    273              }
    274              break;
    275          
    276            case stateAssociate:
    277              /* Associate to the PAN coordinator */
    278              UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
   \                     ??AppTask_5:
   \   00000182   0121               MOVS     R1,#+1
   \   00000184   ....               LDR      R0,??DataTable3_9
   \   00000186   ........           BL       UartUtil_Print
    279              UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
   \   0000018A   0222               MOVS     R2,#+2
   \   0000018C   0121               MOVS     R1,#+1
   \   0000018E   ....               LDR      R0,??DataTable2_6
   \   00000190   0B30               ADDS     R0,R0,#+11
   \   00000192   ........           BL       UartUtil_PrintHex
    280              /*print a message on the LCD also*/
    281              LCD_ClearDisplay();
    282              LCD_WriteString(1,"Associating to ");
   \   00000196   ....               LDR      R0,??DataTable3_10
    283              LCD_WriteString(2,"PAN coordinator");  
   \   00000198   ....               LDR      R0,??DataTable3_11
    284              rc = App_SendAssociateRequest();
   \   0000019A   ........           BL       App_SendAssociateRequest
   \   0000019E   0500               MOVS     R5,R0
    285              if(rc == errorNoError)
   \   000001A0   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001A2   2D0E               LSRS     R5,R5,#+24
   \   000001A4   002D               CMP      R5,#+0
   \   000001A6   61D1               BNE      ??AppTask_7
    286                gState = stateAssociateWaitConfirm;
   \   000001A8   ....               LDR      R0,??DataTable1
   \   000001AA   0421               MOVS     R1,#+4
   \   000001AC   0170               STRB     R1,[R0, #+0]
   \   000001AE   5DE0               B        ??AppTask_7
    287              break; 
    288          
    289            case stateAssociateWaitConfirm:
    290              /* Stay in this state until the Associate confirm message
    291                 arrives, and then goto the Listen state. */
    292              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_4:
   \   000001B0   7007               LSLS     R0,R6,#+29
   \   000001B2   5BD5               BPL      ??AppTask_7
    293              {
    294                if (pMsgIn)
   \   000001B4   002C               CMP      R4,#+0
   \   000001B6   59D0               BEQ      ??AppTask_7
    295                {   
    296                  rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);
   \   000001B8   0121               MOVS     R1,#+1
   \   000001BA   2000               MOVS     R0,R4
   \   000001BC   ........           BL       App_WaitMsg
   \   000001C0   0500               MOVS     R5,R0
    297                  if(rc == errorNoError)
   \   000001C2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001C4   2D0E               LSRS     R5,R5,#+24
   \   000001C6   002D               CMP      R5,#+0
   \   000001C8   50D1               BNE      ??AppTask_7
    298                  {          
    299                    rc = App_HandleAssociateConfirm(pMsgIn);
   \   000001CA   2000               MOVS     R0,R4
   \   000001CC   ........           BL       App_HandleAssociateConfirm
   \   000001D0   0500               MOVS     R5,R0
    300                    if (rc == errorNoError)
   \   000001D2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001D4   2D0E               LSRS     R5,R5,#+24
   \   000001D6   002D               CMP      R5,#+0
   \   000001D8   2AD1               BNE      ??AppTask_13
    301                    { 
    302          	          UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
   \   000001DA   0121               MOVS     R1,#+1
   \   000001DC   ....               LDR      R0,??DataTable4
   \   000001DE   ........           BL       UartUtil_Print
    303          	          UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
   \   000001E2   0121               MOVS     R1,#+1
   \   000001E4   ....               LDR      R0,??DataTable4_1
   \   000001E6   ........           BL       UartUtil_Print
    304          	          UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
   \   000001EA   ....               LDR      R0,??DataTable4_2
   \   000001EC   0078               LDRB     R0,[R0, #+0]
   \   000001EE   0228               CMP      R0,#+2
   \   000001F0   01D1               BNE      ??AppTask_14
   \   000001F2   0221               MOVS     R1,#+2
   \   000001F4   00E0               B        ??AppTask_15
   \                     ??AppTask_14:
   \   000001F6   0821               MOVS     R1,#+8
   \                     ??AppTask_15:
   \   000001F8   0022               MOVS     R2,#+0
   \   000001FA   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001FC   090E               LSRS     R1,R1,#+24
   \   000001FE   ....               LDR      R0,??DataTable4_3
   \   00000200   ........           BL       UartUtil_PrintHex
    305          	          UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
   \   00000204   0121               MOVS     R1,#+1
   \   00000206   ....               LDR      R0,??DataTable4_4
   \   00000208   ........           BL       UartUtil_Print
    306          	          /*print a message on the LCD also*/
    307          	          LCD_ClearDisplay();
    308          	          LCD_WriteString(1,"Ready to send");
   \   0000020C   ....               LDR      R0,??DataTable5
    309          	          LCD_WriteString(2,"and receive data");    
   \   0000020E   ....               LDR      R0,??DataTable5_1
    310          	          /* Startup the timer */
    311          	          TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
   \   00000210   ....               LDR      R2,??DataTable5_2
   \   00000212   ....               LDR      R0,??DataTable5_3
   \   00000214   0188               LDRH     R1,[R0, #+0]
   \   00000216   ....               LDR      R0,??DataTable5_4
   \   00000218   0078               LDRB     R0,[R0, #+0]
   \   0000021A   ........           BL       TMR_StartSingleShotTimer
    312          	          /* Go to the listen state */
    313          	          gState = stateListen;
   \   0000021E   ....               LDR      R0,??DataTable1
   \   00000220   0521               MOVS     R1,#+5
   \   00000222   0170               STRB     R1,[R0, #+0]
    314          	          TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c); 
   \   00000224   0121               MOVS     R1,#+1
   \   00000226   ....               LDR      R0,??DataTable3_1
   \   00000228   0078               LDRB     R0,[R0, #+0]
   \   0000022A   ........           BL       TS_SendEvent
   \   0000022E   1DE0               B        ??AppTask_7
    315                    }        
    316                    else 
    317                    {
    318                    
    319          	          UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
   \                     ??AppTask_13:
   \   00000230   0121               MOVS     R1,#+1
   \   00000232   ....               LDR      R0,??DataTable5_5
   \   00000234   ........           BL       UartUtil_Print
    320          	          gState = stateScanActiveStart;
   \   00000238   ....               LDR      R0,??DataTable1
   \   0000023A   0121               MOVS     R1,#+1
   \   0000023C   0170               STRB     R1,[R0, #+0]
    321                        TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   0000023E   0121               MOVS     R1,#+1
   \   00000240   ....               LDR      R0,??DataTable3_1
   \   00000242   0078               LDRB     R0,[R0, #+0]
   \   00000244   ........           BL       TS_SendEvent
   \   00000248   10E0               B        ??AppTask_7
   \   0000024A   C046               Nop      
   \                     ??AppTask_8:
   \   0000024C   ........           DC32     `?<Constant "Start scanning for a ...">`
    322                    }
    323                  }
    324                }
    325              }
    326              break; 
    327              
    328            case stateListen:
    329              
    330              //WSNProject: necessario da aggiungere perché negli state precedenti "disallow"
    331              //è stato chiamato (uniche due PWR function che si possono chiamare nel main)
    332              PWR_AllowDeviceToSleep();
   \                     ??AppTask_6:
   \   00000250   ........           BL       PWR_AllowDeviceToSleep
    333              
    334              /* Transmit to coordinator data received from UART. */
    335              if (events & gAppEvtMessageFromMLME_c)
   \   00000254   7007               LSLS     R0,R6,#+29
   \   00000256   05D5               BPL      ??AppTask_16
    336              {  
    337                if (pMsgIn)
   \   00000258   002C               CMP      R4,#+0
   \   0000025A   03D0               BEQ      ??AppTask_16
    338                {  
    339                  /* Process it */
    340                  rc = App_HandleMlmeInput(pMsgIn);
   \   0000025C   2000               MOVS     R0,R4
   \   0000025E   ........           BL       App_HandleMlmeInput
   \   00000262   0500               MOVS     R5,R0
    341                }
    342              } 
    343              
    344              if (events & gAppEvtRxFromUart_c)
   \                     ??AppTask_16:
   \   00000264   B007               LSLS     R0,R6,#+30
   \   00000266   01D5               BPL      ??AppTask_7
    345              {      
    346                /* get byte from UART */
    347                App_TransmitUartData();
   \   00000268   ........           BL       App_TransmitUartData
    348              
    349              }  
    350              break;
    351            }
    352            
    353            if (pMsgIn)
   \                     ??AppTask_7:
   \   0000026C   002C               CMP      R4,#+0
   \   0000026E   04D0               BEQ      ??AppTask_17
    354            {
    355              /* Messages must always be freed. */ 
    356              MSG_Free(pMsgIn);
   \   00000270   2000               MOVS     R0,R4
   \   00000272   ........           BL       MM_Free
   \   00000276   0020               MOVS     R0,#+0
   \   00000278   0400               MOVS     R4,R0
    357            }
    358            
    359             /* Handle MCPS confirms and transmit data from UART */
    360            if (events & gAppEvtMessageFromMCPS_c)
   \                     ??AppTask_17:
   \   0000027A   3007               LSLS     R0,R6,#+28
   \   0000027C   0DD5               BPL      ??AppTask_18
    361            {      
    362              /* Get the message from MCPS */
    363              pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
   \   0000027E   ....               LDR      R0,??DataTable7
   \   00000280   ........           BL       List_RemoveHead
   \   00000284   0400               MOVS     R4,R0
    364              if (pMsgIn)
   \   00000286   002C               CMP      R4,#+0
   \   00000288   07D0               BEQ      ??AppTask_18
    365              {              
    366                /* Process it */
    367                App_HandleMcpsInput(pMsgIn);
   \   0000028A   2000               MOVS     R0,R4
   \   0000028C   ........           BL       App_HandleMcpsInput
    368                /* Messages from the MCPS must always be freed. */
    369                MSG_Free(pMsgIn);
   \   00000290   2000               MOVS     R0,R4
   \   00000292   ........           BL       MM_Free
   \   00000296   0020               MOVS     R0,#+0
   \   00000298   0400               MOVS     R4,R0
    370              }
    371            }
    372            //verifica già fatta: una volta che il nodo va in state sleep
    373            //POTREBBE entrare in SleepMode
    374            //(ma di fatto non lo fa)
    375            /*
    376            if(PWR_CheckIfDeviceCanGoToSleep())
    377              UartUtil_Print("Rx can go to sleep\n\r", gAllowToBlock_d);
    378            else
    379              UartUtil_Print("Cannot...\n\r", gAllowToBlock_d);*/
    380            //WSNProject: non ha senso andare in idle task con un evento, non può funzionare
    381            //TS_SendEvent(gIdleTaskID, gTsIdleTaskID_c);
    382            /* Check for pending messages in the Queue */ 
    383            if(MSG_Pending(&mMcpsNwkInputQueue))
   \                     ??AppTask_18:
   \   0000029A   ....               LDR      R0,??DataTable7
   \   0000029C   0068               LDR      R0,[R0, #+0]
   \   0000029E   0028               CMP      R0,#+0
   \   000002A0   04D0               BEQ      ??AppTask_19
    384              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   000002A2   0821               MOVS     R1,#+8
   \   000002A4   ....               LDR      R0,??DataTable3_1
   \   000002A6   0078               LDRB     R0,[R0, #+0]
   \   000002A8   ........           BL       TS_SendEvent
    385            if(MSG_Pending(&mMlmeNwkInputQueue))
   \                     ??AppTask_19:
   \   000002AC   ....               LDR      R0,??DataTable2_1
   \   000002AE   0068               LDR      R0,[R0, #+0]
   \   000002B0   0028               CMP      R0,#+0
   \   000002B2   04D0               BEQ      ??AppTask_20
    386              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
   \   000002B4   0421               MOVS     R1,#+4
   \   000002B6   ....               LDR      R0,??DataTable3_1
   \   000002B8   0078               LDRB     R0,[R0, #+0]
   \   000002BA   ........           BL       TS_SendEvent
    387          }
   \                     ??AppTask_20:
   \   000002BE   70BC               POP      {R4-R6}
   \   000002C0   08BC               POP      {R3}
   \   000002C2   1847               BX       R3               ;; return
   \                     ??AppTask_9:
   \   000002C4   ........           DC32     `?<Constant "Start scanning">`
    388          
    389          /************************************************************************************
    390          *************************************************************************************
    391          * Private functions
    392          *************************************************************************************
    393          ************************************************************************************/
    394          
    395          /*****************************************************************************
    396          * UartRxCallBack
    397          *
    398          * This callback is triggered when a new byte is received over the UART
    399          *
    400          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    401          static void UartRxCallBack(void) 
    402          {
   \                     UartRxCallBack:
   \   00000000   80B5               PUSH     {R7,LR}
    403            uint8_t pressedKey;
    404          	if(stateListen == gState){
   \   00000002   ....               LDR      R0,??DataTable8
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0528               CMP      R0,#+5
   \   00000008   05D1               BNE      ??UartRxCallBack_0
    405              TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   ....               LDR      R0,??DataTable3_1
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   ........           BL       TS_SendEvent
   \   00000014   02E0               B        ??UartRxCallBack_1
    406            }else{
    407          	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
   \                     ??UartRxCallBack_0:
   \   00000016   6846               MOV      R0,SP
   \   00000018   ........           BL       Uart1_GetByteFromRxBuffer
    408            }
    409          }
   \                     ??UartRxCallBack_1:
   \   0000001C   09BC               POP      {R0,R3}
   \   0000001E   1847               BX       R3               ;; return
    410          
    411          /******************************************************************************
    412          * The App_StartScan(scanType) function will start the scan process of the
    413          * specified type in the MAC. This is accomplished by allocating a MAC message,
    414          * which is then assigned the desired scan parameters and sent to the MLME
    415          * service access point.
    416          * The function may return either of the following values:
    417          *   errorNoError:          The Scan message was sent successfully.
    418          *   errorInvalidParameter: The MLME service access point rejected the
    419          *                          message due to an invalid parameter.
    420          *   errorAllocFailed:      A message buffer could not be allocated.
    421          *
    422          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          static uint8_t App_StartScan(uint8_t scanType)
    424          {
   \                     App_StartScan:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    425            mlmeMessage_t *pMsg;
    426            mlmeScanReq_t *pScanReq;
    427          
    428            UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   ....               LDR      R0,??DataTable8_1
   \   00000008   ........           BL       UartUtil_Print
    429          
    430            /* Allocate a message for the MLME (We should check for NULL). */
    431            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000C   0F20               MOVS     R0,#+15
   \   0000000E   ........           BL       MM_Alloc
   \   00000012   0400               MOVS     R4,R0
    432            if(pMsg != NULL)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   20D0               BEQ      ??App_StartScan_0
    433            {
    434              /* This is a MLME-SCAN.req command */
    435              pMsg->msgType = gMlmeScanReq_c;
   \   00000018   0820               MOVS     R0,#+8
   \   0000001A   2070               STRB     R0,[R4, #+0]
    436              /* Create the Scan request message data. */
    437              pScanReq = &pMsg->msgData.scanReq;
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   0500               MOVS     R5,R0
    438              /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
    439              pScanReq->scanType = scanType;
   \   00000022   2E70               STRB     R6,[R5, #+0]
    440              /* ChannelsToScan & 0xFF - LSB, always 0x00 */
    441              pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   6870               STRB     R0,[R5, #+1]
    442              /* ChannelsToScan>>8 & 0xFF  */
    443              pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
   \   00000028   F820               MOVS     R0,#+248
   \   0000002A   A870               STRB     R0,[R5, #+2]
    444              /* ChannelsToScan>>16 & 0xFF  */
    445              pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
   \   0000002C   FF20               MOVS     R0,#+255
   \   0000002E   E870               STRB     R0,[R5, #+3]
    446              /* ChannelsToScan>>24 & 0xFF - MSB */
    447              pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
   \   00000030   0720               MOVS     R0,#+7
   \   00000032   2871               STRB     R0,[R5, #+4]
    448              /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
    449                 A scan duration of 3 on 16 channels approximately takes 2 secs. */
    450              pScanReq->scanDuration = 3;
   \   00000034   0320               MOVS     R0,#+3
   \   00000036   6871               STRB     R0,[R5, #+5]
    451          #ifdef gMAC2006_d
    452          	pScanReq->securityLevel = 0;
    453          #endif //gMAC2006_d	
    454              
    455              /* Send the Scan request to the MLME. */
    456              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       NWK_MLME_SapHandler
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   05D1               BNE      ??App_StartScan_1
    457              {
    458                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000042   0121               MOVS     R1,#+1
   \   00000044   ....               LDR      R0,??DataTable8_2
   \   00000046   ........           BL       UartUtil_Print
    459                return errorNoError;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   0AE0               B        ??App_StartScan_2
    460              }
    461              else
    462              {
    463                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_1:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR      R0,??DataTable8_3
   \   00000052   ........           BL       UartUtil_Print
    464                return errorInvalidParameter;
   \   00000056   0520               MOVS     R0,#+5
   \   00000058   04E0               B        ??App_StartScan_2
    465              }
    466            }
    467            else
    468            {
    469              /* Allocation of a message buffer failed. */
    470              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_0:
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR      R0,??DataTable8_4
   \   0000005E   ........           BL       UartUtil_Print
    471              return errorAllocFailed;
   \   00000062   0420               MOVS     R0,#+4
   \                     ??App_StartScan_2:
   \   00000064   70BC               POP      {R4-R6}
   \   00000066   08BC               POP      {R3}
   \   00000068   1847               BX       R3               ;; return
    472            }
    473          }
    474          
    475          /******************************************************************************
    476          * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
    477          * Active Scan confirm message received from the MLME when the Active scan has
    478          * completed. The message contains a list of PAN descriptors. Based on link
    479          * quality inforamtion in the pan descriptors the nearest coordinator is chosen.
    480          * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
    481          *
    482          * The function may return either of the following values:
    483          *   errorNoError:       A suitable pan descriptor was found.
    484          *   errorNoScanResults: No scan results were present in the confirm message.
    485          *
    486          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    487          static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
    488          {
   \                     App_HandleScanActiveConfirm:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    489            void    *pBlock;
    490            uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
   \   00000004   6846               MOV      R0,SP
   \   00000006   0299               LDR      R1,[SP, #+8]
   \   00000008   C978               LDRB     R1,[R1, #+3]
   \   0000000A   4170               STRB     R1,[R0, #+1]
    491            uint8_t rc = errorNoScanResults;
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   0621               MOVS     R1,#+6
   \   00000010   0170               STRB     R1,[R0, #+0]
    492            uint8_t j;
    493            uint8_t bestLinkQuality = 0;  
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   0700               MOVS     R7,R0
    494            panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
   \   00000016   0298               LDR      R0,[SP, #+8]
   \   00000018   0830               ADDS     R0,R0,#+8
   \   0000001A   ........           BL       __aeabi_uread4
   \   0000001E   0600               MOVS     R6,R0
    495            panDescriptor_t *pPanDesc;    
    496            
    497           
    498            /* Check if the scan resulted in any coordinator responses. */  
    499            
    500            if (panDescListSize > 0)
   \   00000020   6846               MOV      R0,SP
   \   00000022   4078               LDRB     R0,[R0, #+1]
   \   00000024   0128               CMP      R0,#+1
   \   00000026   34D3               BCC      ??App_HandleScanActiveConfirm_0
    501            {    
    502              /* Check all PAN descriptors. */
    503              while (NULL != pDescBlock)
   \                     ??App_HandleScanActiveConfirm_1:
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   32D0               BEQ      ??App_HandleScanActiveConfirm_0
    504              {
    505                for (j = 0; j < pDescBlock->descriptorCount; j++)
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   0400               MOVS     R4,R0
   \                     ??App_HandleScanActiveConfirm_2:
   \   00000030   6E20               MOVS     R0,#+110
   \   00000032   305C               LDRB     R0,[R6, R0]
   \   00000034   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000036   240E               LSRS     R4,R4,#+24
   \   00000038   8442               CMP      R4,R0
   \   0000003A   1ED2               BCS      ??App_HandleScanActiveConfirm_3
    506                {            
    507                  pPanDesc = &pDescBlock->descriptorList[j];
   \   0000003C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000003E   240E               LSRS     R4,R4,#+24
   \   00000040   1620               MOVS     R0,#+22
   \   00000042   6043               MULS     R0,R4,R0
   \   00000044   3018               ADDS     R0,R6,R0
   \   00000046   0500               MOVS     R5,R0
    508          
    509                  /* Only attempt to associate if the coordinator
    510                     accepts associations and is non-beacon. */
    511                  if( ( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) && 
    512                      ((pPanDesc->superFrameSpec[0] & gSuperFrameSpecLsbBO_c) == 0x0F) )
   \   00000048   287C               LDRB     R0,[R5, #+16]
   \   0000004A   0006               LSLS     R0,R0,#+24
   \   0000004C   13D5               BPL      ??App_HandleScanActiveConfirm_4
   \   0000004E   E87B               LDRB     R0,[R5, #+15]
   \   00000050   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000052   000F               LSRS     R0,R0,#+28
   \   00000054   0F28               CMP      R0,#+15
   \   00000056   0ED1               BNE      ??App_HandleScanActiveConfirm_4
    513                  {        
    514                    
    515                    /* Find the nearest coordinator using the link quality measure. */
    516                    if(pPanDesc->linkQuality > bestLinkQuality)
   \   00000058   A87C               LDRB     R0,[R5, #+18]
   \   0000005A   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000005C   3F0E               LSRS     R7,R7,#+24
   \   0000005E   8742               CMP      R7,R0
   \   00000060   09D2               BCS      ??App_HandleScanActiveConfirm_4
    517                    {
    518                      /* Save the information of the coordinator candidate. If we
    519                         find a better candiate, the information will be replaced. */
    520                      FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
   \   00000062   1622               MOVS     R2,#+22
   \   00000064   2900               MOVS     R1,R5
   \   00000066   ....               LDR      R0,??DataTable9
   \   00000068   ........           BL       FLib_MemCpy
    521                      bestLinkQuality = pPanDesc->linkQuality;
   \   0000006C   A87C               LDRB     R0,[R5, #+18]
   \   0000006E   0700               MOVS     R7,R0
    522                      rc = errorNoError;
   \   00000070   6846               MOV      R0,SP
   \   00000072   0021               MOVS     R1,#+0
   \   00000074   0170               STRB     R1,[R0, #+0]
    523                    }
    524                  }      
    525                }
   \                     ??App_HandleScanActiveConfirm_4:
   \   00000076   641C               ADDS     R4,R4,#+1
   \   00000078   DAE7               B        ??App_HandleScanActiveConfirm_2
    526                
    527                /* Free current block */
    528                pBlock = pDescBlock;
   \                     ??App_HandleScanActiveConfirm_3:
   \   0000007A   0196               STR      R6,[SP, #+4]
    529                pDescBlock = pDescBlock->pNext;              
   \   0000007C   6F36               ADDS     R6,R6,#+111
   \   0000007E   3000               MOVS     R0,R6
   \   00000080   ........           BL       __aeabi_uread4
   \   00000084   0600               MOVS     R6,R0
    530                MSG_Free(pBlock);
   \   00000086   0198               LDR      R0,[SP, #+4]
   \   00000088   ........           BL       MM_Free
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   0190               STR      R0,[SP, #+4]
   \   00000090   CAE7               B        ??App_HandleScanActiveConfirm_1
    531              }
    532            }
    533            
    534            if (pDescBlock)
   \                     ??App_HandleScanActiveConfirm_0:
   \   00000092   002E               CMP      R6,#+0
   \   00000094   04D0               BEQ      ??App_HandleScanActiveConfirm_5
    535                MSG_Free(pDescBlock);
   \   00000096   3000               MOVS     R0,R6
   \   00000098   ........           BL       MM_Free
   \   0000009C   0020               MOVS     R0,#+0
   \   0000009E   0600               MOVS     R6,R0
    536            
    537            return rc;
   \                     ??App_HandleScanActiveConfirm_5:
   \   000000A0   6846               MOV      R0,SP
   \   000000A2   0078               LDRB     R0,[R0, #+0]
   \   000000A4   FEBC               POP      {R1-R7}
   \   000000A6   08BC               POP      {R3}
   \   000000A8   1847               BX       R3               ;; return
    538          }
    539          
    540          /******************************************************************************
    541          * The App_SendAssociateRequest(void) will create an Associate Request message
    542          * and send it to the coordinator it wishes to associate to. The function uses
    543          * information gained about the coordinator during the scan procedure.
    544          *
    545          * The function may return either of the following values:
    546          *   errorNoError:          The Associate Request message was sent successfully.
    547          *   errorInvalidParameter: The MLME service access point rejected the
    548          *                          message due to an invalid parameter.
    549          *   errorAllocFailed:      A message buffer could not be allocated.
    550          *
    551          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    552          static uint8_t App_SendAssociateRequest(void)
    553          {
   \                     App_SendAssociateRequest:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    554            mlmeMessage_t *pMsg;
    555            mlmeAssociateReq_t *pAssocReq;
    556          
    557            UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ....               LDR      R0,??DataTable9_1
   \   00000006   ........           BL       UartUtil_Print
    558            
    559            /* Allocate a message for the MLME message. */
    560            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000A   0F20               MOVS     R0,#+15
   \   0000000C   ........           BL       MM_Alloc
   \   00000010   0500               MOVS     R5,R0
    561            if(pMsg != NULL)
   \   00000012   002D               CMP      R5,#+0
   \   00000014   2BD0               BEQ      ??App_SendAssociateRequest_0
    562            {
    563              /* This is a MLME-ASSOCIATE.req command. */
    564              pMsg->msgType = gMlmeAssociateReq_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   2870               STRB     R0,[R5, #+0]
    565              
    566              /* Create the Associate request message data. */
    567              pAssocReq = &pMsg->msgData.associateReq;
   \   0000001A   2800               MOVS     R0,R5
   \   0000001C   401C               ADDS     R0,R0,#+1
   \   0000001E   0400               MOVS     R4,R0
    568           
    569              /* Use the coordinator info we got from the Active Scan. */
    570              FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
   \   00000020   0822               MOVS     R2,#+8
   \   00000022   ....               LDR      R1,??DataTable9
   \   00000024   2000               MOVS     R0,R4
   \   00000026   ........           BL       FLib_MemCpy
    571              FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
   \   0000002A   0222               MOVS     R2,#+2
   \   0000002C   ....               LDR      R1,??DataTable9
   \   0000002E   0831               ADDS     R1,R1,#+8
   \   00000030   2000               MOVS     R0,R4
   \   00000032   0830               ADDS     R0,R0,#+8
   \   00000034   ........           BL       FLib_MemCpy
    572              pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
   \   00000038   ....               LDR      R0,??DataTable9
   \   0000003A   807A               LDRB     R0,[R0, #+10]
   \   0000003C   A072               STRB     R0,[R4, #+10]
    573              pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
   \   0000003E   ....               LDR      R0,??DataTable9
   \   00000040   C07A               LDRB     R0,[R0, #+11]
   \   00000042   E072               STRB     R0,[R4, #+11]
    574          #ifdef gMAC2006_d
    575          	pAssocReq->securityLevel = 0;
    576          #else	
    577              pAssocReq->securityEnable     = FALSE;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   2073               STRB     R0,[R4, #+12]
    578          #endif //gMAC2006_d	
    579              /* We want the coordinator to assign a short address to us. */
    580              pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
   \   00000048   8020               MOVS     R0,#+128
   \   0000004A   6073               STRB     R0,[R4, #+13]
    581                
    582              /* Send the Associate Request to the MLME. */
    583              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   0000004C   2800               MOVS     R0,R5
   \   0000004E   ........           BL       NWK_MLME_SapHandler
   \   00000052   0028               CMP      R0,#+0
   \   00000054   05D1               BNE      ??App_SendAssociateRequest_1
    584              {
    585                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   ....               LDR      R0,??DataTable8_2
   \   0000005A   ........           BL       UartUtil_Print
    586                return errorNoError;
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   0AE0               B        ??App_SendAssociateRequest_2
    587              }
    588              else
    589              {
    590                /* One or more parameters in the message were invalid. */
    591                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateRequest_1:
   \   00000062   0121               MOVS     R1,#+1
   \   00000064   ....               LDR      R0,??DataTable8_3
   \   00000066   ........           BL       UartUtil_Print
    592                return errorInvalidParameter;
   \   0000006A   0520               MOVS     R0,#+5
   \   0000006C   04E0               B        ??App_SendAssociateRequest_2
    593              }
    594            }
    595            else
    596            {
    597              /* Allocation of a message buffer failed. */
    598              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateRequest_0:
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   ....               LDR      R0,??DataTable8_4
   \   00000072   ........           BL       UartUtil_Print
    599              return errorAllocFailed;
   \   00000076   0420               MOVS     R0,#+4
   \                     ??App_SendAssociateRequest_2:
   \   00000078   32BC               POP      {R1,R4,R5}
   \   0000007A   08BC               POP      {R3}
   \   0000007C   1847               BX       R3               ;; return
    600            }
    601          }
    602          
    603          /******************************************************************************
    604          * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
    605          * Associate confirm message received from the MLME when the Association
    606          * procedure has completed. The message contains the short address that the
    607          * coordinator has assigned to us. This address is 0xfffe if we did not specify
    608          * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
    609          * request. The address and address mode are saved in global variables. They
    610          * will be used in the next demo application when sending data.
    611          *
    612          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    613          static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
    614          {
   \                     App_HandleAssociateConfirm:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    615            /* This is our own extended address (MAC address). It cannot be modified. */
    616            extern uint8_t aExtendedAddress[8];
    617            
    618            /* If the coordinator assigns a short address of 0xfffe then,
    619               that means we must use our own extended address in all
    620               communications with the coordinator. Otherwise, we use
    621               the short address assigned to us. */
    622            if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
   \   00000004   E078               LDRB     R0,[R4, #+3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   19D1               BNE      ??App_HandleAssociateConfirm_0
    623            {
    624          
    625          	  if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
    626          	      (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
   \   0000000A   6078               LDRB     R0,[R4, #+1]
   \   0000000C   FE28               CMP      R0,#+254
   \   0000000E   0BD3               BCC      ??App_HandleAssociateConfirm_1
   \   00000010   A078               LDRB     R0,[R4, #+2]
   \   00000012   FF28               CMP      R0,#+255
   \   00000014   08D1               BNE      ??App_HandleAssociateConfirm_1
    627          	  {
    628          	    mAddrMode = gAddrModeLong_c;
   \   00000016   ....               LDR      R0,??DataTable10
   \   00000018   0321               MOVS     R1,#+3
   \   0000001A   0170               STRB     R1,[R0, #+0]
    629          	    FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
   \   0000001C   0822               MOVS     R2,#+8
   \   0000001E   ....               LDR      R1,??DataTable10_1
   \   00000020   ....               LDR      R0,??DataTable11
   \   00000022   ........           BL       FLib_MemCpy
   \   00000026   08E0               B        ??App_HandleAssociateConfirm_2
    630          	  }
    631          	  else
    632          	  {
    633          	    mAddrMode = gAddrModeShort_c;
   \                     ??App_HandleAssociateConfirm_1:
   \   00000028   ....               LDR      R0,??DataTable10
   \   0000002A   0221               MOVS     R1,#+2
   \   0000002C   0170               STRB     R1,[R0, #+0]
    634          	    FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
   \   0000002E   0222               MOVS     R2,#+2
   \   00000030   2100               MOVS     R1,R4
   \   00000032   491C               ADDS     R1,R1,#+1
   \   00000034   ....               LDR      R0,??DataTable11
   \   00000036   ........           BL       FLib_MemCpy
    635          	  }
    636          	    return gSuccess_c;
   \                     ??App_HandleAssociateConfirm_2:
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   00E0               B        ??App_HandleAssociateConfirm_3
    637            } 
    638            
    639            else 
    640            {
    641          	return pMsg->msgData.associateCnf.status; 
   \                     ??App_HandleAssociateConfirm_0:
   \   0000003E   E078               LDRB     R0,[R4, #+3]
   \                     ??App_HandleAssociateConfirm_3:
   \   00000040   10BC               POP      {R4}
   \   00000042   08BC               POP      {R3}
   \   00000044   1847               BX       R3               ;; return
    642            }
    643          }
    644          /******************************************************************************
    645          * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
    646          * messages from the MLME, e.g. poll confirm.
    647          *
    648          * The function may return either of the following values:
    649          *   errorNoError:   The message was processed.
    650          *   errorNoMessage: The message pointer is NULL.
    651          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    652          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
    653          {
   \                     App_HandleMlmeInput:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
    654            if(pMsg == NULL)
   \   00000004   0029               CMP      R1,#+0
   \   00000006   01D1               BNE      ??App_HandleMlmeInput_0
    655              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   0DE0               B        ??App_HandleMlmeInput_1
    656            
    657            /* Handle the incoming message. The type determines the sort of processing.*/
    658            switch(pMsg->msgType) {
   \                     ??App_HandleMlmeInput_0:
   \   0000000C   0878               LDRB     R0,[R1, #+0]
   \   0000000E   1028               CMP      R0,#+16
   \   00000010   09D1               BNE      ??App_HandleMlmeInput_2
    659            case gNwkPollCnf_c:
    660              if(pMsg->msgData.pollCnf.status != gSuccess_c)
   \   00000012   4878               LDRB     R0,[R1, #+1]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   06D0               BEQ      ??App_HandleMlmeInput_2
    661              {
    662                /* The Poll Confirm status was not successful. Usually this happens if
    663                   no data was available at the coordinator. In this case we start
    664                   polling at a lower rate to conserve power. */
    665                mPollInterval = mDefaultValueOfPollIntervalSlow_c;
   \   00000018   ....               LDR      R0,??DataTable10_2
   \   0000001A   CD22               MOVS     R2,#+205
   \   0000001C   9200               LSLS     R2,R2,#+2        ;; #+820
   \   0000001E   0280               STRH     R2,[R0, #+0]
    666                
    667                /* If we get to this point, then no data was available, and we
    668                   allow a new poll request. Otherwise, we wait for the data
    669                   indication before allowing the next poll request. */
    670                mWaitPollConfirm = FALSE;
   \   00000020   ....               LDR      R0,??DataTable13
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   0270               STRB     R2,[R0, #+0]
    671              }
    672              break;
    673            }
    674            return errorNoError;
   \                     ??App_HandleMlmeInput_2:
   \   00000026   0020               MOVS     R0,#+0
   \                     ??App_HandleMlmeInput_1:
   \   00000028   08BC               POP      {R3}
   \   0000002A   1847               BX       R3               ;; return
    675          }
    676          
    677          /******************************************************************************
    678          * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
    679          * messages from the MCPS, e.g. Data Confirm, and Data Indication.
    680          *
    681          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    682          static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
    683          {
   \                     App_HandleMcpsInput:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    684            switch(pMsgIn->msgType)
   \   00000004   2078               LDRB     R0,[R4, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??App_HandleMcpsInput_0
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   0AD0               BEQ      ??App_HandleMcpsInput_1
   \   0000000E   16E0               B        ??App_HandleMcpsInput_2
    685            {
    686              /* The MCPS-Data confirm is sent by the MAC to the network 
    687                 or application layer when data has been sent. */
    688            case gMcpsDataCnf_c:
    689              if(mcPendingPackets)
   \                     ??App_HandleMcpsInput_0:
   \   00000010   ....               LDR      R0,??DataTable10_3
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   12D0               BEQ      ??App_HandleMcpsInput_2
    690                mcPendingPackets--;
   \   00000018   ....               LDR      R0,??DataTable10_3
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   401E               SUBS     R0,R0,#+1
   \   0000001E   ....               LDR      R1,??DataTable10_3
   \   00000020   0870               STRB     R0,[R1, #+0]
   \   00000022   0CE0               B        ??App_HandleMcpsInput_2
    691              break;
    692          
    693            case gMcpsDataInd_c:
    694              /* Copy the received data to the UART. */
    695              UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
   \                     ??App_HandleMcpsInput_1:
   \   00000024   2000               MOVS     R0,R4
   \   00000026   1B30               ADDS     R0,R0,#+27
   \   00000028   ........           BL       __aeabi_uread4
   \   0000002C   E17D               LDRB     R1,[R4, #+23]
   \   0000002E   ........           BL       UartUtil_Tx
    696              /* Since we received data, the coordinator might have more to send. We 
    697                 reduce the polling interval to raise the throughput while data is
    698                 available. */
    699              mPollInterval = mDefaultValueOfPollIntervalFast_c;
   \   00000032   ....               LDR      R0,??DataTable10_2
   \   00000034   5221               MOVS     R1,#+82
   \   00000036   0180               STRH     R1,[R0, #+0]
    700              /* Allow another MLME-Poll request. */
    701              mWaitPollConfirm = FALSE;
   \   00000038   ....               LDR      R0,??DataTable13
   \   0000003A   0021               MOVS     R1,#+0
   \   0000003C   0170               STRB     R1,[R0, #+0]
    702              break;
    703            }
    704          }
   \                     ??App_HandleMcpsInput_2:
   \   0000003E   10BC               POP      {R4}
   \   00000040   08BC               POP      {R3}
   \   00000042   1847               BX       R3               ;; return
    705          
    706          /******************************************************************************
    707          * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
    708          * the name implies, wait for a message, thus blocking the execution of the
    709          * state machine. Instead the function analyzes the supplied message to 
    710          * determine whether or not the message is of the expected type.
    711          * The function may return either of the following values:
    712          *   errorNoError: The message was of the expected type.
    713          *   errorNoMessage: The message pointer is NULL.
    714          *   errorWrongConfirm: The message is not of the expected type.
    715          *
    716          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    717          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
    718          {
   \                     App_WaitMsg:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0200               MOVS     R2,R0
    719            /* Do we have a message? If not, the exit with error code */
    720            if(pMsg == NULL)
   \   00000004   002A               CMP      R2,#+0
   \   00000006   01D1               BNE      ??App_WaitMsg_0
    721              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   07E0               B        ??App_WaitMsg_1
    722          
    723            /* Is it the expected message type? If not then exit with error code */
    724            if(pMsg->msgType != msgType)
   \                     ??App_WaitMsg_0:
   \   0000000C   1078               LDRB     R0,[R2, #+0]
   \   0000000E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000010   090E               LSRS     R1,R1,#+24
   \   00000012   8842               CMP      R0,R1
   \   00000014   01D0               BEQ      ??App_WaitMsg_2
    725              return errorWrongConfirm;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   00E0               B        ??App_WaitMsg_1
    726          
    727            /* Found the expected message. Return with success code */
    728            return errorNoError;
   \                     ??App_WaitMsg_2:
   \   0000001A   0020               MOVS     R0,#+0
   \                     ??App_WaitMsg_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
    729          }
    730          
    731          /******************************************************************************
    732          * The App_TransmitUartData() function will perform (single/multi buffered)
    733          * data transmissions of data received by the UART. Data could also come from
    734          * other sources such as sensors etc. This is completely determined by the
    735          * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
    736          * number of packets pending for transmission in the MAC. A global variable
    737          * is incremented each time a data packet is sent to the MCPS, and decremented
    738          * when the corresponding MCPS-Data Confirm message is received. If the counter
    739          * reaches the defined maximum no more data buffers are allocated until the
    740          * counter is decreased below the maximum number of pending packets.
    741          *
    742          * The function uses the coordinator information gained during the Active Scan,
    743          * and the short address assigned to us by coordinator, for building an MCPS-
    744          * Data Request message. The message is sent to the MCPS service access point
    745          * in the MAC.
    746          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    747          static void App_TransmitUartData(void)
    748          {   
   \                     App_TransmitUartData:
   \   00000000   80B5               PUSH     {R7,LR}
    749            static uint8_t keysBuffer[mMaxKeysToReceive_c];
    750            static uint8_t keysReceived = 0;
    751            
    752            /* get data from UART */
    753            if( keysReceived < mMaxKeysToReceive_c ) 
   \   00000002   ....               LDR      R0,??DataTable13_1
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   2028               CMP      R0,#+32
   \   00000008   0CD2               BCS      ??App_TransmitUartData_0
    754            {
    755              if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
   \   0000000A   ....               LDR      R0,??DataTable13_1
   \   0000000C   0078               LDRB     R0,[R0, #+0]
   \   0000000E   ....               LDR      R1,??DataTable13_2
   \   00000010   0818               ADDS     R0,R1,R0
   \   00000012   ........           BL       Uart1_GetByteFromRxBuffer
   \   00000016   0028               CMP      R0,#+0
   \   00000018   04D0               BEQ      ??App_TransmitUartData_0
    756              {
    757              keysReceived++;
   \   0000001A   ....               LDR      R0,??DataTable13_1
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   ....               LDR      R1,??DataTable13_1
   \   00000022   0870               STRB     R0,[R1, #+0]
    758              }
    759            }
    760          	/* Use multi buffering for increased TX performance. It does not really
    761               have any effect at a UART baud rate of 19200bps but serves as an
    762               example of how the throughput may be improved in a real-world 
    763               application where the data rate is of concern. */
    764            if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
   \                     ??App_TransmitUartData_0:
   \   00000024   ....               LDR      R0,??DataTable10_3
   \   00000026   0078               LDRB     R0,[R0, #+0]
   \   00000028   0228               CMP      R0,#+2
   \   0000002A   08D2               BCS      ??App_TransmitUartData_1
   \   0000002C   ....               LDR      R0,??DataTable13_3
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   04D1               BNE      ??App_TransmitUartData_1
    765            {
    766              /* If the maximum number of pending data buffes is below maximum limit 
    767                 and we do not have a data buffer already then allocate one. */
    768              mpPacket = MSG_AllocType(nwkToMcpsMessage_t);
   \   00000034   1E20               MOVS     R0,#+30
   \   00000036   ........           BL       MM_Alloc
   \   0000003A   ....               LDR      R1,??DataTable13_3
   \   0000003C   0860               STR      R0,[R1, #+0]
    769            }
    770          
    771            if(mpPacket != NULL)
   \                     ??App_TransmitUartData_1:
   \   0000003E   ....               LDR      R0,??DataTable13_3
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   53D0               BEQ      ??App_TransmitUartData_2
    772            {
    773              /* get data from UART */        
    774                mpPacket->msgData.dataReq.pMsdu = &keysBuffer[0];
   \   00000046   ....               LDR      R0,??DataTable13_3
   \   00000048   0168               LDR      R1,[R0, #+0]
   \   0000004A   1A31               ADDS     R1,R1,#+26
   \   0000004C   ....               LDR      R0,??DataTable13_2
   \   0000004E   ........           BL       __aeabi_uwrite4
    775                /* Data was available in the UART receive buffer. Now create an
    776                   MCPS-Data Request message containing the UART data. */
    777                mpPacket->msgType = gMcpsDataReq_c;
   \   00000052   ....               LDR      R0,??DataTable13_3
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   0021               MOVS     R1,#+0
   \   00000058   0170               STRB     R1,[R0, #+0]
    778                /* Create the header using coordinator information gained during 
    779                   the scan procedure. Also use the short address we were assigned
    780                   by the coordinator during association. */
    781                FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, mCoordInfo.coordAddress, 8);
   \   0000005A   0822               MOVS     R2,#+8
   \   0000005C   ....               LDR      R1,??DataTable9
   \   0000005E   ....               LDR      R0,??DataTable13_3
   \   00000060   0068               LDR      R0,[R0, #+0]
   \   00000062   401C               ADDS     R0,R0,#+1
   \   00000064   ........           BL       FLib_MemCpy
    782                FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
   \   00000068   0822               MOVS     R2,#+8
   \   0000006A   ....               LDR      R1,??DataTable11
   \   0000006C   ....               LDR      R0,??DataTable13_3
   \   0000006E   0068               LDR      R0,[R0, #+0]
   \   00000070   0C30               ADDS     R0,R0,#+12
   \   00000072   ........           BL       FLib_MemCpy
    783                FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
   \   00000076   0222               MOVS     R2,#+2
   \   00000078   ....               LDR      R1,??DataTable9
   \   0000007A   0831               ADDS     R1,R1,#+8
   \   0000007C   ....               LDR      R0,??DataTable13_3
   \   0000007E   0068               LDR      R0,[R0, #+0]
   \   00000080   0930               ADDS     R0,R0,#+9
   \   00000082   ........           BL       FLib_MemCpy
    784                FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
   \   00000086   0222               MOVS     R2,#+2
   \   00000088   ....               LDR      R1,??DataTable9
   \   0000008A   0831               ADDS     R1,R1,#+8
   \   0000008C   ....               LDR      R0,??DataTable13_3
   \   0000008E   0068               LDR      R0,[R0, #+0]
   \   00000090   1430               ADDS     R0,R0,#+20
   \   00000092   ........           BL       FLib_MemCpy
    785                mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
   \   00000096   ....               LDR      R0,??DataTable13_3
   \   00000098   0068               LDR      R0,[R0, #+0]
   \   0000009A   ....               LDR      R1,??DataTable9
   \   0000009C   897A               LDRB     R1,[R1, #+10]
   \   0000009E   C172               STRB     R1,[R0, #+11]
    786                mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
   \   000000A0   ....               LDR      R0,??DataTable13_3
   \   000000A2   0068               LDR      R0,[R0, #+0]
   \   000000A4   ....               LDR      R1,??DataTable10
   \   000000A6   0978               LDRB     R1,[R1, #+0]
   \   000000A8   8175               STRB     R1,[R0, #+22]
    787                mpPacket->msgData.dataReq.msduLength = keysReceived;
   \   000000AA   ....               LDR      R0,??DataTable13_3
   \   000000AC   0068               LDR      R0,[R0, #+0]
   \   000000AE   ....               LDR      R1,??DataTable13_1
   \   000000B0   0978               LDRB     R1,[R1, #+0]
   \   000000B2   C175               STRB     R1,[R0, #+23]
    788                /* Request MAC level acknowledgement of the data packet */
    789                mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c;
   \   000000B4   ....               LDR      R0,??DataTable13_3
   \   000000B6   0068               LDR      R0,[R0, #+0]
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   4176               STRB     R1,[R0, #+25]
    790                /* Give the data packet a handle. The handle is
    791                   returned in the MCPS-Data Confirm message. */
    792                mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
   \   000000BC   ....               LDR      R0,??DataTable13_3
   \   000000BE   0068               LDR      R0,[R0, #+0]
   \   000000C0   ....               LDR      R1,??DataTable13_4
   \   000000C2   0978               LDRB     R1,[R1, #+0]
   \   000000C4   0176               STRB     R1,[R0, #+24]
   \   000000C6   ....               LDR      R0,??DataTable13_4
   \   000000C8   0078               LDRB     R0,[R0, #+0]
   \   000000CA   401C               ADDS     R0,R0,#+1
   \   000000CC   ....               LDR      R1,??DataTable13_4
   \   000000CE   0870               STRB     R0,[R1, #+0]
    793          #ifdef gMAC2006_d
    794          	  /* Don't use security */
    795          	  mpPacket->msgData.dataReq.securityLevel = 0;
    796          #endif //gMAC2006_d      
    797                /* Send the Data Request to the MCPS */
    798                (void)MSG_Send(NWK_MCPS, mpPacket);
   \   000000D0   ....               LDR      R0,??DataTable13_3
   \   000000D2   0068               LDR      R0,[R0, #+0]
   \   000000D4   ........           BL       NWK_MCPS_SapHandler
    799                /* Prepare for another data buffer */
    800                mpPacket = NULL;
   \   000000D8   ....               LDR      R0,??DataTable13_3
   \   000000DA   0021               MOVS     R1,#+0
   \   000000DC   0160               STR      R1,[R0, #+0]
    801                mcPendingPackets++;
   \   000000DE   ....               LDR      R0,??DataTable10_3
   \   000000E0   0078               LDRB     R0,[R0, #+0]
   \   000000E2   401C               ADDS     R0,R0,#+1
   \   000000E4   ....               LDR      R1,??DataTable10_3
   \   000000E6   0870               STRB     R0,[R1, #+0]
    802                /* Receive another pressed keys */
    803                keysReceived = 0;
   \   000000E8   ....               LDR      R0,??DataTable13_1
   \   000000EA   0021               MOVS     R1,#+0
   \   000000EC   0170               STRB     R1,[R0, #+0]
    804            }
    805                
    806            /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
    807            /* try to send it later   */
    808            if (keysReceived)
   \                     ??App_TransmitUartData_2:
   \   000000EE   ....               LDR      R0,??DataTable13_1
   \   000000F0   0078               LDRB     R0,[R0, #+0]
   \   000000F2   0028               CMP      R0,#+0
   \   000000F4   04D0               BEQ      ??App_TransmitUartData_3
    809            {
    810            TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   000000F6   0221               MOVS     R1,#+2
   \   000000F8   ....               LDR      R0,??DataTable13_5
   \   000000FA   0078               LDRB     R0,[R0, #+0]
   \   000000FC   ........           BL       TS_SendEvent
    811            }
    812          
    813          }
   \                     ??App_TransmitUartData_3:
   \   00000100   09BC               POP      {R0,R3}
   \   00000102   1847               BX       R3               ;; return

   \                                 In section .bss, align 4
   \                     ??keysBuffer:
   \   00000000                      DS8 32

   \                                 In section .bss, align 1
   \                     ??keysReceived:
   \   00000000                      DS8 1
    814          
    815          /******************************************************************************
    816          * The App_ReceiveUartData() function will check if it is time to send out an
    817          * MLME-Poll request in order to receive data from the coordinator. If its time,
    818          * and we are permitted then a poll request is created and sent.
    819          * 
    820          * The function uses the coordinator information gained during the Active Scan
    821          * for building the MLME-Poll Request message. The message is sent to the MLME
    822          * service access point in the MAC.
    823          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    824          static void    AppPollWaitTimeout(uint8_t tmr)
    825          { 
   \                     AppPollWaitTimeout:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    826            
    827            /* Just to avoid the compiler warning */
    828            tmr++;
   \   00000004   641C               ADDS     R4,R4,#+1
    829            
    830            /* Check if we are permitted, and if it is time to send a poll request.
    831               The poll interval is adjusted dynamically to the current band-width
    832               requirements. */
    833            if(mWaitPollConfirm == FALSE)
   \   00000006   ....               LDR      R0,??DataTable13
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   21D1               BNE      ??AppPollWaitTimeout_0
    834            {
    835              /* This is an MLME-POLL.req command. */
    836              mlmeMessage_t *pMlmeMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000E   0F20               MOVS     R0,#+15
   \   00000010   ........           BL       MM_Alloc
   \   00000014   0500               MOVS     R5,R0
    837              if(pMlmeMsg)
   \   00000016   002D               CMP      R5,#+0
   \   00000018   1BD0               BEQ      ??AppPollWaitTimeout_0
    838              {
    839                /* Create the Poll Request message data. */
    840                pMlmeMsg->msgType = gMlmePollReq_c;
   \   0000001A   0C20               MOVS     R0,#+12
   \   0000001C   2870               STRB     R0,[R5, #+0]
    841           
    842                /* Use the coordinator information we got from the Active Scan. */
    843                FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordAddress, mCoordInfo.coordAddress, 8);
   \   0000001E   0822               MOVS     R2,#+8
   \   00000020   ....               LDR      R1,??DataTable10_4
   \   00000022   2800               MOVS     R0,R5
   \   00000024   401C               ADDS     R0,R0,#+1
   \   00000026   ........           BL       FLib_MemCpy
    844                FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordPanId, mCoordInfo.coordPanId, 2);
   \   0000002A   0222               MOVS     R2,#+2
   \   0000002C   ....               LDR      R1,??DataTable10_4
   \   0000002E   0831               ADDS     R1,R1,#+8
   \   00000030   2800               MOVS     R0,R5
   \   00000032   0930               ADDS     R0,R0,#+9
   \   00000034   ........           BL       FLib_MemCpy
    845                pMlmeMsg->msgData.pollReq.coordAddrMode = mCoordInfo.coordAddrMode;
   \   00000038   ....               LDR      R0,??DataTable10_4
   \   0000003A   807A               LDRB     R0,[R0, #+10]
   \   0000003C   E872               STRB     R0,[R5, #+11]
    846          #ifdef gMAC2006_d
    847                pMlmeMsg->msgData.pollReq.securityLevel = 0;
    848          #else      
    849                pMlmeMsg->msgData.pollReq.securityEnable = FALSE;
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   2873               STRB     R0,[R5, #+12]
    850          #endif //gMAC2006_d      
    851                
    852                /* Send the Poll Request to the MLME. */
    853                if(MSG_Send(NWK_MLME, pMlmeMsg) == gSuccess_c)
   \   00000042   2800               MOVS     R0,R5
   \   00000044   ........           BL       NWK_MLME_SapHandler
   \   00000048   0028               CMP      R0,#+0
   \   0000004A   02D1               BNE      ??AppPollWaitTimeout_0
    854                {
    855                  /* Do not allow another Poll request before the confirm is received. */
    856                  mWaitPollConfirm = TRUE;
   \   0000004C   ....               LDR      R0,??DataTable13
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   0170               STRB     R1,[R0, #+0]
    857          
    858                }
    859              }
    860            }
    861           /* Restart timer. */
    862           TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
   \                     ??AppPollWaitTimeout_0:
   \   00000052   ....               LDR      R2,??DataTable13_6
   \   00000054   ....               LDR      R0,??DataTable10_2
   \   00000056   0188               LDRH     R1,[R0, #+0]
   \   00000058   ....               LDR      R0,??DataTable13_7
   \   0000005A   0078               LDRB     R0,[R0, #+0]
   \   0000005C   ........           BL       TMR_StartSingleShotTimer
    863          }
   \   00000060   31BC               POP      {R0,R4,R5}
   \   00000062   08BC               POP      {R3}
   \   00000064   1847               BX       R3               ;; return
    864          
    865          /*****************************************************************************
    866          * Handles all key events for this device.
    867          * Interface assumptions: None
    868          * Return value: None
    869          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    870          static void App_HandleKeys
    871            (
    872            key_event_t events  /*IN: Events from keyboard modul */
    873            )
    874              
    875              /*WSNProject*****************************************************************************
    876                * A seguire:
    877              * Alcuni controlli sugli switch: setta e controlla parametri MAC PIB
    878          * Lo scopo di tutto ciò è verificare che le data request non vengano più mandate
    879              *per cessare tutte le task attive
    880          *****************************************************************************/
    881          {
   \                     App_HandleKeys:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    882            switch ( events ) 
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   07D0               BEQ      ??App_HandleKeys_0
   \   0000000E   401E               SUBS     R0,R0,#+1
   \   00000010   18D0               BEQ      ??App_HandleKeys_1
   \   00000012   401E               SUBS     R0,R0,#+1
   \   00000014   2DD0               BEQ      ??App_HandleKeys_2
   \   00000016   401E               SUBS     R0,R0,#+1
   \   00000018   0428               CMP      R0,#+4
   \   0000001A   36D9               BLS      ??App_HandleKeys_3
   \   0000001C   5CE0               B        ??App_HandleKeys_4
    883              { 
    884                case gKBD_EventSW1_c:
    885                  if(gState == stateListen)
   \                     ??App_HandleKeys_0:
   \   0000001E   ....               LDR      R0,??DataTable13_8
   \   00000020   0078               LDRB     R0,[R0, #+0]
   \   00000022   0528               CMP      R0,#+5
   \   00000024   0ED1               BNE      ??App_HandleKeys_5
    886                  {
    887                    dataSet= FALSE;
   \   00000026   ....               LDR      R0,??DataTable13_9
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   0170               STRB     R1,[R0, #+0]
    888                    App_SetParam(gMPibAutoRequest_c, &dataSet);
   \   0000002C   ....               LDR      R1,??DataTable13_9
   \   0000002E   4220               MOVS     R0,#+66
   \   00000030   ........           BL       App_SetParam
    889                    dataSet= FALSE;
   \   00000034   ....               LDR      R0,??DataTable13_9
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   0170               STRB     R1,[R0, #+0]
    890                    App_SetParam(gMPibRxOnWhenIdle_c, &dataSet);
   \   0000003A   ....               LDR      R1,??DataTable13_9
   \   0000003C   5220               MOVS     R0,#+82
   \   0000003E   ........           BL       App_SetParam
    891                    break;
   \   00000042   49E0               B        ??App_HandleKeys_6
    892                  }
    893                case gKBD_EventSW2_c:
    894                  if(gState == stateListen)
   \                     ??App_HandleKeys_1:
   \                     ??App_HandleKeys_5:
   \   00000044   ....               LDR      R0,??DataTable13_8
   \   00000046   0078               LDRB     R0,[R0, #+0]
   \   00000048   0528               CMP      R0,#+5
   \   0000004A   12D1               BNE      ??App_HandleKeys_7
    895                  {
    896                    App_GetParam(gMPibAutoRequest_c, &dataGet);
   \   0000004C   ....               LDR      R1,??DataTable13_10
   \   0000004E   4220               MOVS     R0,#+66
   \   00000050   ........           BL       App_GetParam
    897                    UartUtil_PrintHex((uint8_t*)&dataGet, 1, 0);
   \   00000054   0022               MOVS     R2,#+0
   \   00000056   0121               MOVS     R1,#+1
   \   00000058   ....               LDR      R0,??DataTable13_10
   \   0000005A   ........           BL       UartUtil_PrintHex
    898                    //verifica già fatta: RxOnWhenIdle è FALSE (val==0) di default
    899                    //(probabilmente quando la powerlib è introdotta a TRUE in AppConf.h)
    900                    App_GetParam(gMPibRxOnWhenIdle_c, &dataUGet);
   \   0000005E   ....               LDR      R1,??DataTable13_11
   \   00000060   5220               MOVS     R0,#+82
   \   00000062   ........           BL       App_GetParam
    901                    UartUtil_PrintHex((uint8_t*)&dataUGet, 1, 0);
   \   00000066   0022               MOVS     R2,#+0
   \   00000068   0121               MOVS     R1,#+1
   \   0000006A   ....               LDR      R0,??DataTable13_11
   \   0000006C   ........           BL       UartUtil_PrintHex
    902                    break;
   \   00000070   32E0               B        ??App_HandleKeys_6
    903                  }
    904                case gKBD_EventSW3_c:
    905                  if(gState == stateListen)
   \                     ??App_HandleKeys_2:
   \                     ??App_HandleKeys_7:
   \   00000072   ....               LDR      R0,??DataTable13_8
   \   00000074   0078               LDRB     R0,[R0, #+0]
   \   00000076   0528               CMP      R0,#+5
   \   00000078   07D1               BNE      ??App_HandleKeys_8
    906                  {
    907                    dataSet= TRUE;
   \   0000007A   ....               LDR      R0,??DataTable13_9
   \   0000007C   0121               MOVS     R1,#+1
   \   0000007E   0170               STRB     R1,[R0, #+0]
    908                    App_SetParam(gMPibAutoRequest_c, &dataSet);
   \   00000080   ....               LDR      R1,??DataTable13_9
   \   00000082   4220               MOVS     R0,#+66
   \   00000084   ........           BL       App_SetParam
    909                    break;
   \   00000088   26E0               B        ??App_HandleKeys_6
    910                  }
    911                case gKBD_EventSW4_c:
    912                case gKBD_EventLongSW1_c:
    913                case gKBD_EventLongSW2_c:
    914                case gKBD_EventLongSW3_c:
    915                case gKBD_EventLongSW4_c:
    916                  if(gState == stateInit)
   \                     ??App_HandleKeys_3:
   \                     ??App_HandleKeys_8:
   \   0000008A   ....               LDR      R0,??DataTable13_8
   \   0000008C   0078               LDRB     R0,[R0, #+0]
   \   0000008E   0028               CMP      R0,#+0
   \   00000090   22D1               BNE      ??App_HandleKeys_4
    917                    {
    918                    StopLed1Flashing();
   \   00000092   0120               MOVS     R0,#+1
   \   00000094   ........           BL       LED_StopFlash
    919                    StopLed2Flashing();
   \   00000098   0220               MOVS     R0,#+2
   \   0000009A   ........           BL       LED_StopFlash
    920                    StopLed3Flashing();
   \   0000009E   0420               MOVS     R0,#+4
   \   000000A0   ........           BL       LED_StopFlash
    921                    StopLed4Flashing();
   \   000000A4   0820               MOVS     R0,#+8
   \   000000A6   ........           BL       LED_StopFlash
    922                    Led1Off();
   \   000000AA   0021               MOVS     R1,#+0
   \   000000AC   1720               MOVS     R0,#+23
   \   000000AE   ........           BL       Gpio_SetPinData
    923                    Led2Off();
   \   000000B2   0021               MOVS     R1,#+0
   \   000000B4   1820               MOVS     R0,#+24
   \   000000B6   ........           BL       Gpio_SetPinData
    924                    Led3Off();
   \   000000BA   0021               MOVS     R1,#+0
   \   000000BC   1920               MOVS     R0,#+25
   \   000000BE   ........           BL       Gpio_SetPinData
    925                    Led4Off();
   \   000000C2   0021               MOVS     R1,#+0
   \   000000C4   2C20               MOVS     R0,#+44
   \   000000C6   ........           BL       Gpio_SetPinData
    926                    LCD_ClearDisplay();
    927                    LCD_WriteString(1,"Application");
   \   000000CA   ....               LDR      R0,??DataTable13_12
    928                    LCD_WriteString(2,"    started");     
   \   000000CC   ....               LDR      R0,??DataTable13_13
    929                    TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
   \   000000CE   0121               MOVS     R1,#+1
   \   000000D0   ....               LDR      R0,??DataTable13_5
   \   000000D2   0078               LDRB     R0,[R0, #+0]
   \   000000D4   ........           BL       TS_SendEvent
    930                    }
    931              }    
    932          }
   \                     ??App_HandleKeys_4:
   \                     ??App_HandleKeys_6:
   \   000000D8   10BC               POP      {R4}
   \   000000DA   08BC               POP      {R3}
   \   000000DC   1847               BX       R3               ;; return
    933          
    934          /*****************************************************************************
    935          * The DeepSleepWakeupStackProc(void) function is called each time the 
    936          * application exits the DeepSleep mode .
    937          * 
    938          * Return value:
    939          *     None
    940          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    941          void DeepSleepWakeupStackProc(void){
    942            return;
   \                     DeepSleepWakeupStackProc:
   \   00000000   7047               BX       LR               ;; return
    943          }
    944          
    945          /******************************************************************************
    946          * The following functions are called by the MAC to put messages into the
    947          * Application's queue. They need to be defined even if they are not used
    948          * in order to avoid linker errors.
    949          ******************************************************************************/
    950          

   \                                 In section .text, align 2, keep-with-next
    951          uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
    952          {
   \                     MLME_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    953            /* Put the incoming MLME message in the applications input queue. */
    954            MSG_Queue(&mMlmeNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable13_14
   \   00000008   ........           BL       List_AddTail
    955            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
   \   0000000C   0421               MOVS     R1,#+4
   \   0000000E   ....               LDR      R0,??DataTable13_5
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
    956            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    957          }
    958          

   \                                 In section .text, align 2, keep-with-next
    959          uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
    960          {
   \                     MCPS_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    961            /* Put the incoming MCPS message in the applications input queue. */
    962            MSG_Queue(&mMcpsNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable13_15
   \   00000008   ........           BL       List_AddTail
    963            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   0000000C   0821               MOVS     R1,#+8
   \   0000000E   ....               LDR      R0,??DataTable13_5
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
    964            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    965          }
    966          

   \                                 In section .text, align 2, keep-with-next
    967          uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
    968          {
   \                     ASP_APP_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    969            /* If the message is not handled anywhere it must be freed. */
    970            MSG_Free(pMsg);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       MM_Free
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0400               MOVS     R4,R0
    971            return gSuccess_c;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   10BC               POP      {R4}
   \   00000012   08BC               POP      {R3}
   \   00000014   1847               BX       R3               ;; return
    972          }
    973          
    974          /******************************************************************************/
    975          

   \                                 In section .text, align 2, keep-with-next
    976          static uint8_t App_SetParam(uint8_t attribute, bool_t *pValue)
    977          {
   \                     App_SetParam:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0500               MOVS     R5,R0
   \   00000006   0C00               MOVS     R4,R1
    978            mlmeMessage_t mlmeSet;
    979            mlmeSet.msgType=gMlmeSetReq_c;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   0921               MOVS     R1,#+9
   \   0000000C   0170               STRB     R1,[R0, #+0]
    980            mlmeSet.msgData.setReq.pibAttribute=attribute;
   \   0000000E   6846               MOV      R0,SP
   \   00000010   4570               STRB     R5,[R0, #+1]
    981            mlmeSet.msgData.setReq.pibAttributeValue=pValue;
   \   00000012   6946               MOV      R1,SP
   \   00000014   891C               ADDS     R1,R1,#+2
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       __aeabi_uwrite4
    982           
    983            return MSG_Send(NWK_MLME, &mlmeSet);
   \   0000001C   6846               MOV      R0,SP
   \   0000001E   ........           BL       NWK_MLME_SapHandler
   \   00000022   05B0               ADD      SP,SP,#+20
   \   00000024   30BC               POP      {R4,R5}
   \   00000026   08BC               POP      {R3}
   \   00000028   1847               BX       R3               ;; return
    984            
    985          }
    986          

   \                                 In section .text, align 2, keep-with-next
    987          static uint8_t App_GetParam(uint8_t attribute, bool_t* pValue)
    988          {
   \                     App_GetParam:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0500               MOVS     R5,R0
   \   00000006   0C00               MOVS     R4,R1
    989            mlmeMessage_t mlmeGet;
    990            mlmeGet.msgType=gMlmeGetReq_c;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   0321               MOVS     R1,#+3
   \   0000000C   0170               STRB     R1,[R0, #+0]
    991            mlmeGet.msgData.getReq.pibAttribute=attribute;
   \   0000000E   6846               MOV      R0,SP
   \   00000010   4570               STRB     R5,[R0, #+1]
    992            mlmeGet.msgData.getReq.pibAttributeValue=pValue;
   \   00000012   6946               MOV      R1,SP
   \   00000014   891C               ADDS     R1,R1,#+2
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       __aeabi_uwrite4
    993           
    994            return MSG_Send(NWK_MLME, &mlmeGet);
   \   0000001C   6846               MOV      R0,SP
   \   0000001E   ........           BL       NWK_MLME_SapHandler
   \   00000022   05B0               ADD      SP,SP,#+20
   \   00000024   30BC               POP      {R4,R5}
   \   00000026   08BC               POP      {R3}
   \   00000028   1847               BX       R3               ;; return
    995          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   ........           DC32     mWaitPollConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   ........           DC32     App_HandleKeys

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   ........           DC32     UartRxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   ........           DC32     `?<Constant "\\n\\rPress any switch on...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   ........           DC32     `?<Constant "Press any key">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   ........           DC32     `?<Constant "for coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     `?<Constant "to start.">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   ........           DC32     `?<Constant "Received an MLME-Beac...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   ........           DC32     `?<Constant "Found a coordinator w...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   ........           DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   ........           DC32     `?<Constant "\\n\\rAddress...........0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   ........           DC32     mCoordInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   ........           DC32     `?<Constant "\\n\\rPAN ID............0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     `?<Constant "MyWirelessApp Demo No...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     `?<Constant "\\n\\rLogical Channel...0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     `?<Constant "\\n\\rBeacon Spec.......0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     `?<Constant "\\n\\rLink Quality......0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     `?<Constant "\\n\\r\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   ........           DC32     `?<Constant "Scan did not find a s...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   ........           DC32     `?<Constant "No coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   ........           DC32     `?<Constant "found.">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   ........           DC32     `?<Constant "Associating to PAN co...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   ........           DC32     `?<Constant "Associating to ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   ........           DC32     `?<Constant "PAN coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     `?<Constant "Successfully associat...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     `?<Constant "We were assigned the ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     mAddrMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   ........           DC32     maMyAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     `?<Constant "\\n\\r\\n\\rReady to send and...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     `?<Constant "Ready to send">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     `?<Constant "and receive data">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   ........           DC32     AppPollWaitTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   ........           DC32     `?<Constant "\\n\\rAssociate Confirm w...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Scan...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     `?<Constant "Done\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     `?<Constant "Invalid parameter!\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     `?<Constant "Message allocation fa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     mCoordInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Asso...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     mAddrMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     aExtendedAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   ........           DC32     mPollInterval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   ........           DC32     mCoordInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     maMyAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     mWaitPollConfirm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     ??keysReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   ........           DC32     ??keysBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     mpPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   ........           DC32     mMsduHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   ........           DC32     AppPollWaitTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   ........           DC32     mTimer_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   ........           DC32     dataSet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   ........           DC32     dataGet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   ........           DC32     dataUGet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   ........           DC32     `?<Constant "Application">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   ........           DC32     `?<Constant "    started">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rPress any switch on...">`:
   \   00000000   0A0D50726573       DC8 0AH, 0DH, 50H, 72H, 65H, 73H, 73H, 20H
   \              7320        
   \   00000008   616E79207377       DC8 61H, 6EH, 79H, 20H, 73H, 77H, 69H, 74H
   \              6974        
   \   00000010   6368206F6E20       DC8 63H, 68H, 20H, 6FH, 6EH, 20H, 62H, 6FH
   \              626F        
   \   00000018   61726420746F       DC8 61H, 72H, 64H, 20H, 74H, 6FH, 20H, 73H
   \              2073        
   \   00000020   746172742072       DC8 74H, 61H, 72H, 74H, 20H, 72H, 75H, 6EH
   \              756E        
   \   00000028   6E696E672074       DC8 6EH, 69H, 6EH, 67H, 20H, 74H, 68H, 65H
   \              6865        
   \   00000030   206170706C69       DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
   \              6361        
   \   00000038   74696F6E2E0A       DC8 74H, 69H, 6FH, 6EH, 2EH, 0AH, 0DH, 0
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "Press any key">`:
   \   00000000   507265737320       DC8 "Press any key"
   \              616E79206B65
   \              7900        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "to start.">`:
   \   00000000   746F20737461       DC8 "to start."
   \              72742E00    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received an MLME-Beac...">`:
   \   00000000   526563656976       DC8 "Received an MLME-Beacon Notify Indication\012\015"
   \              656420616E20
   \              4D4C4D452D42
   \              6561636F6E20
   \              4E6F74696679
   \              20496E646963
   \              6174696F6E0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "MyWirelessApp Demo No...">`:
   \   00000000   4D7957697265       DC8 4DH, 79H, 57H, 69H, 72H, 65H, 6CH, 65H
   \              6C65        
   \   00000008   737341707020       DC8 73H, 73H, 41H, 70H, 70H, 20H, 44H, 65H
   \              4465        
   \   00000010   6D6F204E6F6E       DC8 6DH, 6FH, 20H, 4EH, 6FH, 6EH, 20H, 42H
   \              2042        
   \   00000018   6561636F6E20       DC8 65H, 61H, 63H, 6FH, 6EH, 20H, 45H, 6EH
   \              456E        
   \   00000020   642044657669       DC8 64H, 20H, 44H, 65H, 76H, 69H, 63H, 65H
   \              6365        
   \   00000028   206170706C69       DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
   \              6361        
   \   00000030   74696F6E2069       DC8 74H, 69H, 6FH, 6EH, 20H, 69H, 73H, 20H
   \              7320        
   \   00000038   696E69746961       DC8 69H, 6EH, 69H, 74H, 69H, 61H, 6CH, 69H
   \              6C69        
   \   00000040   7A656420616E       DC8 7AH, 65H, 64H, 20H, 61H, 6EH, 64H, 20H
   \              6420        
   \   00000048   72656164792E       DC8 72H, 65H, 61H, 64H, 79H, 2EH, 0AH, 0DH
   \              0A0D        
   \   00000050   0A0D00             DC8 0AH, 0DH, 0
   \   00000053   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Start scanning for a ...">`:
   \   00000000   537461727420       DC8 "Start scanning for a PAN coordinator\012\015"
   \              7363616E6E69
   \              6E6720666F72
   \              20612050414E
   \              20636F6F7264
   \              696E61746F72
   \              0A0D00      
   \   00000027   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Start scanning">`:
   \   00000000   537461727420       DC8 "Start scanning"
   \              7363616E6E69
   \              6E6700      
   \   0000000F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "for coordinator">`:
   \   00000000   666F7220636F       DC8 "for coordinator"
   \              6F7264696E61
   \              746F7200    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Found a coordinator w...">`:
   \   00000000   466F756E6420       DC8 46H, 6FH, 75H, 6EH, 64H, 20H, 61H, 20H
   \              6120        
   \   00000008   636F6F726469       DC8 63H, 6FH, 6FH, 72H, 64H, 69H, 6EH, 61H
   \              6E61        
   \   00000010   746F72207769       DC8 74H, 6FH, 72H, 20H, 77H, 69H, 74H, 68H
   \              7468        
   \   00000018   207468652066       DC8 20H, 74H, 68H, 65H, 20H, 66H, 6FH, 6CH
   \              6F6C        
   \   00000020   6C6F77696E67       DC8 6CH, 6FH, 77H, 69H, 6EH, 67H, 20H, 70H
   \              2070        
   \   00000028   726F70657274       DC8 72H, 6FH, 70H, 65H, 72H, 74H, 69H, 65H
   \              6965        
   \   00000030   733A0A0D00         DC8 73H, 3AH, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000008   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000010   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000018   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000020   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000028   2D2D2D2D2D2D       DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              2D2D        
   \   00000030   2D2D2D2D00         DC8 2DH, 2DH, 2DH, 2DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rAddress...........0x">`:
   \   00000000   0A0D41646472       DC8 "\012\015Address...........0x"
   \              6573732E2E2E
   \              2E2E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rPAN ID............0x">`:
   \   00000000   0A0D50414E20       DC8 "\012\015PAN ID............0x"
   \              49442E2E2E2E
   \              2E2E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rLogical Channel...0x">`:
   \   00000000   0A0D4C6F6769       DC8 "\012\015Logical Channel...0x"
   \              63616C204368
   \              616E6E656C2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rBeacon Spec.......0x">`:
   \   00000000   0A0D42656163       DC8 "\012\015Beacon Spec.......0x"
   \              6F6E20537065
   \              632E2E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rLink Quality......0x">`:
   \   00000000   0A0D4C696E6B       DC8 "\012\015Link Quality......0x"
   \              205175616C69
   \              74792E2E2E2E
   \              2E2E307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r\\n\\r">`:
   \   00000000   0A0D0A0D00         DC8 "\012\015\012\015"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Scan did not find a s...">`:
   \   00000000   5363616E2064       DC8 "Scan did not find a suitable coordinator\012\015"
   \              6964206E6F74
   \              2066696E6420
   \              612073756974
   \              61626C652063
   \              6F6F7264696E
   \              61746F720A0D
   \              00          
   \   0000002B   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "No coordinator">`:
   \   00000000   4E6F20636F6F       DC8 "No coordinator"
   \              7264696E6174
   \              6F7200      
   \   0000000F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "found.">`:
   \   00000000   666F756E642E       DC8 "found."
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Associating to PAN co...">`:
   \   00000000   4173736F6369       DC8 "Associating to PAN coordinator on channel 0x"
   \              6174696E6720
   \              746F2050414E
   \              20636F6F7264
   \              696E61746F72
   \              206F6E206368
   \              616E6E656C20
   \              307800      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Associating to ">`:
   \   00000000   4173736F6369       DC8 "Associating to "
   \              6174696E6720
   \              746F2000    

   \                                 In section .rodata, align 4
   \                     `?<Constant "PAN coordinator">`:
   \   00000000   50414E20636F       DC8 "PAN coordinator"
   \              6F7264696E61
   \              746F7200    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Successfully associat...">`:
   \   00000000   537563636573       DC8 "Successfully associated with the coordinator.\012\015"
   \              7366756C6C79
   \              206173736F63
   \              696174656420
   \              776974682074
   \              686520636F6F
   \              7264696E6174
   \              6F722E0A0D00

   \                                 In section .rodata, align 4
   \                     `?<Constant "We were assigned the ...">`:
   \   00000000   576520776572       DC8 "We were assigned the short address 0x"
   \              652061737369
   \              676E65642074
   \              68652073686F
   \              727420616464
   \              726573732030
   \              7800        
   \   00000026   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\r\\n\\rReady to send and...">`:
   \   00000000   0A0D0A0D5265       DC8 0AH, 0DH, 0AH, 0DH, 52H, 65H, 61H, 64H
   \              6164        
   \   00000008   7920746F2073       DC8 79H, 20H, 74H, 6FH, 20H, 73H, 65H, 6EH
   \              656E        
   \   00000010   6420616E6420       DC8 64H, 20H, 61H, 6EH, 64H, 20H, 72H, 65H
   \              7265        
   \   00000018   636569766520       DC8 63H, 65H, 69H, 76H, 65H, 20H, 64H, 61H
   \              6461        
   \   00000020   7461206F7665       DC8 74H, 61H, 20H, 6FH, 76H, 65H, 72H, 20H
   \              7220        
   \   00000028   746865205541       DC8 74H, 68H, 65H, 20H, 55H, 41H, 52H, 54H
   \              5254        
   \   00000030   2E0A0D0A0D00       DC8 2EH, 0AH, 0DH, 0AH, 0DH, 0
   \   00000036   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Ready to send">`:
   \   00000000   526561647920       DC8 "Ready to send"
   \              746F2073656E
   \              6400        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "and receive data">`:
   \   00000000   616E64207265       DC8 "and receive data"
   \              636569766520
   \              6461746100  
   \   00000011   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rAssociate Confirm w...">`:
   \   00000000   0A0D4173736F       DC8 "\012\015Associate Confirm wasn't successful... \012\015\012\015"
   \              636961746520
   \              436F6E666972
   \              6D207761736E
   \              277420737563
   \              636573736675
   \              6C2E2E2E200A
   \              0D0A0D00    
   \   0000002E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Scan...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D5363616E20       DC8 2DH, 53H, 63H, 61H, 6EH, 20H, 52H, 65H
   \              5265        
   \   00000018   717565737420       DC8 71H, 75H, 65H, 73H, 74H, 20H, 6DH, 65H
   \              6D65        
   \   00000020   737361676520       DC8 73H, 73H, 61H, 67H, 65H, 20H, 74H, 6FH
   \              746F        
   \   00000028   20746865204D       DC8 20H, 74H, 68H, 65H, 20H, 4DH, 41H, 43H
   \              4143        
   \   00000030   2E2E2E00           DC8 2EH, 2EH, 2EH, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Done\\n\\r">`:
   \   00000000   446F6E650A0D       DC8 "Done\012\015"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Invalid parameter!\\n\\r">`:
   \   00000000   496E76616C69       DC8 "Invalid parameter!\012\015"
   \              642070617261
   \              6D6574657221
   \              0A0D00      
   \   00000015   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Message allocation fa...">`:
   \   00000000   4D6573736167       DC8 "Message allocation failed!\012\015"
   \              6520616C6C6F
   \              636174696F6E
   \              206661696C65
   \              64210A0D00  
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Asso...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D4173736F63       DC8 2DH, 41H, 73H, 73H, 6FH, 63H, 69H, 61H
   \              6961        
   \   00000018   746520526571       DC8 74H, 65H, 20H, 52H, 65H, 71H, 75H, 65H
   \              7565        
   \   00000020   7374206D6573       DC8 73H, 74H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              7361        
   \   00000028   676520746F20       DC8 67H, 65H, 20H, 74H, 6FH, 20H, 74H, 68H
   \              7468        
   \   00000030   65204D41432E       DC8 65H, 20H, 4DH, 41H, 43H, 2EH, 2EH, 2EH
   \              2E2E        
   \   00000038   00                 DC8 0
   \   00000039   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Application">`:
   \   00000000   4170706C6963       DC8 "Application"
   \              6174696F6E00

   \                                 In section .rodata, align 4
   \                     `?<Constant "    started">`:
   \   00000000   202020207374       DC8 "    started"
   \              617274656400

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     ASP_APP_SapHandler               8
     AppPollWaitTimeout              16
     AppTask                         16
     App_GetParam                    32
     App_HandleAssociateConfirm       8
     App_HandleKeys                   8
     App_HandleMcpsInput              8
     App_HandleMlmeInput              4
     App_HandleScanActiveConfirm     32
     App_SendAssociateRequest        16
     App_SetParam                    32
     App_StartScan                   16
     App_TransmitUartData             8
     App_WaitMsg                      4
     DeepSleepWakeupStackProc         0
     MApp_init                        8
     MCPS_NWK_SapHandler              8
     MLME_NWK_SapHandler              8
     UartRxCallBack                   8


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     mCoordInfo                                   24
     maMyAddress                                   8
     mAddrMode                                     1
     mpPacket                                      4
     mMsduHandle                                   1
     mcPendingPackets                              1
     mWaitPollConfirm                              1
     dataSet                                       1
     dataGet                                       1
     dataUGet                                      1
     mPollInterval                                 2
     mMlmeNwkInputQueue                            8
     mMcpsNwkInputQueue                            8
     mTimer_c                                      1
     gState                                        1
     gaNvAppDataSet                                8
     MApp_init                                   122
     AppTask                                     712
     UartRxCallBack                               32
     App_StartScan                               106
     App_HandleScanActiveConfirm                 170
     App_SendAssociateRequest                    126
     App_HandleAssociateConfirm                   70
     App_HandleMlmeInput                          44
     App_HandleMcpsInput                          68
     App_WaitMsg                                  32
     App_TransmitUartData                        260
     keysBuffer                                   32
     keysReceived                                  1
     AppPollWaitTimeout                          102
     App_HandleKeys                              222
     DeepSleepWakeupStackProc                      2
     MLME_NWK_SapHandler                          30
     MCPS_NWK_SapHandler                          30
     ASP_APP_SapHandler                           22
     App_SetParam                                 42
     App_GetParam                                 42
     ??DataTable0                                  4
     ??DataTable0_1                                4
     ??DataTable0_2                                4
     ??DataTable0_3                                4
     ??DataTable0_4                                4
     ??DataTable0_5                                4
     ??DataTable0_6                                4
     ??DataTable0_7                                4
     ??DataTable0_8                                4
     ??DataTable0_9                                4
     ??DataTable0_10                               4
     ??DataTable1                                  4
     ??DataTable1_1                                4
     ??DataTable2                                  4
     ??DataTable2_1                                4
     ??DataTable2_2                                4
     ??DataTable2_3                                4
     ??DataTable2_4                                4
     ??DataTable2_5                                4
     ??DataTable2_6                                4
     ??DataTable2_7                                4
     ??DataTable3                                  4
     ??DataTable3_1                                4
     ??DataTable3_2                                4
     ??DataTable3_3                                4
     ??DataTable3_4                                4
     ??DataTable3_5                                4
     ??DataTable3_6                                4
     ??DataTable3_7                                4
     ??DataTable3_8                                4
     ??DataTable3_9                                4
     ??DataTable3_10                               4
     ??DataTable3_11                               4
     ??DataTable4                                  4
     ??DataTable4_1                                4
     ??DataTable4_2                                4
     ??DataTable4_3                                4
     ??DataTable4_4                                4
     ??DataTable5                                  4
     ??DataTable5_1                                4
     ??DataTable5_2                                4
     ??DataTable5_3                                4
     ??DataTable5_4                                4
     ??DataTable5_5                                4
     ??DataTable7                                  4
     ??DataTable8                                  4
     ??DataTable8_1                                4
     ??DataTable8_2                                4
     ??DataTable8_3                                4
     ??DataTable8_4                                4
     ??DataTable9                                  4
     ??DataTable9_1                                4
     ??DataTable10                                 4
     ??DataTable10_1                               4
     ??DataTable10_2                               4
     ??DataTable10_3                               4
     ??DataTable10_4                               4
     ??DataTable11                                 4
     ??DataTable13                                 4
     ??DataTable13_1                               4
     ??DataTable13_2                               4
     ??DataTable13_3                               4
     ??DataTable13_4                               4
     ??DataTable13_5                               4
     ??DataTable13_6                               4
     ??DataTable13_7                               4
     ??DataTable13_8                               4
     ??DataTable13_9                               4
     ??DataTable13_10                              4
     ??DataTable13_11                              4
     ??DataTable13_12                              4
     ??DataTable13_13                              4
     ??DataTable13_14                              4
     ??DataTable13_15                              4
     ?<Constant "\n\rPress any switch on...">     64
     ?<Constant "Press any key">                  16
     ?<Constant "to start.">                      12
     ?<Constant "Received an MLME-Beac...">       44
     ?<Constant "MyWirelessApp Demo No...">       84
     ?<Constant "Start scanning for a ...">       40
     ?<Constant "Start scanning">                 16
     ?<Constant "for coordinator">                16
     ?<Constant "Found a coordinator w...">       56
     ?<Constant "---------------------...">       56
     ?<Constant "\n\rAddress...........0x">       24
     ?<Constant "\n\rPAN ID............0x">       24
     ?<Constant "\n\rLogical Channel...0x">       24
     ?<Constant "\n\rBeacon Spec.......0x">       24
     ?<Constant "\n\rLink Quality......0x">       24
     ?<Constant "\n\r\n\r">                        8
     ?<Constant "Scan did not find a s...">       44
     ?<Constant "No coordinator">                 16
     ?<Constant "found.">                          8
     ?<Constant "Associating to PAN co...">       48
     ?<Constant "Associating to ">                16
     ?<Constant "PAN coordinator">                16
     ?<Constant "Successfully associat...">       48
     ?<Constant "We were assigned the ...">       40
     ?<Constant "\n\r\n\rReady to send and...">   56
     ?<Constant "Ready to send">                  16
     ?<Constant "and receive data">               20
     ?<Constant "\n\rAssociate Confirm w...">     48
     ?<Constant "Sending the MLME-Scan...">       52
     ?<Constant "Done\n\r">                        8
     ?<Constant "Invalid parameter!\n\r">         24
     ?<Constant "Message allocation fa...">       32
     ?<Constant "Sending the MLME-Asso...">       60
     ?<Constant "Application">                    12
     ?<Constant "    started">                    12

 
    95 bytes in section .bss
     1 byte  in section .data
 1 116 bytes in section .rodata
 2 530 bytes in section .text
 
 2 530 bytes of CODE  memory
 1 116 bytes of CONST memory
    96 bytes of DATA  memory

Errors: none
Warnings: none
