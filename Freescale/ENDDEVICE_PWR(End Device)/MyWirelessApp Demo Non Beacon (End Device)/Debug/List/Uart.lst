###############################################################################
#                                                                             #
#                                                       08/Dec/2015  21:07:35 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\UART\Uart.c                           #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\UART\Uart.c" -D gMacStandAlone_d=1    #
#                    -D gSAPMessagesEnableLlc_d=0 -D gZtcIncluded_d=0 -D      #
#                    gTargetMC1322xSRB=1 --preprocess "C:\Documents and       #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\List\" -lC "C:\Documents and   #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\List\" -lB "C:\Documents and   #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\List\" --diag_suppress         #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Debug\Obj\" --no_cse --no_unroll     #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\MacPhy\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Init\" -I "C:\Documents  #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\Interface\" -I "C:\Documents and     #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Configure\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Application\UartUtil\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\Application\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\TS\Interface\" -I "C:\Documents and          #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\SSM\TS\Source\" -I "C:\Documents     #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and         #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\SSM\ZTC\Source\" -I "C:\Documents    #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Interface\" -I "C:\Documents and             #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\LibInterface\" -I "C:\Documents  #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\Display\" -I "C:\Documents and        #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\Source\Keyboard\" -I             #
#                    "C:\Documents and Settings\Administrator\Desktop\Copy    #
#                    of MyWirelessApp Demo Non Beacon (End                    #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\NVM\" -I "C:\Documents and            #
#                    Settings\Administrator\Desktop\Copy of MyWirelessApp     #
#                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non      #
#                    Beacon (End Device)\PLM\Source\TMR\" -I "C:\Documents    #
#                    and Settings\Administrator\Desktop\Copy of               #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR       #
#                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"      #
#                    --interwork --cpu_mode thumb -On                         #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\List\Uart.lst                              #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\Copy of  #
#                    MyWirelessApp Demo Non Beacon (End                       #
#                    Device)\MyWirelessApp Demo Non Beacon (End               #
#                    Device)\Debug\Obj\Uart.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\PLM\Source\UART\Uart.c
      1          /*****************************************************************************
      2          * UART / SCI / USB / Serial Port implementation for ARM7
      3          *
      4          * (c) Copyright 2006, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          *
      8          * No part of this document must be reproduced in any form - including copied,
      9          * transcribed, printed or by any electronic means - without specific written
     10          * permission from Freescale Semiconductor.
     11          *
     12          *****************************************************************************/
     13          
     14          /* Note: This code is size optimized for the case where only one SCI port is
     15           * enabled. If both ports are enabled, it might be worthwhile to create
     16           * functions that take a port number as a parameter.
     17           */
     18          #include "Platform.h"
     19          #include "Uart_Interface.h"
     20          #include "Uart.h"
     21          #include "UartLowLevel.h"
     22          #include "Interrupt.h"
     23          #include "TS_Interface.h"
     24          
     25          #define FN_MASK  3UL
     26          #define FN_ALT  1
     27          
     28          void Uart1_TxIsr(UartWriteCallbackArgs_t* args);
     29          void Uart2_TxIsr(UartWriteCallbackArgs_t* args);
     30          void Uart1_RxIsr(UartReadCallbackArgs_t* args);
     31          void Uart2_RxIsr(UartReadCallbackArgs_t* args);
     32          
     33          void GpioUart1Init(void);
     34          void GpioUart2Init(void);
     35          
     36          
     37          
     38          /*****************************************************************************
     39          ******************************************************************************
     40          * Public memory definitions
     41          ******************************************************************************
     42          *****************************************************************************/
     43          
     44          /* if neither UART enabled, then no code or data */
     45          #if gUart1_Enabled_d || gUart2_Enabled_d
     46          
     47          /* id for Uart task */

   \                                 In section .bss, align 1
     48          tsTaskID_t gUartTaskId;
   \                     gUartTaskId:
   \   00000000                      DS8 1
     49          
     50          /* Each port can store one unget byte. */
     51          #if gUart1_Enabled_d

   \                                 In section .bss, align 1
     52          static bool_t uart1_ungetFlag = FALSE;
   \                     uart1_ungetFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     53          static unsigned char uart1_ungetByte;
   \                     uart1_ungetByte:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     54          bool_t Uart1_TxInProgress = FALSE;
   \                     Uart1_TxInProgress:
   \   00000000                      DS8 1
     55          #endif
     56          
     57          #if gUart2_Enabled_d
     58          static bool_t uart2_ungetFlag = FALSE;
     59          static unsigned char uart2_ungetByte;
     60          bool_t Uart2_TxInProgress = FALSE;
     61          #endif
     62          
     63          /* The transmit code keeps a circular list of buffers to be sent. */
     64          /* Each SCI port has it's own list. */
     65          typedef struct SciTxBufRef_tag {
     66            unsigned char const *pBuf;
     67            void (*pfCallBack)(unsigned char const *pBuf);
     68          } SciTxBufRef_t;
     69          
     70          /* The leading index is the next position to store a buffer reference. */
     71          /* The trailing index is the buffer currently being transmitted. */
     72          /* Using a separate table for the buffer lengths reduces code size. */
     73          #if gUart1_Enabled_d

   \                                 In section .bss, align 4
     74          static SciTxBufRef_t maSci1TxBufRefTable[gUart_TransmitBuffers_c];
   \                     maSci1TxBufRefTable:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
     75          static index_t maSci1TxBufLenTable[gUart_TransmitBuffers_c];
   \                     maSci1TxBufLenTable:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     76          static index_t mSci1TxBufRefLeadingIndex;   /* Post-increment. */
   \                     mSci1TxBufRefLeadingIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     77          static index_t mSci1TxBufRefTrailingIndex;  /* Post-increment. */
   \                     mSci1TxBufRefTrailingIndex:
   \   00000000                      DS8 1
     78          
     79          /*Callback table and index pointers*/

   \                                 In section .bss, align 4
     80          static SciTxBufRef_t maSci1TxCallbackTable[gUart_TransmitBuffers_c];
   \                     maSci1TxCallbackTable:
   \   00000000                      DS8 24

   \                                 In section .bss, align 1
     81          static index_t maSci1TxCallbackLeadingIndex = 0; 
   \                     maSci1TxCallbackLeadingIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     82          static index_t maSci1TxCallbackTrailingIndex = 0; 
   \                     maSci1TxCallbackTrailingIndex:
   \   00000000                      DS8 1
     83          #endif
     84          
     85          #if gUart2_Enabled_d
     86          static SciTxBufRef_t maSci2TxBufRefTable[gUart_TransmitBuffers_c];
     87          static index_t maSci2TxBufLenTable[gUart_TransmitBuffers_c];
     88          static index_t mSci2TxBufRefLeadingIndex;   /* Post-increment. */
     89          static index_t mSci2TxBufRefTrailingIndex;  /* Post-increment. */
     90          /*Callback table and index pointers*/
     91          static SciTxBufRef_t maSci2TxCallbackTable[gUart_TransmitBuffers_c];
     92          static index_t maSci2TxCallbackLeadingIndex = 0; 
     93          static index_t maSci2TxCallbackTrailingIndex = 0; 
     94          #endif
     95          
     96          /* Each port has a small local circular Rx buffer to store data until the */
     97          /* application can retrieve it. In addition to the leading and trailing */
     98          /* indexes, the Rx code keeps a count of the number of bytes in the buffer. */
     99          #if gUart1_Enabled_d

   \                                 In section .bss, align 4
    100          static unsigned char maSci1RxBuf[gUart_ReceiveBufferSize_c];
   \                     maSci1RxBuf:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    101          static void (*pfSci1RxCallBack)(void);
   \                     pfSci1RxCallBack:
   \   00000000                      DS8 4
    102          #endif
    103          
    104          #if gUart2_Enabled_d
    105          static unsigned char maSci2RxBuf[gUart_ReceiveBufferSize_c];
    106          static void (*pfSci2RxCallBack)(void);
    107          #endif
    108          
    109          /*****************************************************************************
    110          ******************************************************************************
    111          * Private memory definitions
    112          ******************************************************************************
    113          *****************************************************************************/
    114          
    115          /* Keep track of the high water mark in the Rx circular buffer. */
    116          #if gUart_Debug_d
    117            #if gUart1_Enabled_d
    118            static index_t uart1RxBufHighWaterMark = 0;
    119            #endif /* gUart1_Enabled_d */
    120          
    121            #if gUart2_Enabled_d
    122            static index_t uart2RxBufHighWaterMark = 0;
    123            #endif /* gUart2_Enabled_d */
    124          #endif /* gUart_Debug_d */
    125          
    126          /*****************************************************************************
    127          ******************************************************************************
    128          * Public functions
    129          ******************************************************************************
    130          *****************************************************************************/
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void Uart_ClearErrors(void) {
   \                     Uart_ClearErrors:
   \   00000000   80B5               PUSH     {R7,LR}
    133          
    134          #if gUart1_Enabled_d
    135            UartClearErrors(UART_1);
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ........           BL       UartClearErrors
    136          #endif
    137          
    138          #if gUart2_Enabled_d
    139            UartClearErrors(UART_2);
    140          #endif
    141          
    142          }                                       /* Uart_ClearErrors() */
   \   00000008   09BC               POP      {R0,R3}
   \   0000000A   1847               BX       R3               ;; return
    143          
    144          
    145          /*****************************************************************************/
    146          
    147          /* Retrieve a byte from the driver's Rx buffer and store it at *pDst. */
    148          /* Return TRUE if a byte was retrieved; FALSE if the Rx buffer is empty. */

   \                                 In section .text, align 2, keep-with-next
    149          bool_t Uart1_GetByteFromRxBuffer(unsigned char *pDst) {
   \                     Uart1_GetByteFromRxBuffer:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    150          #if !gUart1_Enabled_d
    151            (void) pDst;
    152            return 0;
    153          #else  
    154          
    155            if (uart1_ungetFlag) {
   \   00000004   ....               LDR      R0,??DataTable6
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   07D0               BEQ      ??Uart1_GetByteFromRxBuffer_0
    156              uart1_ungetFlag = FALSE;
   \   0000000C   ....               LDR      R0,??DataTable6
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0170               STRB     R1,[R0, #+0]
    157              *pDst = uart1_ungetByte;
   \   00000012   ....               LDR      R0,??DataTable7
   \   00000014   0078               LDRB     R0,[R0, #+0]
   \   00000016   2070               STRB     R0,[R4, #+0]
    158              return TRUE;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   03E0               B        ??Uart1_GetByteFromRxBuffer_1
    159            } else  
    160            return UartGetByteFromRxBuffer(UART_1, pDst);
   \                     ??Uart1_GetByteFromRxBuffer_0:
   \   0000001C   2100               MOVS     R1,R4
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   ........           BL       UartGetByteFromRxBuffer
   \                     ??Uart1_GetByteFromRxBuffer_1:
   \   00000024   10BC               POP      {R4}
   \   00000026   08BC               POP      {R3}
   \   00000028   1847               BX       R3               ;; return
    161            
    162          #endif
    163          }                                       /* Uart1_GetBytesFromRxBuffer() */
    164          
    165          /**************************************/
    166          

   \                                 In section .text, align 2, keep-with-next
    167          bool_t Uart2_GetByteFromRxBuffer(unsigned char *pDst) {
   \                     Uart2_GetByteFromRxBuffer:
   \   00000000   0100               MOVS     R1,R0
    168          #if !gUart2_Enabled_d
    169            (void) pDst;
    170            return 0;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   7047               BX       LR               ;; return
    171          #else
    172            // unsigned char scic2;
    173          
    174            if (uart2_ungetFlag) {
    175              uart2_ungetFlag = FALSE;
    176              *pDst = uart2_ungetByte;
    177              return TRUE;
    178            } else
    179            return UartGetByteFromRxBuffer(UART_2, pDst);
    180            
    181          #endif
    182          }                                       /* Uart2_GetBytesFromRxBuffer() */
    183          
    184          /*****************************************************************************/
    185          
    186          /* Return TRUE if there is data still not sent. */

   \                                 In section .text, align 2, keep-with-next
    187          bool_t Uart1_IsTxActive(void) {
   \                     Uart1_IsTxActive:
   \   00000000   00B5               PUSH     {LR}
    188          #if !gUart1_Enabled_d
    189            return FALSE;
    190          #else
    191            return ((Uart1_TxInProgress) || (UART1_REGS_P->Utxcon != 32));
   \   00000002   ....               LDR      R0,??DataTable6_1
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   03D1               BNE      ??Uart1_IsTxActive_0
   \   0000000A   ....               LDR      R0,??DataTable8  ;; 0x80005010
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   2028               CMP      R0,#+32
   \   00000010   01D0               BEQ      ??Uart1_IsTxActive_1
   \                     ??Uart1_IsTxActive_0:
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   00E0               B        ??Uart1_IsTxActive_2
   \                     ??Uart1_IsTxActive_1:
   \   00000016   0020               MOVS     R0,#+0
   \                     ??Uart1_IsTxActive_2:
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
    192          #endif
    193          }                                            /* Uart1_IsTxActive() */      
    194          
    195          /**************************************/
    196          /* Return TRUE if there is data still not sent. */

   \                                 In section .text, align 2, keep-with-next
    197          bool_t Uart2_IsTxActive(void) {
    198          #if !gUart2_Enabled_d
    199            return FALSE;
   \                     Uart2_IsTxActive:
   \   00000000   0020               MOVS     R0,#+0
   \   00000002   7047               BX       LR               ;; return
    200          #else
    201            return ((Uart2_TxInProgress) || (UART2_REGS_P->Utxcon != 32));
    202          #endif
    203          }                                            /* Uart2_IsTxActive() */
    204          
    205          /*****************************************************************************/
    206          
    207          /* Initialize the serial port(s) and this module's local data. */

   \                                 In section .text, align 2, keep-with-next
    208          void Uart_ModuleInit(void) {
   \                     Uart_ModuleInit:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
    209            
    210            uint8_t res;
    211            UartConfig_t pConfig;
    212            UartCallbackFunctions_t pCallback;
    213            
    214          #if gUart1_Enabled_d
    215          
    216            //initialize GPIOs for UART1 and UART2 
    217            GpioUart1Init();  
   \   00000002   ........           BL       GpioUart1Init
    218          
    219            //configure the uart parameters 
    220            pConfig.UartParity = gUartParityNone_c;
   \   00000006   6846               MOV      R0,SP
   \   00000008   0021               MOVS     R1,#+0
   \   0000000A   0171               STRB     R1,[R0, #+4]
    221            pConfig.UartStopBits = gUartStopBits1_c;
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   4171               STRB     R1,[R0, #+5]
    222            pConfig.UartBaudrate = gUartDefaultBaud_c;
   \   00000012   9620               MOVS     R0,#+150
   \   00000014   C001               LSLS     R0,R0,#+7        ;; #+19200
   \   00000016   0090               STR      R0,[SP, #+0]
    223            pConfig.UartFlowControlEnabled = gUart1_EnableHWFlowControl_d;
   \   00000018   6846               MOV      R0,SP
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   8171               STRB     R1,[R0, #+6]
    224            pConfig.UartRTSActiveHigh = FALSE;
   \   0000001E   6846               MOV      R0,SP
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   C171               STRB     R1,[R0, #+7]
    225          
    226            //initialize the uart
    227            res = UartOpen(UART_1,PLATFORM_CLOCK);  
   \   00000024   ....               LDR      R1,??DataTable7_1  ;; 0x5dc0
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   ........           BL       UartOpen
   \   0000002C   0400               MOVS     R4,R0
    228            res |= UartSetConfig(UART_1, &pConfig);  
   \   0000002E   6946               MOV      R1,SP
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   ........           BL       UartSetConfig
   \   00000036   2043               ORRS     R0,R0,R4
   \   00000038   0400               MOVS     R4,R0
    229          
    230            UartSetCTSThreshold(UART_1, gUart_RxFlowControlSkew_d);
   \   0000003A   0821               MOVS     R1,#+8
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   ........           BL       UartSetCTSThreshold
    231          
    232            //configure the Uart Rx and Tx Threshold
    233            res |= UartSetTransmitterThreshold(UART_1, 5);
   \   00000042   0521               MOVS     R1,#+5
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   ........           BL       UartSetTransmitterThreshold
   \   0000004A   2043               ORRS     R0,R0,R4
   \   0000004C   0400               MOVS     R4,R0
    234            res |= UartSetReceiverThreshold(UART_1, 5);
   \   0000004E   0521               MOVS     R1,#+5
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   ........           BL       UartSetReceiverThreshold
   \   00000056   2043               ORRS     R0,R0,R4
   \   00000058   0400               MOVS     R4,R0
    235          
    236            //set pCallback functions
    237            pCallback.pfUartWriteCallback = Uart1_TxIsr;
   \   0000005A   ....               LDR      R0,??DataTable8_1
   \   0000005C   0390               STR      R0,[SP, #+12]
    238            pCallback.pfUartReadCallback = Uart1_RxIsr;
   \   0000005E   ....               LDR      R0,??DataTable8_2
   \   00000060   0290               STR      R0,[SP, #+8]
    239          
    240            res |= UartSetCallbackFunctions(UART_1, &pCallback);
   \   00000062   02A9               ADD      R1,SP,#+8
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   ........           BL       UartSetCallbackFunctions
   \   0000006A   2043               ORRS     R0,R0,R4
   \   0000006C   0400               MOVS     R4,R0
    241            /*set Half Flow Control*/
    242            #if (gUart1_EnableHalfFlowControl_d == TRUE)
    243              UartSetHalfFlowControl(UART_1, TRUE);
    244            #endif
    245          
    246            //mount the interrupts corresponding to UART driver
    247            IntAssignHandler(gUart1Int_c, (IntHandlerFunc_t)UartIsr1);
   \   0000006E   ....               LDR      R1,??DataTable8_3
   \   00000070   0120               MOVS     R0,#+1
   \   00000072   ........           BL       IntAssignHandler
    248            ITC_SetPriority(gUart1Int_c, gItcNormalPriority_c);
   \   00000076   0021               MOVS     R1,#+0
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   ........           BL       ITC_SetPriority
    249            //enable the interrupts corresponding to UART driver
    250            ITC_EnableInterrupt(gUart1Int_c);
   \   0000007E   0120               MOVS     R0,#+1
   \   00000080   ........           BL       ITC_EnableInterrupt
    251            
    252            /* Make sure we're not enabling the RX path yet. User must set the RX callback first */
    253            UartOpenCloseTransceiver(UART_1, BIT_RX_EN, FALSE);   
   \   00000084   0022               MOVS     R2,#+0
   \   00000086   0221               MOVS     R1,#+2
   \   00000088   0020               MOVS     R0,#+0
   \   0000008A   ........           BL       UartOpenCloseTransceiver
    254            
    255            UartReadData(UART_1, maSci1RxBuf, sizeof(maSci1RxBuf), TRUE);       
   \   0000008E   0123               MOVS     R3,#+1
   \   00000090   2022               MOVS     R2,#+32
   \   00000092   ....               LDR      R1,??DataTable10
   \   00000094   0020               MOVS     R0,#+0
   \   00000096   ........           BL       UartReadData
    256          #endif
    257          
    258          #if gUart2_Enabled_d
    259          
    260            //initialize GPIOs for UART1 and UART2
    261            GpioUart2Init();  
    262          
    263            //configure the uart parameters
    264            pConfig.UartParity = gUartParityNone_c;
    265            pConfig.UartStopBits = gUartStopBits1_c;
    266            pConfig.UartBaudrate = gUartDefaultBaud_c;
    267            pConfig.UartFlowControlEnabled = gUart2_EnableHWFlowControl_d;
    268            pConfig.UartRTSActiveHigh = FALSE;
    269            
    270            //initialize the uart
    271            UartOpen(UART_2,PLATFORM_CLOCK);
    272          
    273            UartSetConfig(UART_2,&pConfig);
    274            UartSetCTSThreshold(UART_2, gUart_RxFlowControlSkew_d);
    275          
    276            //configure the Uart Rx and Tx Threshold
    277            UartSetTransmitterThreshold(UART_2,5);
    278            UartSetReceiverThreshold(UART_2,5);
    279          
    280            //set pCallback functions
    281            pCallback.pfUartWriteCallback = Uart2_TxIsr;
    282            pCallback.pfUartReadCallback = Uart2_RxIsr;
    283            UartSetCallbackFunctions(UART_2,&pCallback);
    284          
    285            /*set Half Flow Control*/
    286            #if (gUart2_EnableHalfFlowControl_d == TRUE)
    287              UartSetHalfFlowControl(UART_2, TRUE);
    288            #endif
    289              //mount the interrupts corresponding to UART driver
    290            IntAssignHandler(gUart2Int_c, (IntHandlerFunc_t)UartIsr2);
    291            ITC_SetPriority(gUart2Int_c, gItcNormalPriority_c);
    292            //enable the interrupts corresponding to UART driver
    293            ITC_EnableInterrupt(gUart2Int_c);
    294          
    295            /* Make sure we're not enabling the RX path yet. User must set the RX callback first */
    296            UartOpenCloseTransceiver(UART_2, BIT_RX_EN, FALSE); 
    297            
    298            UartReadData(UART_2, maSci2RxBuf, sizeof(maSci2RxBuf), TRUE);
    299          
    300          #endif /* gUart2_Enabled_d */
    301          
    302            // global enable interrupts in AITC driver
    303            IntEnableIRQ();
   \   0000009A   0020               MOVS     R0,#+0
   \   0000009C   ........           BL       IntRestoreIRQ
    304            
    305            Uart_TaskInit();
   \   000000A0   ........           BL       Uart_TaskInit
    306          }                                       /* Uart_ModuleInit() */
   \   000000A4   1FBC               POP      {R0-R4}
   \   000000A6   08BC               POP      {R3}
   \   000000A8   1847               BX       R3               ;; return
    307          
    308          /*****************************************************************************/
    309          
    310          /* Rx ISR. If there is room, store the byte in the Rx circular buffer. */
    311          #if gUart1_Enabled_d

   \                                 In section .text, align 2, keep-with-next
    312          void Uart1_RxIsr(UartReadCallbackArgs_t* args) {
   \                     Uart1_RxIsr:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    313            
    314            /* Receive register full and no errors */
    315            if (gUartReadStatusComplete_c == args->UartStatus) {  
   \   00000004   2078               LDRB     R0,[R4, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   04D1               BNE      ??Uart1_RxIsr_0
    316            TS_SendEvent(gUartTaskId, gRxSci1Event_c);  
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   ....               LDR      R0,??DataTable10_1
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   ........           BL       TS_SendEvent
    317            }  
    318          }                                       /* Uart1_RxIsr() */
   \                     ??Uart1_RxIsr_0:
   \   00000014   10BC               POP      {R4}
   \   00000016   08BC               POP      {R3}
   \   00000018   1847               BX       R3               ;; return
    319          #endif /** gUart1_Enabled_d */
    320          
    321          /**************************************/
    322          
    323          #if gUart2_Enabled_d
    324          void Uart2_RxIsr(UartReadCallbackArgs_t* args) {
    325          
    326          /* Receive register full and no errors */
    327            if (gUartReadStatusComplete_c == args->UartStatus) {  
    328            TS_SendEvent(gUartTaskId, gRxSci2Event_c);  
    329            }
    330            
    331          }                                       /* Uart2_RxIsr() */
    332          #endif /* gUart2_Enabled_d */
    333          
    334          /*****************************************************************************/
    335          
    336          /* Set a pointer to the function to be called whenever a byte is received. */
    337          /* If the pointer is set to NULL, turn off the Rx interrupt and clear the Rx */
    338          /* buffer. */

   \                                 In section .text, align 2, keep-with-next
    339          void Uart1_SetRxCallBack(void (*pfCallBack)(void)) {
   \                     Uart1_SetRxCallBack:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    340          #if (gUart1_Enabled_d == FALSE)
    341            (void) pfCallBack;
    342          #else  /* gUart1_Enabled_d */
    343            pfSci1RxCallBack = pfCallBack;
   \   00000004   ....               LDR      R0,??DataTable11
   \   00000006   0460               STR      R4,[R0, #+0]
    344            UartOpenCloseTransceiver(UART_1, BIT_RX_EN, NULL != pfSci1RxCallBack);  
   \   00000008   ....               LDR      R0,??DataTable11
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   01D0               BEQ      ??Uart1_SetRxCallBack_0
   \   00000010   0122               MOVS     R2,#+1
   \   00000012   00E0               B        ??Uart1_SetRxCallBack_1
   \                     ??Uart1_SetRxCallBack_0:
   \   00000014   0022               MOVS     R2,#+0
   \                     ??Uart1_SetRxCallBack_1:
   \   00000016   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000018   120E               LSRS     R2,R2,#+24
   \   0000001A   0221               MOVS     R1,#+2
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   ........           BL       UartOpenCloseTransceiver
    345          #endif  /* gUart1_Enabled_d */
    346          }      /* Uart1_SetRxCallback() */
   \   00000022   10BC               POP      {R4}
   \   00000024   08BC               POP      {R3}
   \   00000026   1847               BX       R3               ;; return
    347          
    348          /**************************************/
    349          

   \                                 In section .text, align 2, keep-with-next
    350          void Uart2_SetRxCallBack(void (*pfCallBack)(void)) {
    351          #if (gUart2_Enabled_d == FALSE)
    352            (void) pfCallBack;
    353          #else
    354            pfSci2RxCallBack = pfCallBack;  
    355            UartOpenCloseTransceiver(UART_2, BIT_RX_EN, NULL != pfSci2RxCallBack);  
    356          #endif   /* gUart2_Enabled_d */
    357          }                                       /* Uart2_SetRxCallback() */
   \                     Uart2_SetRxCallBack:
   \   00000000   7047               BX       LR               ;; return
    358          
    359          /*****************************************************************************/
    360          
    361          /* Set the UART baud rate. */

   \                                 In section .text, align 2, keep-with-next
    362          void Uart1_SetBaud(UartBaudRate_t baudRate) {  
   \                     Uart1_SetBaud:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   83B0               SUB      SP,SP,#+12
   \   00000004   0700               MOVS     R7,R0
    363          #if (gUart1_Enabled_d == FALSE)
    364            (void) baudRate;
    365          #else  
    366            UartConfig_t Cfg;
    367            bool_t readStopped = FALSE;
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0600               MOVS     R6,R0
    368            register uint32_t i;
    369          
    370            UartErr_t err = UartGetStatus(UART_1);  
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   ........           BL       UartGetStatus
   \   00000010   0500               MOVS     R5,R0
    371            if(err != gUartErrUartNotOpen_c)
   \   00000012   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000014   2D0E               LSRS     R5,R5,#+24
   \   00000016   022D               CMP      R5,#+2
   \   00000018   1CD0               BEQ      ??Uart1_SetBaud_0
    372            {  
    373             for (i = 0; i < 2; i++)
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   0400               MOVS     R4,R0
   \                     ??Uart1_SetBaud_1:
   \   0000001E   022C               CMP      R4,#+2
   \   00000020   18D2               BCS      ??Uart1_SetBaud_0
    374             {  
    375                if(err == gUartErrReadOngoing_c) 
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   042D               CMP      R5,#+4
   \   00000028   05D1               BNE      ??Uart1_SetBaud_2
    376                {  
    377                  UartCancelReadData(UART_1);
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   ........           BL       UartCancelReadData
    378                  readStopped = TRUE;
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   0600               MOVS     R6,R0
   \   00000034   08E0               B        ??Uart1_SetBaud_3
    379                }
    380                else
    381                {  
    382                 if(err == gUartErrWriteOngoing_c)
   \                     ??Uart1_SetBaud_2:
   \   00000036   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000038   2D0E               LSRS     R5,R5,#+24
   \   0000003A   052D               CMP      R5,#+5
   \   0000003C   03D1               BNE      ??Uart1_SetBaud_4
    383                 {  
    384                   UartCancelWriteData(UART_1);
   \   0000003E   0020               MOVS     R0,#+0
   \   00000040   ........           BL       UartCancelWriteData
   \   00000044   00E0               B        ??Uart1_SetBaud_3
    385                 }  
    386                 else
    387                 {
    388                  break;
   \                     ??Uart1_SetBaud_4:
   \   00000046   05E0               B        ??Uart1_SetBaud_0
    389                 }
    390                }
    391                /* UartGetStatus is returning one error code at a time. Read back the status to check again */
    392                err = UartGetStatus(UART_1);
   \                     ??Uart1_SetBaud_3:
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   ........           BL       UartGetStatus
   \   0000004E   0500               MOVS     R5,R0
    393              }
   \   00000050   641C               ADDS     R4,R4,#+1
   \   00000052   E4E7               B        ??Uart1_SetBaud_1
    394            }  
    395            
    396            UartGetConfig(UART_1, &Cfg);
   \                     ??Uart1_SetBaud_0:
   \   00000054   6946               MOV      R1,SP
   \   00000056   0020               MOVS     R0,#+0
   \   00000058   ........           BL       UartGetConfig
    397            Cfg.UartBaudrate = baudRate;
   \   0000005C   0097               STR      R7,[SP, #+0]
    398            UartSetConfig(UART_1, &Cfg);  
   \   0000005E   6946               MOV      R1,SP
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   ........           BL       UartSetConfig
    399              
    400            if(TRUE == readStopped)
   \   00000066   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000068   360E               LSRS     R6,R6,#+24
   \   0000006A   012E               CMP      R6,#+1
   \   0000006C   05D1               BNE      ??Uart1_SetBaud_5
    401            {
    402              UartReadData(UART_1, maSci1RxBuf, sizeof(maSci1RxBuf), TRUE);
   \   0000006E   0123               MOVS     R3,#+1
   \   00000070   2022               MOVS     R2,#+32
   \   00000072   ....               LDR      R1,??DataTable10
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   ........           BL       UartReadData
    403            }    
    404          #endif /* gUart1_Enabled_d */
    405          }                                       /* Uart1_SetBaud() */
   \                     ??Uart1_SetBaud_5:
   \   0000007A   F7BC               POP      {R0-R2,R4-R7}
   \   0000007C   08BC               POP      {R3}
   \   0000007E   1847               BX       R3               ;; return
    406          
    407          /**************************************/
    408          

   \                                 In section .text, align 2, keep-with-next
    409          void Uart2_SetBaud(UartBaudRate_t baudRate) {
    410          #if (gUart2_Enabled_d == FALSE)
    411            (void) baudRate;
    412          #else
    413            UartConfig_t Cfg;
    414            bool_t readStopped = FALSE;
    415            register uint32_t i;
    416          
    417            UartErr_t err = UartGetStatus(UART_2);  
    418            if(err != gUartErrUartNotOpen_c)
    419            {  
    420             for (i = 0; i < 2; i++)
    421             {  
    422                if(err == gUartErrReadOngoing_c) 
    423                {  
    424                  UartCancelReadData(UART_2);
    425                  readStopped = TRUE;
    426                }
    427                else
    428                {  
    429                 if(err == gUartErrWriteOngoing_c)
    430                 {  
    431                   UartCancelWriteData(UART_2);
    432                 }  
    433                 else
    434                 {
    435                  break;
    436                 }
    437                }
    438                /* UartGetStatus is returning one error code at a time. Read back the status to check again */
    439                err = UartGetStatus(UART_2);
    440              }
    441            }  
    442            
    443            UartGetConfig(UART_2, &Cfg);
    444            Cfg.UartBaudrate = baudRate;
    445            UartSetConfig(UART_2, &Cfg);  
    446              
    447            if(TRUE == readStopped)
    448            {
    449              UartReadData(UART_2, maSci2RxBuf, sizeof(maSci2RxBuf), TRUE);
    450            } 
    451          #endif /* gUart2_Enabled_d */
    452          }                                       /* Uart2_SetBaud() */
   \                     Uart2_SetBaud:
   \   00000000   7047               BX       LR               ;; return
    453          
    454          /*****************************************************************************/
    455          
    456          /* Begin transmitting size bytes of data from *pBuffer. */
    457          /* Returns FALSE if there are no more slots in the buffer reference table. */

   \                                 In section .text, align 2, keep-with-next
    458          bool_t Uart1_Transmit(unsigned char const *pBuf, index_t bufLen, void (*pfCallBack)(unsigned char const *pBuf)) {
   \                     Uart1_Transmit:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1400               MOVS     R4,R2
    459          #if (gUart1_Enabled_d == FALSE)
    460            (void) pBuf;
    461            (void) bufLen;
    462            (void) pfCallBack;
    463            return FALSE;
    464          #else
    465            /* Handle empty buffers. */
    466            if (!bufLen) {
   \   00000008   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000000A   2D0E               LSRS     R5,R5,#+24
   \   0000000C   002D               CMP      R5,#+0
   \   0000000E   04D1               BNE      ??Uart1_Transmit_0
    467              (*pfCallBack)(pBuf);
   \   00000010   3000               MOVS     R0,R6
   \   00000012   ........           BL       __iar_via_R4
    468              return TRUE;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   3AE0               B        ??Uart1_Transmit_1
    469            }
    470          
    471            /* Room for one more? */
    472            if (maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex]) {
   \                     ??Uart1_Transmit_0:
   \   0000001A   ....               LDR      R0,??DataTable12
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   ....               LDR      R1,??DataTable12_1
   \   00000020   085C               LDRB     R0,[R1, R0]
   \   00000022   0028               CMP      R0,#+0
   \   00000024   01D0               BEQ      ??Uart1_Transmit_2
    473              return FALSE;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   32E0               B        ??Uart1_Transmit_1
    474              
    475            }
    476          
    477            maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pBuf = pBuf;
   \                     ??Uart1_Transmit_2:
   \   0000002A   ....               LDR      R0,??DataTable12
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   0821               MOVS     R1,#+8
   \   00000030   4843               MULS     R0,R1,R0
   \   00000032   ....               LDR      R1,??DataTable12_2
   \   00000034   0E50               STR      R6,[R1, R0]
    478            maSci1TxBufRefTable[mSci1TxBufRefLeadingIndex].pfCallBack = pfCallBack;
   \   00000036   ....               LDR      R0,??DataTable12
   \   00000038   0078               LDRB     R0,[R0, #+0]
   \   0000003A   0821               MOVS     R1,#+8
   \   0000003C   4843               MULS     R0,R1,R0
   \   0000003E   ....               LDR      R1,??DataTable12_2
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   4460               STR      R4,[R0, #+4]
    479            /* This has to be last, in case the Tx ISR finishes with the previous */
    480            /* buffer while this function is executing. */
    481            maSci1TxBufLenTable[mSci1TxBufRefLeadingIndex] = bufLen;
   \   00000044   ....               LDR      R0,??DataTable12
   \   00000046   0078               LDRB     R0,[R0, #+0]
   \   00000048   ....               LDR      R1,??DataTable12_1
   \   0000004A   0D54               STRB     R5,[R1, R0]
    482          
    483            if (++mSci1TxBufRefLeadingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
   \   0000004C   ....               LDR      R0,??DataTable12
   \   0000004E   0078               LDRB     R0,[R0, #+0]
   \   00000050   401C               ADDS     R0,R0,#+1
   \   00000052   ....               LDR      R1,??DataTable12
   \   00000054   0870               STRB     R0,[R1, #+0]
   \   00000056   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000058   000E               LSRS     R0,R0,#+24
   \   0000005A   0328               CMP      R0,#+3
   \   0000005C   02D3               BCC      ??Uart1_Transmit_3
    484            {
    485                mSci1TxBufRefLeadingIndex = 0;
   \   0000005E   ....               LDR      R0,??DataTable12
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   0170               STRB     R1,[R0, #+0]
    486            }  
    487            
    488            if(!Uart1_TxInProgress) 
   \                     ??Uart1_Transmit_3:
   \   00000064   ....               LDR      R0,??DataTable6_1
   \   00000066   0078               LDRB     R0,[R0, #+0]
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   10D1               BNE      ??Uart1_Transmit_4
    489            {
    490               /* No buffer is pending for transmission */
    491              
    492               /* Enable the transmit interrupt. Harmless if the interrupt is already */
    493               /* enabled. */
    494               Uart1_TxInProgress = TRUE;
   \   0000006C   ....               LDR      R0,??DataTable6_1
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   0170               STRB     R1,[R0, #+0]
    495               UartOpenTransmitter(UART_1);
   \   00000072   0122               MOVS     R2,#+1
   \   00000074   0121               MOVS     R1,#+1
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   ........           BL       UartOpenCloseTransceiver
    496               UartWriteData(UART_1, (uint8_t*) pBuf, bufLen);     
   \   0000007C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000007E   2D0E               LSRS     R5,R5,#+24
   \   00000080   2A00               MOVS     R2,R5
   \   00000082   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   00000084   120C               LSRS     R2,R2,#+16
   \   00000086   3100               MOVS     R1,R6
   \   00000088   0020               MOVS     R0,#+0
   \   0000008A   ........           BL       UartWriteData
    497            } 
    498          
    499          
    500            return TRUE;
   \                     ??Uart1_Transmit_4:
   \   0000008E   0120               MOVS     R0,#+1
   \                     ??Uart1_Transmit_1:
   \   00000090   70BC               POP      {R4-R6}
   \   00000092   08BC               POP      {R3}
   \   00000094   1847               BX       R3               ;; return
    501          #endif /* gUart1_Enabled_d */
    502          }                                       /* Uart1_Transmit() */
    503          
    504          /**************************************/
    505          

   \                                 In section .text, align 2, keep-with-next
    506          bool_t Uart2_Transmit(unsigned char const *pBuf, index_t bufLen, void (*pfCallBack)(unsigned char const *pBuf)) {
   \                     Uart2_Transmit:
   \   00000000   0300               MOVS     R3,R0
    507          #if (gUart2_Enabled_d == FALSE)
    508            (void) pBuf;
    509            (void) bufLen;
    510            (void) pfCallBack;
    511            return FALSE;
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   7047               BX       LR               ;; return
    512          #else
    513            /* Handle empty buffers. */
    514            if (!bufLen) {
    515              (*pfCallBack)(pBuf);
    516              return TRUE;
    517            }
    518          
    519            /* Room for one more? */
    520            if (maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex]) {
    521              return FALSE;
    522            }
    523          
    524            maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pBuf = pBuf;
    525            maSci2TxBufRefTable[mSci2TxBufRefLeadingIndex].pfCallBack = pfCallBack;
    526            /* This has to be last, in case the Tx ISR finishes with the previous */
    527            /* buffer while this function is executing. */
    528            maSci2TxBufLenTable[mSci2TxBufRefLeadingIndex] = bufLen;
    529          
    530            if (++mSci2TxBufRefLeadingIndex >= NumberOfElements(maSci2TxBufRefTable)) 
    531            {
    532              mSci2TxBufRefLeadingIndex = 0;
    533            }
    534          
    535            if(!Uart2_TxInProgress)
    536            {
    537             /* No buffer is pending for transmission */ 
    538              
    539             /* Enable the transmit interrupt. Harmless if the interrupt is already */
    540             /* enabled. */
    541             Uart2_TxInProgress = TRUE; 
    542             UartOpenTransmitter(UART_2);    
    543             UartWriteData(UART_2, (uint8_t*) pBuf, bufLen);
    544            }
    545            
    546            return TRUE;
    547          #endif  /* gUart2_Enabled_d */
    548          }                                       /* Uart2_Transmit() */
    549          
    550          /*****************************************************************************/
    551          
    552          /* Transmit ISR. */
    553          #if (gUart1_Enabled_d == TRUE)

   \                                 In section .text, align 2, keep-with-next
    554          void Uart1_TxIsr(UartWriteCallbackArgs_t* args) {
   \                     Uart1_TxIsr:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
    555             void (*pfCallBack)(unsigned char const *pBuf);
    556          
    557            /* Finished with the current buffer */
    558          
    559            /* Mark this one as done, and call the callback. */
    560            maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] = 0;
   \   00000004   ....               LDR      R0,??DataTable12_3
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   ....               LDR      R1,??DataTable12_1
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   0A54               STRB     R2,[R1, R0]
    561            pfCallBack = *maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pfCallBack;
   \   0000000E   ....               LDR      R0,??DataTable12_3
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   0821               MOVS     R1,#+8
   \   00000014   4843               MULS     R0,R1,R0
   \   00000016   ....               LDR      R1,??DataTable12_2
   \   00000018   0818               ADDS     R0,R1,R0
   \   0000001A   4068               LDR      R0,[R0, #+4]
   \   0000001C   0400               MOVS     R4,R0
    562              
    563            if(pfCallBack)
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   0028               CMP      R0,#+0
   \   00000022   23D0               BEQ      ??Uart1_TxIsr_0
    564            {
    565                /*Signal uart task that we got a callback to be executed*/
    566                TS_SendEvent(gUartTaskId, gTxSci1Event_c);
   \   00000024   0421               MOVS     R1,#+4
   \   00000026   ....               LDR      R0,??DataTable10_1
   \   00000028   0078               LDRB     R0,[R0, #+0]
   \   0000002A   ........           BL       TS_SendEvent
    567              
    568                /*add callback information to callback table*/
    569                maSci1TxCallbackTable[maSci1TxCallbackLeadingIndex].pfCallBack = pfCallBack;
   \   0000002E   ....               LDR      R0,??DataTable12_4
   \   00000030   0078               LDRB     R0,[R0, #+0]
   \   00000032   0821               MOVS     R1,#+8
   \   00000034   4843               MULS     R0,R1,R0
   \   00000036   ....               LDR      R1,??DataTable12_5
   \   00000038   0818               ADDS     R0,R1,R0
   \   0000003A   4460               STR      R4,[R0, #+4]
    570                maSci1TxCallbackTable[maSci1TxCallbackLeadingIndex].pBuf = maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf;
   \   0000003C   ....               LDR      R0,??DataTable12_4
   \   0000003E   0078               LDRB     R0,[R0, #+0]
   \   00000040   0821               MOVS     R1,#+8
   \   00000042   4843               MULS     R0,R1,R0
   \   00000044   ....               LDR      R1,??DataTable12_5
   \   00000046   ....               LDR      R2,??DataTable12_3
   \   00000048   1278               LDRB     R2,[R2, #+0]
   \   0000004A   0823               MOVS     R3,#+8
   \   0000004C   5A43               MULS     R2,R3,R2
   \   0000004E   ....               LDR      R3,??DataTable12_2
   \   00000050   9A58               LDR      R2,[R3, R2]
   \   00000052   0A50               STR      R2,[R1, R0]
    571                /*increment and wrap around leading index*/
    572                if (++maSci1TxCallbackLeadingIndex >= NumberOfElements(maSci1TxBufRefTable))
   \   00000054   ....               LDR      R0,??DataTable12_4
   \   00000056   0078               LDRB     R0,[R0, #+0]
   \   00000058   401C               ADDS     R0,R0,#+1
   \   0000005A   ....               LDR      R1,??DataTable12_4
   \   0000005C   0870               STRB     R0,[R1, #+0]
   \   0000005E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000060   000E               LSRS     R0,R0,#+24
   \   00000062   0328               CMP      R0,#+3
   \   00000064   02D3               BCC      ??Uart1_TxIsr_0
    573                {
    574                  maSci1TxCallbackLeadingIndex = 0;
   \   00000066   ....               LDR      R0,??DataTable12_4
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   0170               STRB     R1,[R0, #+0]
    575                }    
    576            }      
    577            
    578            /* Increment to the next buffer. */  
    579            if (++mSci1TxBufRefTrailingIndex >= NumberOfElements(maSci1TxBufRefTable)) 
   \                     ??Uart1_TxIsr_0:
   \   0000006C   ....               LDR      R0,??DataTable12_3
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   401C               ADDS     R0,R0,#+1
   \   00000072   ....               LDR      R1,??DataTable12_3
   \   00000074   0870               STRB     R0,[R1, #+0]
   \   00000076   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000078   000E               LSRS     R0,R0,#+24
   \   0000007A   0328               CMP      R0,#+3
   \   0000007C   02D3               BCC      ??Uart1_TxIsr_1
    580            {
    581               mSci1TxBufRefTrailingIndex = 0;
   \   0000007E   ....               LDR      R0,??DataTable12_3
   \   00000080   0021               MOVS     R1,#+0
   \   00000082   0170               STRB     R1,[R0, #+0]
    582            }
    583              
    584            if(maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex] != 0)
   \                     ??Uart1_TxIsr_1:
   \   00000084   ....               LDR      R0,??DataTable12_3
   \   00000086   0078               LDRB     R0,[R0, #+0]
   \   00000088   ....               LDR      R1,??DataTable12_1
   \   0000008A   085C               LDRB     R0,[R1, R0]
   \   0000008C   0028               CMP      R0,#+0
   \   0000008E   0FD0               BEQ      ??Uart1_TxIsr_2
    585            {
    586               /* Write the next buffer. */       
    587               UartWriteData(UART_1, (uint8_t*)maSci1TxBufRefTable[mSci1TxBufRefTrailingIndex].pBuf, maSci1TxBufLenTable[mSci1TxBufRefTrailingIndex]);
   \   00000090   ....               LDR      R0,??DataTable12_3
   \   00000092   0078               LDRB     R0,[R0, #+0]
   \   00000094   ....               LDR      R1,??DataTable12_1
   \   00000096   0A5C               LDRB     R2,[R1, R0]
   \   00000098   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000009A   120C               LSRS     R2,R2,#+16
   \   0000009C   ....               LDR      R0,??DataTable12_3
   \   0000009E   0078               LDRB     R0,[R0, #+0]
   \   000000A0   0821               MOVS     R1,#+8
   \   000000A2   4843               MULS     R0,R1,R0
   \   000000A4   ....               LDR      R1,??DataTable12_2
   \   000000A6   0958               LDR      R1,[R1, R0]
   \   000000A8   0020               MOVS     R0,#+0
   \   000000AA   ........           BL       UartWriteData
   \   000000AE   02E0               B        ??Uart1_TxIsr_3
    588            }
    589            else
    590            {
    591               Uart1_TxInProgress = FALSE;
   \                     ??Uart1_TxIsr_2:
   \   000000B0   ....               LDR      R0,??DataTable12_6
   \   000000B2   0021               MOVS     R1,#+0
   \   000000B4   0170               STRB     R1,[R0, #+0]
    592            }         
    593          }                                       /* Uart1_TxIsr() */
   \                     ??Uart1_TxIsr_3:
   \   000000B6   31BC               POP      {R0,R4,R5}
   \   000000B8   08BC               POP      {R3}
   \   000000BA   1847               BX       R3               ;; return
    594          #endif /* gUart1_Enabled_d */
    595          
    596          /**************************************/
    597          
    598          #if (gUart2_Enabled_d == TRUE)
    599          void Uart2_TxIsr(UartWriteCallbackArgs_t* args) {
    600            void (*pfCallBack)(unsigned char const *pBuf);
    601          
    602            /* Finished with the current buffer */
    603          
    604            /* Mark this one as done, and call the callback. */
    605            maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] = 0;
    606            pfCallBack = *maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pfCallBack;
    607          
    608            if (pfCallBack)
    609            {
    610                /*Signal uart task that we got a callback to be executed*/
    611                TS_SendEvent(gUartTaskId, gTxSci2Event_c);
    612                /*add callback information to callback table*/
    613                maSci2TxCallbackTable[maSci2TxCallbackLeadingIndex].pfCallBack = pfCallBack;
    614                maSci2TxCallbackTable[maSci2TxCallbackLeadingIndex].pBuf = maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf;
    615                /*increment and wrap around leading index*/  
    616                if (++maSci2TxCallbackLeadingIndex >= NumberOfElements(maSci2TxBufRefTable))
    617                {
    618                  maSci2TxCallbackLeadingIndex = 0;
    619                }    
    620            }
    621              
    622            /* Increment to the next buffer. */
    623          
    624            if (++mSci2TxBufRefTrailingIndex >= NumberOfElements(maSci2TxBufRefTable))
    625            {
    626                mSci2TxBufRefTrailingIndex = 0;
    627            }
    628              
    629            if(maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex] != 0)
    630            {
    631                 /* Write the next buffer. */       
    632                 UartWriteData(UART_2, (uint8_t*)maSci2TxBufRefTable[mSci2TxBufRefTrailingIndex].pBuf, maSci2TxBufLenTable[mSci2TxBufRefTrailingIndex]);
    633            }
    634            else
    635            {
    636               Uart2_TxInProgress = FALSE;
    637            }  
    638          }                                       /* Uart2_TxIsr() */
    639          #endif /* gUart2_Enabled_d */
    640          
    641          /*****************************************************************************/
    642          
    643          /* Shut down the serial port(s). */

   \                                 In section .text, align 2, keep-with-next
    644          void Uart_ModuleUninit(void) {
   \                     Uart_ModuleUninit:
   \   00000000   80B5               PUSH     {R7,LR}
    645          #if gUart1_Enabled_d
    646            UartClose(UART_1);
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ........           BL       UartClose
    647          #endif /* gUart1_Enabled_d */
    648          
    649          #if gUart2_Enabled_d
    650            UartClose(UART_2);
    651          #endif /* gUart2_Enabled_d */
    652          }                                       /* Uart_ModuleUninit() */
   \   00000008   09BC               POP      {R0,R3}
   \   0000000A   1847               BX       R3               ;; return
    653          
    654          /*****************************************************************************/
    655          
    656          /* Unget a byte: store the byte so that it will be returned by the next call */
    657          /* to the get byte function. Also call the Rx call back. */
    658          

   \                                 In section .text, align 2, keep-with-next
    659          void Uart1_UngetByte(unsigned char byte) {
   \                     Uart1_UngetByte:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    660          #if (gUart1_Enabled_d == FALSE)
    661            (void) byte;
    662          #else
    663            /* If the un get flag is already true, there isn't anything we can */
    664            /* do about it. Not much point in checking. Its up to the called to */
    665            /* use this function correctly. */
    666            uart1_ungetFlag = TRUE;
   \   00000004   ....               LDR      R0,??DataTable12_7
   \   00000006   0121               MOVS     R1,#+1
   \   00000008   0170               STRB     R1,[R0, #+0]
    667            uart1_ungetByte = byte;
   \   0000000A   ....               LDR      R0,??DataTable12_8
   \   0000000C   0470               STRB     R4,[R0, #+0]
    668          
    669            /* Likewise, it is the caller's responsibility to not call this function */
    670            /* if the call back pointer is not valid. */
    671            if(pfSci1RxCallBack != NULL)
   \   0000000E   ....               LDR      R0,??DataTable12_9
   \   00000010   0068               LDR      R0,[R0, #+0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   03D0               BEQ      ??Uart1_UngetByte_0
    672            {  
    673             pfSci1RxCallBack();
   \   00000016   ....               LDR      R0,??DataTable12_9
   \   00000018   0068               LDR      R0,[R0, #+0]
   \   0000001A   ........           BL       __iar_via_R0
    674            } 
    675          
    676          #endif /* gUart1_Enabled_d */
    677          }                                       /* Uart1_UngetByte() */
   \                     ??Uart1_UngetByte_0:
   \   0000001E   10BC               POP      {R4}
   \   00000020   08BC               POP      {R3}
   \   00000022   1847               BX       R3               ;; return
    678          

   \                                 In section .text, align 2, keep-with-next
    679          void Uart2_UngetByte(unsigned char byte) {
    680          #if (gUart2_Enabled_d == FALSE)
    681            (void) byte;
    682          #else
    683            uart2_ungetFlag = TRUE;
    684            uart2_ungetByte = byte;
    685            if(pfSci2RxCallBack != NULL)
    686            {  
    687             pfSci2RxCallBack();
    688            } 
    689          #endif  /* gUart2_Enabled_d */
    690          }                                       /* Uart2_UngetByte() */
   \                     Uart2_UngetByte:
   \   00000000   7047               BX       LR               ;; return
    691          
    692          
    693          
    694          

   \                                 In section .text, align 2, keep-with-next
    695          uint32_t Uart1_RxBufferByteCount() {
   \                     Uart1_RxBufferByteCount:
   \   00000000   80B5               PUSH     {R7,LR}
    696            return UartGetUnreadBytesNumber(UART_1);
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   ........           BL       UartGetUnreadBytesNumber
   \   00000008   0ABC               POP      {R1,R3}
   \   0000000A   1847               BX       R3               ;; return
    697            
    698          }
    699          

   \                                 In section .text, align 2, keep-with-next
    700          uint32_t Uart2_RxBufferByteCount() {
   \                     Uart2_RxBufferByteCount:
   \   00000000   80B5               PUSH     {R7,LR}
    701            return UartGetUnreadBytesNumber(UART_2);
   \   00000002   0120               MOVS     R0,#+1
   \   00000004   ........           BL       UartGetUnreadBytesNumber
   \   00000008   0ABC               POP      {R1,R3}
   \   0000000A   1847               BX       R3               ;; return
    702            
    703          }
    704          
    705          

   \                                 In section .text, align 2, keep-with-next
    706          void Uart_Task(event_t events)
    707          {
   \                     Uart_Task:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    708            void (*pfCallBack)(unsigned char const *pBuf);
    709            
    710          
    711          #if gUart1_Enabled_d
    712          
    713            if( events & gRxSci1Event_c ) {
   \   00000004   E007               LSLS     R0,R4,#+31
   \   00000006   07D5               BPL      ??Uart_Task_0
    714              if(pfSci1RxCallBack != NULL)
   \   00000008   ....               LDR      R0,??DataTable11
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   03D0               BEQ      ??Uart_Task_0
    715              {
    716               pfSci1RxCallBack();
   \   00000010   ....               LDR      R0,??DataTable11
   \   00000012   0068               LDR      R0,[R0, #+0]
   \   00000014   ........           BL       __iar_via_R0
    717              } 
    718            }
    719          
    720            if( events & gTxSci1Event_c ) {   
   \                     ??Uart_Task_0:
   \   00000018   6007               LSLS     R0,R4,#+29
   \   0000001A   25D5               BPL      ??Uart_Task_1
    721            
    722              /*Tx call back event received - run through the callback table and execute any pending
    723              Callbacks.
    724              */
    725              while (maSci1TxCallbackLeadingIndex != maSci1TxCallbackTrailingIndex) {    
   \                     ??Uart_Task_2:
   \   0000001C   ....               LDR      R0,??DataTable12_4
   \   0000001E   0078               LDRB     R0,[R0, #+0]
   \   00000020   ....               LDR      R1,??DataTable12_10
   \   00000022   0978               LDRB     R1,[R1, #+0]
   \   00000024   8842               CMP      R0,R1
   \   00000026   1FD0               BEQ      ??Uart_Task_1
    726                pfCallBack = maSci1TxCallbackTable[maSci1TxCallbackTrailingIndex].pfCallBack;
   \   00000028   ....               LDR      R0,??DataTable12_10
   \   0000002A   0078               LDRB     R0,[R0, #+0]
   \   0000002C   0821               MOVS     R1,#+8
   \   0000002E   4843               MULS     R0,R1,R0
   \   00000030   ....               LDR      R1,??DataTable12_5
   \   00000032   0818               ADDS     R0,R1,R0
   \   00000034   4068               LDR      R0,[R0, #+4]
   \   00000036   0500               MOVS     R5,R0
    727          
    728                if(pfCallBack != NULL)
   \   00000038   2800               MOVS     R0,R5
   \   0000003A   0028               CMP      R0,#+0
   \   0000003C   07D0               BEQ      ??Uart_Task_3
    729                {  
    730                 /*Call calback with buffer info as parameter*/
    731                 (*pfCallBack)(maSci1TxCallbackTable[maSci1TxCallbackTrailingIndex].pBuf);
   \   0000003E   ....               LDR      R0,??DataTable12_10
   \   00000040   0078               LDRB     R0,[R0, #+0]
   \   00000042   0821               MOVS     R1,#+8
   \   00000044   4843               MULS     R0,R1,R0
   \   00000046   ....               LDR      R1,??DataTable12_5
   \   00000048   0858               LDR      R0,[R1, R0]
   \   0000004A   ........           BL       __iar_via_R5
    732                } 
    733                
    734                /*increment and wrap around trailing index*/
    735                if (++maSci1TxCallbackTrailingIndex >= NumberOfElements(maSci1TxCallbackTable)) {
   \                     ??Uart_Task_3:
   \   0000004E   ....               LDR      R0,??DataTable12_10
   \   00000050   0078               LDRB     R0,[R0, #+0]
   \   00000052   401C               ADDS     R0,R0,#+1
   \   00000054   ....               LDR      R1,??DataTable12_10
   \   00000056   0870               STRB     R0,[R1, #+0]
   \   00000058   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000005A   000E               LSRS     R0,R0,#+24
   \   0000005C   0328               CMP      R0,#+3
   \   0000005E   DDD3               BCC      ??Uart_Task_2
    736                  maSci1TxCallbackTrailingIndex = 0;    
   \   00000060   ....               LDR      R0,??DataTable12_10
   \   00000062   0021               MOVS     R1,#+0
   \   00000064   0170               STRB     R1,[R0, #+0]
   \   00000066   D9E7               B        ??Uart_Task_2
    737                }
    738              } /* while */
    739            } /*if events ...*/
    740          
    741          
    742          #endif /* gUart1_Enabled_d */
    743            
    744            
    745          #if gUart2_Enabled_d
    746          
    747            if( events & gRxSci2Event_c ) {
    748              if(pfSci2RxCallBack != NULL)
    749              {  
    750               pfSci2RxCallBack();
    751              } 
    752            } 
    753          
    754            if( events & gTxSci2Event_c ) {
    755              /*Tx call back event received - run through the callback table and execute any pending
    756              Callbacks.
    757              */
    758              while (maSci2TxCallbackLeadingIndex != maSci2TxCallbackTrailingIndex) {    
    759                pfCallBack = maSci2TxCallbackTable[maSci2TxCallbackTrailingIndex].pfCallBack;
    760                if(pfCallBack != NULL)
    761                {  
    762                 /*Call calback with buffer info as parameter*/
    763                 (*pfCallBack)(maSci2TxCallbackTable[maSci2TxCallbackTrailingIndex].pBuf);
    764                } 
    765                /*increment and wrap around trailing index*/     
    766                if (++maSci2TxCallbackTrailingIndex >= NumberOfElements(maSci2TxCallbackTable)) {
    767                  maSci2TxCallbackTrailingIndex = 0;    
    768                }
    769              } /* while */
    770            } /*if events ...*/
    771          
    772          #endif /* gUart2_Enabled_d */
    773            
    774          }
   \                     ??Uart_Task_1:
   \   00000068   31BC               POP      {R0,R4,R5}
   \   0000006A   08BC               POP      {R3}
   \   0000006C   1847               BX       R3               ;; return
    775          
    776          #endif /* gUart1_Enabled_d || gUart2_Enabled_d */
    777          
    778          
    779          /*
    780            Initialize the uart task.
    781          */

   \                                 In section .text, align 2, keep-with-next
    782          void Uart_TaskInit(void)
    783          {
   \                     Uart_TaskInit:
   \   00000000   80B5               PUSH     {R7,LR}
    784          #if gUart1_Enabled_d || gUart2_Enabled_d
    785            gUartTaskId = TS_CreateTask(gTsUartTaskPriority_c, Uart_Task);
   \   00000002   ....               LDR      R1,??DataTable12_11
   \   00000004   2A20               MOVS     R0,#+42
   \   00000006   ........           BL       TS_CreateTask
   \   0000000A   ....               LDR      R1,??DataTable12_12
   \   0000000C   0870               STRB     R0,[R1, #+0]
    786          #endif /* gUart1_Enabled_d || gUart2_Enabled_d */
    787          }
   \   0000000E   09BC               POP      {R0,R3}
   \   00000010   1847               BX       R3               ;; return
    788          
    789          /*
    790            Uart1 GPIO .Initilization
    791          */

   \                                 In section .text, align 2, keep-with-next
    792          void GpioUart1Init(void)
    793          {
    794            register uint32_t tmpReg;
    795          
    796            GPIO.PuSelLo |= (GPIO_UART1_RTS_bit | GPIO_UART1_RX_bit);  // Pull-up select: UP type
   \                     GpioUart1Init:
   \   00000000   ....               LDR      R1,??DataTable12_13  ;; 0x80000030
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   A022               MOVS     R2,#+160
   \   00000006   9202               LSLS     R2,R2,#+10       ;; #+163840
   \   00000008   0A43               ORRS     R2,R2,R1
   \   0000000A   ....               LDR      R1,??DataTable12_13  ;; 0x80000030
   \   0000000C   0A60               STR      R2,[R1, #+0]
    797            GPIO.PuEnLo  |= (GPIO_UART1_RTS_bit | GPIO_UART1_RX_bit);  // Pull-up enable
   \   0000000E   ....               LDR      R1,??DataTable12_14  ;; 0x80000010
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   A022               MOVS     R2,#+160
   \   00000014   9202               LSLS     R2,R2,#+10       ;; #+163840
   \   00000016   0A43               ORRS     R2,R2,R1
   \   00000018   ....               LDR      R1,??DataTable12_14  ;; 0x80000010
   \   0000001A   0A60               STR      R2,[R1, #+0]
    798                  
    799            #if (gUart1_EnableHalfFlowControl_d == FALSE)
    800            tmpReg = GPIO.FuncSel0 & ~((FN_MASK << GPIO_UART1_RX_fnpos) | (FN_MASK << GPIO_UART1_TX_fnpos));
   \   0000001C   ....               LDR      R1,??DataTable12_15  ;; 0x80000018
   \   0000001E   0968               LDR      R1,[R1, #+0]
   \   00000020   0901               LSLS     R1,R1,#+4        ;; ZeroExtS R1,R1,#+4,#+4
   \   00000022   0909               LSRS     R1,R1,#+4
   \   00000024   0800               MOVS     R0,R1
    801            GPIO.FuncSel0 = tmpReg | ((FN_ALT << GPIO_UART1_RX_fnpos) | (FN_ALT << GPIO_UART1_TX_fnpos));
   \   00000026   A021               MOVS     R1,#+160
   \   00000028   C905               LSLS     R1,R1,#+23       ;; #+1342177280
   \   0000002A   0143               ORRS     R1,R1,R0
   \   0000002C   ....               LDR      R2,??DataTable12_15  ;; 0x80000018
   \   0000002E   1160               STR      R1,[R2, #+0]
    802            tmpReg = GPIO.FuncSel1 & ~((FN_MASK << GPIO_UART1_CTS_fnpos) | (FN_MASK << GPIO_UART1_RTS_fnpos));
   \   00000030   ....               LDR      R1,??DataTable12_16  ;; 0x8000001c
   \   00000032   0968               LDR      R1,[R1, #+0]
   \   00000034   0F22               MOVS     R2,#+15
   \   00000036   9143               BICS     R1,R1,R2
   \   00000038   0800               MOVS     R0,R1
    803            GPIO.FuncSel1 = tmpReg | ((FN_ALT << GPIO_UART1_CTS_fnpos) | (FN_ALT << GPIO_UART1_RTS_fnpos));
   \   0000003A   0521               MOVS     R1,#+5
   \   0000003C   0143               ORRS     R1,R1,R0
   \   0000003E   ....               LDR      R2,??DataTable12_16  ;; 0x8000001c
   \   00000040   1160               STR      R1,[R2, #+0]
    804            #else
    805              tmpReg = GPIO.FuncSel0 & ~((FN_MASK << GPIO_UART1_RX_fnpos) | (FN_MASK << GPIO_UART1_TX_fnpos));
    806              GPIO.FuncSel0 = tmpReg | ((FN_ALT << GPIO_UART1_RX_fnpos) | (FN_ALT << GPIO_UART1_TX_fnpos));
    807              tmpReg = GPIO.FuncSel1 & ~((FN_MASK << GPIO_UART1_CTS_fnpos) | (FN_MASK << GPIO_UART1_RTS_fnpos));
    808              GPIO.FuncSel1 = tmpReg | (FN_ALT << GPIO_UART1_RTS_fnpos);
    809              GPIO.DataResetLo = GPIO_UART1_CTS_bit;  // low
    810              GPIO.DirSetLo = GPIO_UART1_CTS_bit;  // output
    811            #endif
    812          }
   \   00000042   7047               BX       LR               ;; return
    813          
    814          
    815          /*
    816            Uart1 GPIO .Initilization
    817          */

   \                                 In section .text, align 2, keep-with-next
    818          void GpioUart2Init(void)
    819          {
    820            register uint32_t tmpReg;
    821          
    822            GPIO.PuSelLo |= (GPIO_UART2_RTS_bit | GPIO_UART2_RX_bit);  // Pull-up select: UP type
   \                     GpioUart2Init:
   \   00000000   ....               LDR      R1,??DataTable12_13  ;; 0x80000030
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   A022               MOVS     R2,#+160
   \   00000006   9203               LSLS     R2,R2,#+14       ;; #+2621440
   \   00000008   0A43               ORRS     R2,R2,R1
   \   0000000A   ....               LDR      R1,??DataTable12_13  ;; 0x80000030
   \   0000000C   0A60               STR      R2,[R1, #+0]
    823            GPIO.PuEnLo  |= (GPIO_UART2_RTS_bit | GPIO_UART2_RX_bit);  // Pull-up enable
   \   0000000E   ....               LDR      R1,??DataTable12_14  ;; 0x80000010
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   A022               MOVS     R2,#+160
   \   00000014   9203               LSLS     R2,R2,#+14       ;; #+2621440
   \   00000016   0A43               ORRS     R2,R2,R1
   \   00000018   ....               LDR      R1,??DataTable12_14  ;; 0x80000010
   \   0000001A   0A60               STR      R2,[R1, #+0]
    824          
    825            #if (gUart2_EnableHalfFlowControl_d == FALSE)
    826            tmpReg = GPIO.FuncSel1 & ~((FN_MASK << GPIO_UART2_CTS_fnpos) | (FN_MASK << GPIO_UART2_RTS_fnpos)\
    827            | (FN_MASK << GPIO_UART2_RX_fnpos) | (FN_MASK << GPIO_UART2_TX_fnpos));
   \   0000001C   ....               LDR      R1,??DataTable12_16  ;; 0x8000001c
   \   0000001E   0968               LDR      R1,[R1, #+0]
   \   00000020   ....               LDR      R2,??DataTable12_17  ;; 0xfffff00f
   \   00000022   0A40               ANDS     R2,R2,R1
   \   00000024   1000               MOVS     R0,R2
    828            GPIO.FuncSel1 = tmpReg | ((FN_ALT << GPIO_UART2_CTS_fnpos) | (FN_ALT << GPIO_UART2_RTS_fnpos)\
    829            | (FN_ALT << GPIO_UART2_RX_fnpos) | (FN_ALT << GPIO_UART2_TX_fnpos));
   \   00000026   AA21               MOVS     R1,#+170
   \   00000028   C900               LSLS     R1,R1,#+3        ;; #+1360
   \   0000002A   0143               ORRS     R1,R1,R0
   \   0000002C   ....               LDR      R2,??DataTable12_16  ;; 0x8000001c
   \   0000002E   1160               STR      R1,[R2, #+0]
    830            #else
    831              tmpReg = GPIO.FuncSel1 & ~((FN_MASK << GPIO_UART2_CTS_fnpos) | (FN_MASK << GPIO_UART2_RTS_fnpos)\
    832                | (FN_MASK << GPIO_UART2_RX_fnpos) | (FN_MASK << GPIO_UART2_TX_fnpos));
    833              GPIO.FuncSel1 = tmpReg | ((FN_ALT << GPIO_UART2_RTS_fnpos) | (FN_ALT << GPIO_UART2_RX_fnpos)\
    834                | (FN_ALT << GPIO_UART2_TX_fnpos));
    835              GPIO.DataResetLo = GPIO_UART2_CTS_bit;  // low
    836              GPIO.DirSetLo = GPIO_UART2_CTS_bit; // output
    837            #endif
    838          }
   \   00000030   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     uart1_ungetFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   ........           DC32     Uart1_TxInProgress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     uart1_ungetByte

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   C05D0000           DC32     0x5dc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   10500080           DC32     0x80005010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     Uart1_TxIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     Uart1_RxIsr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     UartIsr1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     maSci1RxBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   ........           DC32     gUartTaskId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     pfSci1RxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     mSci1TxBufRefLeadingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   ........           DC32     maSci1TxBufLenTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   ........           DC32     maSci1TxBufRefTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   ........           DC32     mSci1TxBufRefTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   ........           DC32     maSci1TxCallbackLeadingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   ........           DC32     maSci1TxCallbackTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   ........           DC32     Uart1_TxInProgress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   ........           DC32     uart1_ungetFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   ........           DC32     uart1_ungetByte

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   ........           DC32     pfSci1RxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   ........           DC32     maSci1TxCallbackTrailingIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   ........           DC32     Uart_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   ........           DC32     gUartTaskId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   30000080           DC32     0x80000030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   10000080           DC32     0x80000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   18000080           DC32     0x80000018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   1C000080           DC32     0x8000001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0FF0FFFF           DC32     0xfffff00f

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     GpioUart1Init                  0
     GpioUart2Init                  0
     Uart1_GetByteFromRxBuffer      8
     Uart1_IsTxActive               4
     Uart1_RxBufferByteCount        8
     Uart1_RxIsr                    8
     Uart1_SetBaud                 32
     Uart1_SetRxCallBack            8
     Uart1_Transmit                16
     Uart1_TxIsr                   16
     Uart1_UngetByte                8
     Uart2_GetByteFromRxBuffer      0
     Uart2_IsTxActive               0
     Uart2_RxBufferByteCount        8
     Uart2_SetBaud                  0
     Uart2_SetRxCallBack            0
     Uart2_Transmit                 0
     Uart2_UngetByte                0
     Uart_ClearErrors               8
     Uart_ModuleInit               24
     Uart_ModuleUninit              8
     Uart_Task                     16
     Uart_TaskInit                  8


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     gUartTaskId                      1
     uart1_ungetFlag                  1
     uart1_ungetByte                  1
     Uart1_TxInProgress               1
     maSci1TxBufRefTable             24
     maSci1TxBufLenTable              4
     mSci1TxBufRefLeadingIndex        1
     mSci1TxBufRefTrailingIndex       1
     maSci1TxCallbackTable           24
     maSci1TxCallbackLeadingIndex     1
     maSci1TxCallbackTrailingIndex    1
     maSci1RxBuf                     32
     pfSci1RxCallBack                 4
     Uart_ClearErrors                12
     Uart1_GetByteFromRxBuffer       42
     Uart2_GetByteFromRxBuffer        6
     Uart1_IsTxActive                32
     Uart2_IsTxActive                 4
     Uart_ModuleInit                170
     Uart1_RxIsr                     26
     Uart1_SetRxCallBack             40
     Uart2_SetRxCallBack              2
     Uart1_SetBaud                  128
     Uart2_SetBaud                    2
     Uart1_Transmit                 150
     Uart2_Transmit                   6
     Uart1_TxIsr                    188
     Uart_ModuleUninit               12
     Uart1_UngetByte                 36
     Uart2_UngetByte                  2
     Uart1_RxBufferByteCount         12
     Uart2_RxBufferByteCount         12
     Uart_Task                      110
     Uart_TaskInit                   18
     GpioUart1Init                   68
     GpioUart2Init                   50
     ??DataTable6                     4
     ??DataTable6_1                   4
     ??DataTable7                     4
     ??DataTable7_1                   4
     ??DataTable8                     4
     ??DataTable8_1                   4
     ??DataTable8_2                   4
     ??DataTable8_3                   4
     ??DataTable10                    4
     ??DataTable10_1                  4
     ??DataTable11                    4
     ??DataTable12                    4
     ??DataTable12_1                  4
     ??DataTable12_2                  4
     ??DataTable12_3                  4
     ??DataTable12_4                  4
     ??DataTable12_5                  4
     ??DataTable12_6                  4
     ??DataTable12_7                  4
     ??DataTable12_8                  4
     ??DataTable12_9                  4
     ??DataTable12_10                 4
     ??DataTable12_11                 4
     ??DataTable12_12                 4
     ??DataTable12_13                 4
     ??DataTable12_14                 4
     ??DataTable12_15                 4
     ??DataTable12_16                 4
     ??DataTable12_17                 4
      Others                          6

 
    96 bytes in section .bss
 1 250 bytes in section .text
 
 1 244 bytes of CODE memory (+ 6 bytes shared)
    96 bytes of DATA memory

Errors: none
Warnings: none
