###############################################################################
#                                                                             #
#                                                       12/Oct/2015  10:21:28 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\SSM\ZTC\Source\ZtcClientCommunic #
#                    ation.c                                                  #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Source\ZtcClientCommunic #
#                    ation.c" -D gMacStandAlone_d=1 -D                        #
#                    gSAPMessagesEnableLlc_d=0 -D gZtcIncluded_d=0 -D         #
#                    gTargetMC1322xSRB=1 --preprocess "C:\Documents and       #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" -lC "C:\Documents and               #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" -lB "C:\Documents and               #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\MacPhy\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Init\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Interface\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Configure\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\UartUtil\" -I        #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Source\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Source\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Interface\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Interface\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\LibInterface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Display\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Keyboard\" -I         #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\NVM\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\TMR\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\UART\" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 5.4     #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\List\ZtcClientCommunicatio #
#                    n.lst                                                    #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\Obj\ZtcClientCommunication #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\SSM\ZTC\Source\ZtcClientCommunication.c
      1          /******************************************************************************
      2          * ZTC routines to handle the ZTC <--> external client protocol.
      3          *
      4          * (c) Copyright 2008, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          ******************************************************************************/
     12          
     13          #include "EmbeddedTypes.h"
     14          
     15          #if gBeeStackIncluded_d
     16          #include "ZigBee.h"
     17          #include "BeeStackFunctionality.h"
     18          #include "BeeStackConfiguration.h"
     19          #endif
     20          
     21          #include "ZtcInterface.h"
     22          
     23          #if gZtcIncluded_d
     24          
     25          #include "FunctionLib.h"
     26          
     27          #if gBeeStackIncluded_d
     28          #include "BeeCommon.h"
     29          #endif
     30          
     31          #include "Uart_Interface.h"
     32          
     33          #include "ZtcPrivate.h"
     34          #include "ZtcClientCommunication.h"
     35          
     36          /******************************************************************************
     37          *******************************************************************************
     38          * Public memory declarations
     39          *******************************************************************************
     40          ******************************************************************************/
     41          
     42          /* UART packet received from the external client, minus the UART envelope. */
     43          clientPacket_t gZtcPacketFromClient;
     44          
     45          /* UART packet to be sent to external client, minus the UART envelope. */
     46          clientPacket_t gZtcPacketToClient;
     47          
     48          /* If true, ZtcWritePacketToClient() will block after enabling the UART Tx */
     49          /* interrupt, until the UART driver's output buffer is empty again. */
     50          #ifdef gZtcDebug_d
     51          bool_t gZtcUartTxBlocking = TRUE;
     52          #else
     53          bool_t gZtcUartTxBlocking = FALSE;
     54          #endif
     55          
     56          /******************************************************************************
     57          *******************************************************************************
     58          * Public functions
     59          *******************************************************************************
     60          ******************************************************************************/
     61          
     62          /* Read data from the UART. If the UART ISR has received a complete packet
     63           * (STX, packet header, and FCS), copy it to the Ztc's global
     64           * gZtcPacketFromClient buffer and return true. Otherwise return false.
     65           * This routine is called each time a byte is received from the UART.
     66           * Client packets consist of a UART envelope enclosing a variable length
     67           * clientPacket_t.
     68           * The UART envelope is a leading sync (STX) byte and a trailing FCS.
     69           */
     70          
     71          static index_t bytesReceived = 0;       /* Does not count the STX. */
     72          
     73          #define mMinValidPacketLen_c    (sizeof(clientPacketHdr_t) + sizeof(clientPacketChecksum_t))
     74          typedef enum {
     75            packetIsValid,
     76            packetIsTooShort,
     77            framingError
     78          } ztcPacketStatus_t;
     79          
     80          /* Does the buffer contain a valid packet? */
     81          ztcPacketStatus_t ZtcCheckPacket(void) {
     82            clientPacketChecksum_t checksum = 0;
     83            index_t i;
     84            index_t len;
     85          
     86            if (bytesReceived < mMinValidPacketLen_c) {
     87              return packetIsTooShort;            /* Too short to be valid. */
     88            }
     89          
     90            if (bytesReceived >= sizeof(gZtcPacketFromClient)) {
     91              return framingError;
     92            }
     93          
     94            /* The packet's len field does not count the STX, the opcode group, the */
     95            /* opcode, the len field, or the checksum. */
     96            len = gZtcPacketFromClient.structured.header.len;
     97            if (bytesReceived < len + sizeof(clientPacketHdr_t) + sizeof(checksum)) {
     98              return packetIsTooShort;
     99            }
    100          
    101            /* If the length appears to be too long, it might be because the external */
    102            /* client is sending a packet that is too long, or it might be that we're */
    103            /* out of sync with the external client. Assume we're out of sync. */
    104            if (len > sizeof(gZtcPacketFromClient.structured.payload)) {
    105              return framingError;
    106            }
    107          
    108            /* If the length looks right, make sure that the checksum is correct. */
    109            if (bytesReceived == len + sizeof(clientPacketHdr_t) + sizeof(checksum)) {
    110              for (checksum = 0, i = 0; i < len + sizeof(clientPacketHdr_t); ++i) {
    111                checksum ^= gZtcPacketFromClient.raw[i];
    112              }
    113            }
    114          
    115            if (checksum == gZtcPacketFromClient.structured.payload[len]) {
    116              return packetIsValid;
    117            }
    118          
    119            return framingError;
    120          }                                       /* ZtcCheckPacket() */
    121          
    122          bool_t ZtcReadPacketFromClient(void) {
    123            static bool_t startOfFrameSeen = FALSE;
    124            uint8_t byte;
    125            index_t i;
    126            ztcPacketStatus_t status;
    127          
    128            while (UartX_GetByteFromRxBuffer(&byte)) {
    129              if (!startOfFrameSeen) {
    130                bytesReceived = 0;
    131                startOfFrameSeen = (byte == mUartStxValue_c);
    132                break;                            /* Don't store the STX in the buffer. */
    133              }
    134          
    135              gZtcPacketFromClient.raw[bytesReceived++] = byte;
    136              for (;;) {
    137                status = ZtcCheckPacket();
    138                if (status == packetIsValid) {
    139                  startOfFrameSeen = FALSE;
    140                  bytesReceived = 0;
    141                  return TRUE;
    142                }
    143          
    144                if (status == packetIsTooShort) {
    145                  break;
    146                }
    147          
    148                /* If there appears to be a framing error, search the data received for */
    149                /* the next STX and try again. */
    150                startOfFrameSeen = FALSE;
    151                for (i = 0; i < bytesReceived; ++i) {
    152                  if (gZtcPacketFromClient.raw[i] == mUartStxValue_c) {
    153                    bytesReceived -= (i + 1);     /* Don't count the STX. */
    154                    FLib_MemCpy(gZtcPacketFromClient.raw, gZtcPacketFromClient.raw + i + 1, bytesReceived);
    155                    startOfFrameSeen = TRUE;
    156                    break;                        /* Back to the "for (;;)" loop. */
    157                  }                               /* if (gZtcPacketFromClient.raw[i] == mUartStxValue_c) */
    158                }                                 /* for (i = 0; i < bytesReceived; ++i) */
    159              break;
    160              }                                   /* for (;;) */
    161            }                                     /* while (UartX_GetBytesFromRxBuffer(&byte)) */
    162          
    163            return FALSE;                         /* Not yet. */
    164          }                                       /* ZtcReadPacketFromClient() */
    165          
    166          /****************************************************************************/
    167          
    168          volatile bool_t mZtcPacketToClientIsBusy;
    169          void ZtcWritePacketCallBack(unsigned char const *pBuf) {
    170            (void) pBuf;
    171            mZtcPacketToClientIsBusy = FALSE;
    172          }
    173          
    174          void ZtcWritePacketToClient(index_t const len) {
    175            mZtcPacketToClientIsBusy = TRUE;
    176            ZtcTransmitBuffer(gZtcPacketToClient.raw, len, ZtcWritePacketCallBack);
    177          }
    178          
    179          /**************************************/
    180          
    181          static volatile bool_t mZtcOutputBufferIsBusy;
    182          static void ZtcTransmitCallBack(unsigned char const *pBuf) {
    183            (void) pBuf;
    184            mZtcOutputBufferIsBusy = FALSE;
    185          }
    186          
    187          /* Send an arbitrary buffer to the external client. Block until the entire */
    188          /* buffer has been sent, regardless of the state of the gZtcUartTxBlocking */
    189          /* flag. */
    190          void ZtcTransmitBufferBlock(uint8_t const *pSrc, index_t const len) {
    191            mZtcOutputBufferIsBusy = TRUE;
    192          
    193            ZtcTransmitBuffer(pSrc, len, ZtcTransmitCallBack);
    194            while (UartX_IsTxActive());
    195          }
    196          
    197          /**************************************/
    198          
    199          static volatile bool_t mZtcChecksumWritten;
    200          void ZtcWriteChecksumCallBack(unsigned char const *pBuf) {
    201            (void) pBuf;
    202            mZtcChecksumWritten = TRUE;
    203          }
    204          
    205          void ZtcTransmitBuffer
    206            (
    207            uint8_t const *pSrc,
    208            index_t const len,
    209            void (*pfCallBack)(unsigned char const *pBuf)
    210            )
    211          {
    212            uint8_t byte;
    213            uint8_t checksum;
    214            uint8_t i;
    215          
    216            byte = mUartStxValue_c;
    217          
    218            while (!UartX_Transmit(&byte, sizeof(byte), NULL));
    219            /* if uart blocking enabled, wait for tx to complete.*/ 
    220            if(gZtcUartTxBlocking) { 
    221              while (UartX_IsTxActive());
    222            }
    223            
    224            if(gZtcUartTxBlocking) { 
    225            /*if uart blocking enabled, call uart with no callback and wait for tx to complete
    226              and execute callback manually
    227            */
    228              while (!UartX_Transmit(pSrc, len, NULL));  
    229               while (UartX_IsTxActive());
    230              if (pfCallBack)
    231                pfCallBack(NULL);
    232            } else { 
    233            /*else call uart with callbacm*/
    234            while (!UartX_Transmit(pSrc, len, pfCallBack));
    235            }
    236            
    237            checksum = 0;
    238            for (i = 0; i < len; ++i) {
    239              checksum ^= pSrc[i];
    240            }
    241          
    242            mZtcChecksumWritten = FALSE;
    243          
    244            if (gZtcUartTxBlocking) {
    245            /*if uart blocking enabled, call uart with no callback and wait for tx to complete
    246              and execute callback manually
    247            */  
    248              while (!UartX_Transmit(&checksum, sizeof(checksum), NULL));
    249               while (UartX_IsTxActive());
    250              ZtcWriteChecksumCallBack(NULL);
    251            } else {    
    252            /*else call uart with callbacm*/  
    253              while (!UartX_Transmit(&checksum, sizeof(checksum), ZtcWriteChecksumCallBack)); 
    254            }
    255            
    256          }                                       /* ZtcWritePacketToClient() */
    257          
    258          #endif                                  /* #if gZtcIncluded_d == 1 */


 
 
 0 bytes of memory

Errors: none
Warnings: none
