///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      08/Dec/2015  22:02:17 /
// IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM               /
// Copyright (C) 1999-2010 IAR Systems AB.                                    /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Source\MApp.c                       /
//    Command line =  "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Source\MApp.c" -D                   /
//                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D      /
//                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess    /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Debug\List\" -lC "C:\Documents and              /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" -lB "C:\Documents and  /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" --diag_suppress        /
//                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and      /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\Obj\" --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa --no_clustering  /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program   /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\DLib_Config_Normal.h" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\MacPhy\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Init\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Interface\" -I "C:\Documents and    /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Configure\" -I          /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\UartUtil\" -I "C:\Documents and     /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Source\" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\TS\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\TS\Source\" -I "C:\Documents    /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and        /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\ZTC\Source\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Interface\" -I "C:\Documents and            /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\LibInterface\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\Display\" -I "C:\Documents and       /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\Keyboard\" -I            /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\NVM\" -I "C:\Documents and           /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\TMR\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR      /
//                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"     /
//                    --interwork --cpu_mode thumb -On                        /
//    List file    =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Debug\List\MApp.s                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME MApp

        EXTERN FLib_MemCpy
        EXTERN Gpio_SetPinData
        EXTERN Init_MacExtendedAddress
        EXTERN IntRestoreAll
        EXTERN KBD_Init
        EXTERN LED_Init
        EXTERN LED_StartFlash
        EXTERN LED_StopFlash
        EXTERN List_AddTail
        EXTERN List_ClearAnchor
        EXTERN List_RemoveHead
        EXTERN MM_Alloc
        EXTERN MM_Free
        EXTERN NWK_MCPS_SapHandler
        EXTERN NWK_MLME_SapHandler
        EXTERN PWR_AllowDeviceToSleep
        EXTERN TMR_AllocateTimer
        EXTERN TMR_StartSingleShotTimer
        EXTERN TS_SendEvent
        EXTERN Uart1_GetByteFromRxBuffer
        EXTERN Uart1_SetBaud
        EXTERN Uart1_SetRxCallBack
        EXTERN UartUtil_Print
        EXTERN UartUtil_PrintHex
        EXTERN UartUtil_Tx
        EXTERN __aeabi_uread4
        EXTERN __aeabi_uwrite4
        EXTERN aExtendedAddress
        EXTERN gAppTaskID_c

        PUBLIC ASP_APP_SapHandler
        PUBLIC AppTask
        PUBLIC DeepSleepWakeupStackProc
        PUBLIC MApp_init
        PUBLIC MCPS_NWK_SapHandler
        PUBLIC MLME_NWK_SapHandler
        PUBLIC gState
        PUBLIC gaNvAppDataSet

// C:\Documents and Settings\Administrator\Desktop\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\Application\Source\MApp.c
//    1 /*****************************************************************************
//    2 * MyWirelessApp Demo Non Beacon End Device application.
//    3 *
//    4 * (c) Copyright 2008, Freescale, Inc. All rights reserved.
//    5 *
//    6 *
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor.
//   10 *
//   11 *****************************************************************************/
//   12 
//   13 #include "MApp.h"
//   14 #include "NVM_Interface.h"
//   15 
//   16 /************************************************************************************
//   17 *************************************************************************************
//   18 * Private macros
//   19 *************************************************************************************
//   20 ************************************************************************************/
//   21 
//   22 /* If there are too many pending packets to be send over the air, */
//   23 /* receive mMaxKeysToReceive_c chars. */
//   24 /* The chars will be send over the air when there are no pending packets*/
//   25 #define mMaxKeysToReceive_c 32
//   26 
//   27 /************************************************************************************
//   28 *************************************************************************************
//   29 * Private prototypes
//   30 *************************************************************************************
//   31 ************************************************************************************/
//   32 
//   33 /* Forward declarations of helper functions */
//   34 static void    UartRxCallBack(void);
//   35 static uint8_t App_StartScan(uint8_t scanType);
//   36 static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
//   37 static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
//   38 static uint8_t App_SendAssociateRequest(void);
//   39 static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
//   40 static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
//   41 static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
//   42 static void    App_TransmitUartData(void);
//   43 static void    AppPollWaitTimeout(uint8_t tmr);
//   44 static void    App_HandleKeys( key_event_t events );
//   45 static uint8_t App_SetParam(uint8_t attribute, uint8_t *pValue);
//   46 static uint8_t App_GetParam(uint8_t attribute, uint8_t *pValue);
//   47 
//   48 /************************************************************************************
//   49 *************************************************************************************
//   50 * Private type definitions
//   51 *************************************************************************************
//   52 ************************************************************************************/
//   53 
//   54 
//   55 /************************************************************************************
//   56 *************************************************************************************
//   57 * Private memory declarations
//   58 *************************************************************************************
//   59 ************************************************************************************/
//   60 
//   61 /* Information about the PAN we are part of */

        SECTION `.bss`:DATA:NOROOT(2)
//   62 static panDescriptor_t mCoordInfo;
mCoordInfo:
        DS8 24
//   63 
//   64 /* This is either the short address assigned by the PAN coordinator
//   65    during association, or our own extended MAC address. */

        SECTION `.bss`:DATA:NOROOT(2)
//   66 static uint8_t maMyAddress[8];
maMyAddress:
        DS8 8
//   67 /* The devices address mode. If 2, then maMyAddress contains the short
//   68    address assigned by the PAN coordinator. If 3, then maMyAddress is
//   69    equal to the extended address. */

        SECTION `.bss`:DATA:NOROOT(0)
//   70 static uint8_t mAddrMode;
mAddrMode:
        DS8 1
//   71 
//   72 /* Data request packet for sending UART input to the coordinator */

        SECTION `.bss`:DATA:NOROOT(2)
//   73 static nwkToMcpsMessage_t *mpPacket;
mpPacket:
        DS8 4
//   74 
//   75 /* The MSDU handle is a unique data packet identifier */

        SECTION `.bss`:DATA:NOROOT(0)
//   76 static uint8_t mMsduHandle;
mMsduHandle:
        DS8 1
//   77 
//   78 /* Number of pending data packets */

        SECTION `.bss`:DATA:NOROOT(0)
//   79 static uint8_t mcPendingPackets;
mcPendingPackets:
        DS8 1
//   80 
//   81 /* Signals that an MLME-Poll request is pending, and that we must wait for 
//   82    the MLME-Poll confirm message before sending the next poll request. */

        SECTION `.bss`:DATA:NOROOT(0)
//   83 static bool_t mWaitPollConfirm;
mWaitPollConfirm:
        DS8 1
//   84 
//   85 //WSNProject

        SECTION `.bss`:DATA:NOROOT(0)
//   86 static bool_t dataSet;
dataSet:
        DS8 1

        SECTION `.bss`:DATA:NOROOT(0)
//   87 static bool_t dataGet;
dataGet:
        DS8 1

        SECTION `.bss`:DATA:NOROOT(0)
//   88 static uint8_t dataUGet;
dataUGet:
        DS8 1
//   89 
//   90 /* Time between MLME-Poll requests */

        SECTION `.bss`:DATA:NOROOT(1)
//   91 static uint16_t mPollInterval;
mPollInterval:
        DS8 2
//   92 
//   93 /* Application input queues */

        SECTION `.bss`:DATA:NOROOT(2)
//   94 static anchor_t mMlmeNwkInputQueue;
mMlmeNwkInputQueue:
        DS8 8

        SECTION `.bss`:DATA:NOROOT(2)
//   95 static anchor_t mMcpsNwkInputQueue;
mMcpsNwkInputQueue:
        DS8 8
//   96 

        SECTION `.data`:DATA:NOROOT(0)
//   97 static tmrTimerID_t mTimer_c = gTmrInvalidTimerID_c;
mTimer_c:
        DATA
        DC8 255
//   98 
//   99 /************************************************************************************
//  100 *************************************************************************************
//  101 * Public memory declarations
//  102 *************************************************************************************
//  103 ************************************************************************************/
//  104 
//  105 /* The current state of the applications state machine */

        SECTION `.bss`:DATA:NOROOT(0)
//  106 uint8_t gState;
gState:
        DS8 1

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rPress any switch on...">`:
        DATA
        DC8 0AH, 0DH, 50H, 72H, 65H, 73H, 73H, 20H
        DC8 61H, 6EH, 79H, 20H, 73H, 77H, 69H, 74H
        DC8 63H, 68H, 20H, 6FH, 6EH, 20H, 62H, 6FH
        DC8 61H, 72H, 64H, 20H, 74H, 6FH, 20H, 73H
        DC8 74H, 61H, 72H, 74H, 20H, 72H, 75H, 6EH
        DC8 6EH, 69H, 6EH, 67H, 20H, 74H, 68H, 65H
        DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
        DC8 74H, 69H, 6FH, 6EH, 2EH, 0AH, 0DH, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Press any key">`:
        DATA
        DC8 "Press any key"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "to start.">`:
        DATA
        DC8 "to start."
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Received an MLME-Beac...">`:
        DATA
        DC8 "Received an MLME-Beacon Notify Indication\012\015"

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "MyWirelessApp Demo No...">`:
        DATA
        DC8 4DH, 79H, 57H, 69H, 72H, 65H, 6CH, 65H
        DC8 73H, 73H, 41H, 70H, 70H, 20H, 44H, 65H
        DC8 6DH, 6FH, 20H, 4EH, 6FH, 6EH, 20H, 42H
        DC8 65H, 61H, 63H, 6FH, 6EH, 20H, 45H, 6EH
        DC8 64H, 20H, 44H, 65H, 76H, 69H, 63H, 65H
        DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
        DC8 74H, 69H, 6FH, 6EH, 20H, 69H, 73H, 20H
        DC8 69H, 6EH, 69H, 74H, 69H, 61H, 6CH, 69H
        DC8 7AH, 65H, 64H, 20H, 61H, 6EH, 64H, 20H
        DC8 72H, 65H, 61H, 64H, 79H, 2EH, 0AH, 0DH
        DC8 0AH, 0DH, 0
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Start scanning for a ...">`:
        DATA
        DC8 "Start scanning for a PAN coordinator\012\015"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Start scanning">`:
        DATA
        DC8 "Start scanning"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "for coordinator">`:
        DATA
        DC8 "for coordinator"

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Found a coordinator w...">`:
        DATA
        DC8 46H, 6FH, 75H, 6EH, 64H, 20H, 61H, 20H
        DC8 63H, 6FH, 6FH, 72H, 64H, 69H, 6EH, 61H
        DC8 74H, 6FH, 72H, 20H, 77H, 69H, 74H, 68H
        DC8 20H, 74H, 68H, 65H, 20H, 66H, 6FH, 6CH
        DC8 6CH, 6FH, 77H, 69H, 6EH, 67H, 20H, 70H
        DC8 72H, 6FH, 70H, 65H, 72H, 74H, 69H, 65H
        DC8 73H, 3AH, 0AH, 0DH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "---------------------...">`:
        DATA
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
        DC8 2DH, 2DH, 2DH, 2DH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rAddress...........0x">`:
        DATA
        DC8 "\012\015Address...........0x"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rPAN ID............0x">`:
        DATA
        DC8 "\012\015PAN ID............0x"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rLogical Channel...0x">`:
        DATA
        DC8 "\012\015Logical Channel...0x"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rBeacon Spec.......0x">`:
        DATA
        DC8 "\012\015Beacon Spec.......0x"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rLink Quality......0x">`:
        DATA
        DC8 "\012\015Link Quality......0x"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\r\\n\\r">`:
        DATA
        DC8 "\012\015\012\015"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Scan did not find a s...">`:
        DATA
        DC8 "Scan did not find a suitable coordinator\012\015"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "No coordinator">`:
        DATA
        DC8 "No coordinator"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "found.">`:
        DATA
        DC8 "found."
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Associating to PAN co...">`:
        DATA
        DC8 "Associating to PAN coordinator on channel 0x"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Associating to ">`:
        DATA
        DC8 "Associating to "

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "PAN coordinator">`:
        DATA
        DC8 "PAN coordinator"

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Successfully associat...">`:
        DATA
        DC8 "Successfully associated with the coordinator.\012\015"

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "We were assigned the ...">`:
        DATA
        DC8 "We were assigned the short address 0x"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\r\\n\\rReady to send and...">`:
        DATA
        DC8 0AH, 0DH, 0AH, 0DH, 52H, 65H, 61H, 64H
        DC8 79H, 20H, 74H, 6FH, 20H, 73H, 65H, 6EH
        DC8 64H, 20H, 61H, 6EH, 64H, 20H, 72H, 65H
        DC8 63H, 65H, 69H, 76H, 65H, 20H, 64H, 61H
        DC8 74H, 61H, 20H, 6FH, 76H, 65H, 72H, 20H
        DC8 74H, 68H, 65H, 20H, 55H, 41H, 52H, 54H
        DC8 2EH, 0AH, 0DH, 0AH, 0DH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Ready to send">`:
        DATA
        DC8 "Ready to send"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "and receive data">`:
        DATA
        DC8 "and receive data"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "\\n\\rAssociate Confirm w...">`:
        DATA
        DC8 "\012\015Associate Confirm wasn't successful... \012\015\012\015"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Sending the MLME-Scan...">`:
        DATA
        DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
        DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
        DC8 2DH, 53H, 63H, 61H, 6EH, 20H, 52H, 65H
        DC8 71H, 75H, 65H, 73H, 74H, 20H, 6DH, 65H
        DC8 73H, 73H, 61H, 67H, 65H, 20H, 74H, 6FH
        DC8 20H, 74H, 68H, 65H, 20H, 4DH, 41H, 43H
        DC8 2EH, 2EH, 2EH, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Done\\n\\r">`:
        DATA
        DC8 "Done\012\015"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Invalid parameter!\\n\\r">`:
        DATA
        DC8 "Invalid parameter!\012\015"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Message allocation fa...">`:
        DATA
        DC8 "Message allocation failed!\012\015"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Sending the MLME-Asso...">`:
        DATA
        DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
        DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
        DC8 2DH, 41H, 73H, 73H, 6FH, 63H, 69H, 61H
        DC8 74H, 65H, 20H, 52H, 65H, 71H, 75H, 65H
        DC8 73H, 74H, 20H, 6DH, 65H, 73H, 73H, 61H
        DC8 67H, 65H, 20H, 74H, 6FH, 20H, 74H, 68H
        DC8 65H, 20H, 4DH, 41H, 43H, 2EH, 2EH, 2EH
        DC8 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "Application">`:
        DATA
        DC8 "Application"

        SECTION `.rodata`:CONST:NOROOT(2)
`?<Constant "    started">`:
        DATA
        DC8 "    started"
//  107 
//  108 /* This data set contains application variables to be preserved across resets */

        SECTION `.rodata`:CONST:NOROOT(2)
//  109 NvDataItemDescription_t const gaNvAppDataSet[] = {
gaNvAppDataSet:
        DATA
        DC32 0H
        DC16 0
        DC8 0, 0
//  110   {NULL, 0}       /* Required end-of-table marker. */
//  111 };
//  112 
//  113 /************************************************************************************
//  114 *************************************************************************************
//  115 * Public functions
//  116 *************************************************************************************
//  117 ************************************************************************************/
//  118 
//  119 void DeepSleepWakeupStackProc(void);
//  120 
//  121 /*****************************************************************************
//  122 * Initialization function for the App Task. This is called during
//  123 * initialization and should contain any application specific initialization
//  124 * (ie. hardware initialization/setup, table initialization, power up
//  125 * notificaiton.
//  126 *
//  127 * Interface assumptions: None
//  128 *
//  129 * Return value: None
//  130 *
//  131 *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  132 void MApp_init(void)
//  133 { 
MApp_init:
        PUSH     {R7,LR}
//  134   
//  135   /* The initial application state */
//  136   gState = stateInit;  
        LDR      R0,??DataTable0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  137   /* Reset number of pending packets */
//  138   mcPendingPackets = 0;
        LDR      R0,??DataTable0_1
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  139   
//  140   /* Allow sending a poll request */  
//  141   mWaitPollConfirm = FALSE;    
        LDR      R0,??DataTable0_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  142   
//  143   /* Initialize the poll interval */
//  144   mPollInterval = mDefaultValueOfPollIntervalSlow_c;
        LDR      R0,??DataTable0_3
        MOVS     R1,#+205
        LSLS     R1,R1,#+2        ;; #+820
        STRH     R1,[R0, #+0]
//  145 
//  146   /* Initialize the MAC 802.15.4 extended address */
//  147   Init_MacExtendedAddress();
        BL       Init_MacExtendedAddress
//  148   mTimer_c = TMR_AllocateTimer();
        BL       TMR_AllocateTimer
        LDR      R1,??DataTable0_4
        STRB     R0,[R1, #+0]
//  149   /* register keyboard callback function */
//  150   KBD_Init(App_HandleKeys);
        LDR      R0,??DataTable0_5
        BL       KBD_Init
//  151   /* initialize LCD Module */
//  152   LCD_Init();
//  153   /* initialize LED Module */
//  154   LED_Init();
        BL       LED_Init
//  155   /* Initialize the UART so that we can print out status messages */
//  156   UartX_SetBaud(gUartDefaultBaud_c);
        MOVS     R0,#+150
        LSLS     R0,R0,#+7        ;; #+19200
        BL       Uart1_SetBaud
//  157   UartX_SetRxCallBack(UartRxCallBack);
        LDR      R0,??DataTable0_6
        BL       Uart1_SetRxCallBack
//  158   /* Prepare input queues.*/
//  159   MSG_InitQueue(&mMlmeNwkInputQueue); 
        LDR      R0,??DataTable0_7
        BL       List_ClearAnchor
//  160   MSG_InitQueue(&mMcpsNwkInputQueue);
        LDR      R0,??DataTable0_8
        BL       List_ClearAnchor
//  161   /* Enable MCU interrupts */
//  162   IntEnableAll();
        MOVS     R0,#+0
        BL       IntRestoreAll
//  163   /*signal app ready*/  
//  164   Led1Flashing();
        MOVS     R0,#+1
        BL       LED_StartFlash
//  165   Led2Flashing();
        MOVS     R0,#+2
        BL       LED_StartFlash
//  166   Led3Flashing();
        MOVS     R0,#+4
        BL       LED_StartFlash
//  167   Led4Flashing();
        MOVS     R0,#+8
        BL       LED_StartFlash
//  168     
//  169   UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
        MOVS     R1,#+1
        LDR      R0,??DataTable0_9
        BL       UartUtil_Print
//  170   LCD_ClearDisplay();
//  171   LCD_WriteString(1,"Press any key");
        LDR      R0,??DataTable0_10
//  172   LCD_WriteString(2,"to start.");
        LDR      R0,??DataTable2
//  173 }
        POP      {R0,R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0:
        DC32     gState

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_1:
        DC32     mcPendingPackets

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_2:
        DC32     mWaitPollConfirm

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_3:
        DC32     mPollInterval

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_4:
        DC32     mTimer_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_5:
        DC32     App_HandleKeys

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_6:
        DC32     UartRxCallBack

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_7:
        DC32     mMlmeNwkInputQueue

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_8:
        DC32     mMcpsNwkInputQueue

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_9:
        DC32     `?<Constant "\\n\\rPress any switch on...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable0_10:
        DC32     `?<Constant "Press any key">`
//  174 
//  175 /*****************************************************************************
//  176 *Mac Application Task event processor.  This function is called to
//  177 * process all events for the task. Events include timers, messages and any
//  178 * other user defined events
//  179 *
//  180 * Interface assumptions: None
//  181 *
//  182 * Return value: None
//  183 *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  184 void AppTask(event_t events) 
//  185 { 
AppTask:
        PUSH     {R4-R6,LR}
        MOVS     R6,R0
//  186 
//  187   /* Pointer for storing the messages from MLME, MCPS, and ASP. */
//  188   void *pMsgIn;
//  189   /* Stores the status code returned by some functions. */
//  190   uint8_t rc;  
//  191   pMsgIn = NULL;
        MOVS     R0,#+0
        MOVS     R4,R0
//  192   
//  193   /* Dequeue the MLME message */
//  194   if (events & gAppEvtMessageFromMLME_c)
        LSLS     R0,R6,#+29
        BPL      ??AppTask_0
//  195   {
//  196     /* Get the message from MLME */
//  197     pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
        LDR      R0,??DataTable2_1
        BL       List_RemoveHead
        MOVS     R4,R0
//  198     
//  199     /* Any time a beacon might arrive. Always handle the beacon frame first */
//  200     if (pMsgIn)
        CMP      R4,#+0
        BEQ      ??AppTask_0
//  201     {               
//  202       rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
        MOVS     R1,#+4
        MOVS     R0,R4
        BL       App_WaitMsg
        MOVS     R5,R0
//  203       if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BNE      ??AppTask_0
//  204       {
//  205         /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
//  206         /* ALSO the application can use the beacon payload.*/
//  207         MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
        MOVS     R0,R4
        ADDS     R0,R0,#+16
        BL       __aeabi_uread4
        BL       MM_Free
        MOVS     R1,R4
        ADDS     R1,R1,#+16
        MOVS     R0,#+0
        BL       __aeabi_uwrite4
//  208         UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable2_2
        BL       UartUtil_Print
//  209       }
//  210     }
//  211   }
//  212   
//  213   /* The application state machine */
//  214   switch(gState)
??AppTask_0:
        LDR      R0,??DataTable1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??AppTask_1
        CMP      R0,#+2
        BEQ      ??AppTask_2
        BCC      ??AppTask_3
        CMP      R0,#+4
        BNE      .+4
        B        ??AppTask_4
        BCS      .+4
        B        ??AppTask_5
        CMP      R0,#+5
        BNE      .+4
        B        ??AppTask_6
        B        ??AppTask_7
//  215   {
//  216   case stateInit:    
//  217     /* Print a welcome message to the UART */
//  218     UartUtil_Print("MyWirelessApp Demo Non Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
??AppTask_1:
        MOVS     R1,#+1
        LDR      R0,??DataTable3
        BL       UartUtil_Print
//  219     /* Goto Active Scan state. */
//  220     gState = stateScanActiveStart;
        LDR      R0,??DataTable1
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  221     TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);    
        MOVS     R1,#+1
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
        B        ??AppTask_7
//  222     break;
//  223     
//  224   case stateScanActiveStart:
//  225     /* Start the Active scan, and goto wait for confirm state. */
//  226     UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
??AppTask_3:
        MOVS     R1,#+1
        LDR      R0,??AppTask_8
        BL       UartUtil_Print
//  227     /*print a message on the LCD also*/
//  228     LCD_ClearDisplay();
//  229     LCD_WriteString(1,"Start scanning");
        LDR      R0,??AppTask_9
//  230     LCD_WriteString(2,"for coordinator");  
        LDR      R0,??DataTable1_1
//  231     rc = App_StartScan(gScanModeActive_c);
        MOVS     R0,#+1
        BL       App_StartScan
        MOVS     R5,R0
//  232     if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BEQ      .+4
        B        ??AppTask_7
//  233     {
//  234       gState = stateScanActiveWaitConfirm;
        LDR      R0,??DataTable1
        MOVS     R1,#+2
        STRB     R1,[R0, #+0]
        B        ??AppTask_7
//  235     }
//  236     break;
//  237     
//  238   case stateScanActiveWaitConfirm:
//  239     /* Stay in this state until the Scan confirm message
//  240        arrives, and then goto the associate state. */
//  241     if (events & gAppEvtMessageFromMLME_c)
??AppTask_2:
        LSLS     R0,R6,#+29
        BMI      .+4
        B        ??AppTask_7
//  242     {
//  243       if (pMsgIn)
        CMP      R4,#+0
        BNE      .+4
        B        ??AppTask_7
//  244       {                     
//  245         rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
        MOVS     R1,#+11
        MOVS     R0,R4
        BL       App_WaitMsg
        MOVS     R5,R0
//  246         if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BEQ      .+4
        B        ??AppTask_7
//  247         {
//  248           rc = App_HandleScanActiveConfirm(pMsgIn);
        MOVS     R0,R4
        BL       App_HandleScanActiveConfirm
        MOVS     R5,R0
//  249           if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BNE      ??AppTask_10
//  250           {
//  251             UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable2_3
        BL       UartUtil_Print
//  252             UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable2_4
        BL       UartUtil_Print
//  253             UartUtil_Print("\n\rAddress...........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
        MOVS     R1,#+1
        LDR      R0,??DataTable2_5
        BL       UartUtil_Print
        LDR      R0,??DataTable2_6
        LDRB     R0,[R0, #+10]
        CMP      R0,#+2
        BNE      ??AppTask_11
        MOVS     R1,#+2
        B        ??AppTask_12
??AppTask_11:
        MOVS     R1,#+8
??AppTask_12:
        MOVS     R2,#+0
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        LDR      R0,??DataTable2_6
        BL       UartUtil_PrintHex
//  254             UartUtil_Print("\n\rPAN ID............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
        MOVS     R1,#+1
        LDR      R0,??DataTable2_7
        BL       UartUtil_Print
        MOVS     R2,#+0
        MOVS     R1,#+2
        LDR      R0,??DataTable2_6
        ADDS     R0,R0,#+8
        BL       UartUtil_PrintHex
//  255             UartUtil_Print("\n\rLogical Channel...0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_2
        BL       UartUtil_Print
        MOVS     R2,#+0
        MOVS     R1,#+1
        LDR      R0,??DataTable2_6
        ADDS     R0,R0,#+11
        BL       UartUtil_PrintHex
//  256             UartUtil_Print("\n\rBeacon Spec.......0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_3
        BL       UartUtil_Print
        MOVS     R2,#+0
        MOVS     R1,#+2
        LDR      R0,??DataTable2_6
        ADDS     R0,R0,#+15
        BL       UartUtil_PrintHex
//  257             UartUtil_Print("\n\rLink Quality......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_4
        BL       UartUtil_Print
        MOVS     R2,#+0
        MOVS     R1,#+1
        LDR      R0,??DataTable2_6
        ADDS     R0,R0,#+18
        BL       UartUtil_PrintHex
//  258             UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_5
        BL       UartUtil_Print
//  259 
//  260             gState = stateAssociate;
        LDR      R0,??DataTable1
        MOVS     R1,#+3
        STRB     R1,[R0, #+0]
//  261             TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
        B        ??AppTask_7
//  262           }
//  263           else
//  264 		      {
//  265             UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
??AppTask_10:
        MOVS     R1,#+1
        LDR      R0,??DataTable3_6
        BL       UartUtil_Print
//  266             /*print a message on the LCD also*/
//  267             LCD_ClearDisplay();
//  268             LCD_WriteString(1,"No coordinator");
        LDR      R0,??DataTable3_7
//  269             LCD_WriteString(2,"found.");
        LDR      R0,??DataTable3_8
        B        ??AppTask_7
//  270 		      }
//  271 		    }
//  272       }
//  273     }
//  274     break;
//  275 
//  276   case stateAssociate:
//  277     /* Associate to the PAN coordinator */
//  278     UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
??AppTask_5:
        MOVS     R1,#+1
        LDR      R0,??DataTable3_9
        BL       UartUtil_Print
//  279     UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
        MOVS     R2,#+2
        MOVS     R1,#+1
        LDR      R0,??DataTable2_6
        ADDS     R0,R0,#+11
        BL       UartUtil_PrintHex
//  280     /*print a message on the LCD also*/
//  281     LCD_ClearDisplay();
//  282     LCD_WriteString(1,"Associating to ");
        LDR      R0,??DataTable3_10
//  283     LCD_WriteString(2,"PAN coordinator");  
        LDR      R0,??DataTable3_11
//  284     rc = App_SendAssociateRequest();
        BL       App_SendAssociateRequest
        MOVS     R5,R0
//  285     if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BNE      ??AppTask_7
//  286       gState = stateAssociateWaitConfirm;
        LDR      R0,??DataTable1
        MOVS     R1,#+4
        STRB     R1,[R0, #+0]
        B        ??AppTask_7
//  287     break; 
//  288 
//  289   case stateAssociateWaitConfirm:
//  290     /* Stay in this state until the Associate confirm message
//  291        arrives, and then goto the Listen state. */
//  292     if (events & gAppEvtMessageFromMLME_c)
??AppTask_4:
        LSLS     R0,R6,#+29
        BPL      ??AppTask_7
//  293     {
//  294       if (pMsgIn)
        CMP      R4,#+0
        BEQ      ??AppTask_7
//  295       {   
//  296         rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);
        MOVS     R1,#+1
        MOVS     R0,R4
        BL       App_WaitMsg
        MOVS     R5,R0
//  297         if(rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BNE      ??AppTask_7
//  298         {          
//  299           rc = App_HandleAssociateConfirm(pMsgIn);
        MOVS     R0,R4
        BL       App_HandleAssociateConfirm
        MOVS     R5,R0
//  300           if (rc == errorNoError)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BNE      ??AppTask_13
//  301           { 
//  302 	          UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable4
        BL       UartUtil_Print
//  303 	          UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable4_1
        BL       UartUtil_Print
//  304 	          UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
        LDR      R0,??DataTable4_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE      ??AppTask_14
        MOVS     R1,#+2
        B        ??AppTask_15
??AppTask_14:
        MOVS     R1,#+8
??AppTask_15:
        MOVS     R2,#+0
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        LDR      R0,??DataTable4_3
        BL       UartUtil_PrintHex
//  305 	          UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable4_4
        BL       UartUtil_Print
//  306 	          /*print a message on the LCD also*/
//  307 	          LCD_ClearDisplay();
//  308 	          LCD_WriteString(1,"Ready to send");
        LDR      R0,??DataTable5
//  309 	          LCD_WriteString(2,"and receive data");    
        LDR      R0,??DataTable5_1
//  310 	          /* Startup the timer */
//  311 	          TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
        LDR      R2,??DataTable5_2
        LDR      R0,??DataTable5_3
        LDRH     R1,[R0, #+0]
        LDR      R0,??DataTable5_4
        LDRB     R0,[R0, #+0]
        BL       TMR_StartSingleShotTimer
//  312 	          /* Go to the listen state */
//  313 	          gState = stateListen;
        LDR      R0,??DataTable1
        MOVS     R1,#+5
        STRB     R1,[R0, #+0]
//  314 	          TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c); 
        MOVS     R1,#+1
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
        B        ??AppTask_7
//  315           }        
//  316           else 
//  317           {
//  318           
//  319 	          UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
??AppTask_13:
        MOVS     R1,#+1
        LDR      R0,??DataTable5_5
        BL       UartUtil_Print
//  320 	          gState = stateScanActiveStart;
        LDR      R0,??DataTable1
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  321               TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
        MOVS     R1,#+1
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
        B        ??AppTask_7
        Nop      
        DATA
??AppTask_8:
        DC32     `?<Constant "Start scanning for a ...">`
        THUMB
//  322           }
//  323         }
//  324       }
//  325     }
//  326     break; 
//  327     
//  328   case stateListen:
//  329     
//  330     //WSNProject: necessario da aggiungere perché negli state precedenti "disallow"
//  331     //è stato chiamato (uniche due PWR function che si possono chiamare nel main)
//  332     PWR_AllowDeviceToSleep();
??AppTask_6:
        BL       PWR_AllowDeviceToSleep
//  333     
//  334     /* Transmit to coordinator data received from UART. */
//  335     if (events & gAppEvtMessageFromMLME_c)
        LSLS     R0,R6,#+29
        BPL      ??AppTask_16
//  336     {  
//  337       if (pMsgIn)
        CMP      R4,#+0
        BEQ      ??AppTask_16
//  338       {  
//  339         /* Process it */
//  340         rc = App_HandleMlmeInput(pMsgIn);
        MOVS     R0,R4
        BL       App_HandleMlmeInput
        MOVS     R5,R0
//  341       }
//  342     } 
//  343     
//  344     if (events & gAppEvtRxFromUart_c)
??AppTask_16:
        LSLS     R0,R6,#+30
        BPL      ??AppTask_7
//  345     {      
//  346       /* get byte from UART */
//  347       App_TransmitUartData();
        BL       App_TransmitUartData
//  348     
//  349     }  
//  350     break;
//  351   }
//  352   
//  353   if (pMsgIn)
??AppTask_7:
        CMP      R4,#+0
        BEQ      ??AppTask_17
//  354   {
//  355     /* Messages must always be freed. */ 
//  356     MSG_Free(pMsgIn);
        MOVS     R0,R4
        BL       MM_Free
        MOVS     R0,#+0
        MOVS     R4,R0
//  357   }
//  358   
//  359    /* Handle MCPS confirms and transmit data from UART */
//  360   if (events & gAppEvtMessageFromMCPS_c)
??AppTask_17:
        LSLS     R0,R6,#+28
        BPL      ??AppTask_18
//  361   {      
//  362     /* Get the message from MCPS */
//  363     pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
        LDR      R0,??DataTable7
        BL       List_RemoveHead
        MOVS     R4,R0
//  364     if (pMsgIn)
        CMP      R4,#+0
        BEQ      ??AppTask_18
//  365     {              
//  366       /* Process it */
//  367       App_HandleMcpsInput(pMsgIn);
        MOVS     R0,R4
        BL       App_HandleMcpsInput
//  368       /* Messages from the MCPS must always be freed. */
//  369       MSG_Free(pMsgIn);
        MOVS     R0,R4
        BL       MM_Free
        MOVS     R0,#+0
        MOVS     R4,R0
//  370     }
//  371   }
//  372   //verifica già fatta: una volta che il nodo va in state sleep
//  373   //POTREBBE entrare in SleepMode
//  374   //(ma di fatto non lo fa)
//  375   /*
//  376   if(PWR_CheckIfDeviceCanGoToSleep())
//  377     UartUtil_Print("Rx can go to sleep\n\r", gAllowToBlock_d);
//  378   else
//  379     UartUtil_Print("Cannot...\n\r", gAllowToBlock_d);*/
//  380   //WSNProject: non ha senso andare in idle task con un evento, non può funzionare
//  381   //TS_SendEvent(gIdleTaskID, gTsIdleTaskID_c);
//  382   /* Check for pending messages in the Queue */ 
//  383   if(MSG_Pending(&mMcpsNwkInputQueue))
??AppTask_18:
        LDR      R0,??DataTable7
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??AppTask_19
//  384     TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
        MOVS     R1,#+8
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  385   if(MSG_Pending(&mMlmeNwkInputQueue))
??AppTask_19:
        LDR      R0,??DataTable2_1
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??AppTask_20
//  386     TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
        MOVS     R1,#+4
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  387 }
??AppTask_20:
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
        DATA
??AppTask_9:
        DC32     `?<Constant "Start scanning">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable1:
        DC32     gState

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable1_1:
        DC32     `?<Constant "for coordinator">`
//  388 
//  389 /************************************************************************************
//  390 *************************************************************************************
//  391 * Private functions
//  392 *************************************************************************************
//  393 ************************************************************************************/
//  394 
//  395 /*****************************************************************************
//  396 * UartRxCallBack
//  397 *
//  398 * This callback is triggered when a new byte is received over the UART
//  399 *
//  400 *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  401 static void UartRxCallBack(void) 
//  402 {
UartRxCallBack:
        PUSH     {R7,LR}
//  403   uint8_t pressedKey;
//  404 	if(stateListen == gState){
        LDR      R0,??DataTable8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE      ??UartRxCallBack_0
//  405     TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
        MOVS     R1,#+2
        LDR      R0,??DataTable3_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
        B        ??UartRxCallBack_1
//  406   }else{
//  407 	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
??UartRxCallBack_0:
        MOV      R0,SP
        BL       Uart1_GetByteFromRxBuffer
//  408   }
//  409 }
??UartRxCallBack_1:
        POP      {R0,R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2:
        DC32     `?<Constant "to start.">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_1:
        DC32     mMlmeNwkInputQueue

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_2:
        DC32     `?<Constant "Received an MLME-Beac...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_3:
        DC32     `?<Constant "Found a coordinator w...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_4:
        DC32     `?<Constant "---------------------...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_5:
        DC32     `?<Constant "\\n\\rAddress...........0x">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_6:
        DC32     mCoordInfo

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable2_7:
        DC32     `?<Constant "\\n\\rPAN ID............0x">`
//  410 
//  411 /******************************************************************************
//  412 * The App_StartScan(scanType) function will start the scan process of the
//  413 * specified type in the MAC. This is accomplished by allocating a MAC message,
//  414 * which is then assigned the desired scan parameters and sent to the MLME
//  415 * service access point.
//  416 * The function may return either of the following values:
//  417 *   errorNoError:          The Scan message was sent successfully.
//  418 *   errorInvalidParameter: The MLME service access point rejected the
//  419 *                          message due to an invalid parameter.
//  420 *   errorAllocFailed:      A message buffer could not be allocated.
//  421 *
//  422 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  423 static uint8_t App_StartScan(uint8_t scanType)
//  424 {
App_StartScan:
        PUSH     {R4-R6,LR}
        MOVS     R6,R0
//  425   mlmeMessage_t *pMsg;
//  426   mlmeScanReq_t *pScanReq;
//  427 
//  428   UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable8_1
        BL       UartUtil_Print
//  429 
//  430   /* Allocate a message for the MLME (We should check for NULL). */
//  431   pMsg = MSG_AllocType(mlmeMessage_t);
        MOVS     R0,#+15
        BL       MM_Alloc
        MOVS     R4,R0
//  432   if(pMsg != NULL)
        CMP      R4,#+0
        BEQ      ??App_StartScan_0
//  433   {
//  434     /* This is a MLME-SCAN.req command */
//  435     pMsg->msgType = gMlmeScanReq_c;
        MOVS     R0,#+8
        STRB     R0,[R4, #+0]
//  436     /* Create the Scan request message data. */
//  437     pScanReq = &pMsg->msgData.scanReq;
        MOVS     R0,R4
        ADDS     R0,R0,#+1
        MOVS     R5,R0
//  438     /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
//  439     pScanReq->scanType = scanType;
        STRB     R6,[R5, #+0]
//  440     /* ChannelsToScan & 0xFF - LSB, always 0x00 */
//  441     pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
        MOVS     R0,#+0
        STRB     R0,[R5, #+1]
//  442     /* ChannelsToScan>>8 & 0xFF  */
//  443     pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
        MOVS     R0,#+248
        STRB     R0,[R5, #+2]
//  444     /* ChannelsToScan>>16 & 0xFF  */
//  445     pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
        MOVS     R0,#+255
        STRB     R0,[R5, #+3]
//  446     /* ChannelsToScan>>24 & 0xFF - MSB */
//  447     pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
        MOVS     R0,#+7
        STRB     R0,[R5, #+4]
//  448     /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
//  449        A scan duration of 3 on 16 channels approximately takes 2 secs. */
//  450     pScanReq->scanDuration = 3;
        MOVS     R0,#+3
        STRB     R0,[R5, #+5]
//  451 #ifdef gMAC2006_d
//  452 	pScanReq->securityLevel = 0;
//  453 #endif //gMAC2006_d	
//  454     
//  455     /* Send the Scan request to the MLME. */
//  456     if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
        MOVS     R0,R4
        BL       NWK_MLME_SapHandler
        CMP      R0,#+0
        BNE      ??App_StartScan_1
//  457     {
//  458       UartUtil_Print("Done\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable8_2
        BL       UartUtil_Print
//  459       return errorNoError;
        MOVS     R0,#+0
        B        ??App_StartScan_2
//  460     }
//  461     else
//  462     {
//  463       UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
??App_StartScan_1:
        MOVS     R1,#+1
        LDR      R0,??DataTable8_3
        BL       UartUtil_Print
//  464       return errorInvalidParameter;
        MOVS     R0,#+5
        B        ??App_StartScan_2
//  465     }
//  466   }
//  467   else
//  468   {
//  469     /* Allocation of a message buffer failed. */
//  470     UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
??App_StartScan_0:
        MOVS     R1,#+1
        LDR      R0,??DataTable8_4
        BL       UartUtil_Print
//  471     return errorAllocFailed;
        MOVS     R0,#+4
??App_StartScan_2:
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
//  472   }
//  473 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     `?<Constant "MyWirelessApp Demo No...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_1:
        DC32     gAppTaskID_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_2:
        DC32     `?<Constant "\\n\\rLogical Channel...0x">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_3:
        DC32     `?<Constant "\\n\\rBeacon Spec.......0x">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_4:
        DC32     `?<Constant "\\n\\rLink Quality......0x">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_5:
        DC32     `?<Constant "\\n\\r\\n\\r">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_6:
        DC32     `?<Constant "Scan did not find a s...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_7:
        DC32     `?<Constant "No coordinator">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_8:
        DC32     `?<Constant "found.">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_9:
        DC32     `?<Constant "Associating to PAN co...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_10:
        DC32     `?<Constant "Associating to ">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_11:
        DC32     `?<Constant "PAN coordinator">`
//  474 
//  475 /******************************************************************************
//  476 * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
//  477 * Active Scan confirm message received from the MLME when the Active scan has
//  478 * completed. The message contains a list of PAN descriptors. Based on link
//  479 * quality inforamtion in the pan descriptors the nearest coordinator is chosen.
//  480 * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
//  481 *
//  482 * The function may return either of the following values:
//  483 *   errorNoError:       A suitable pan descriptor was found.
//  484 *   errorNoScanResults: No scan results were present in the confirm message.
//  485 *
//  486 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  487 static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
//  488 {
App_HandleScanActiveConfirm:
        PUSH     {R0,R4-R7,LR}
        SUB      SP,SP,#+8
//  489   void    *pBlock;
//  490   uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
        MOV      R0,SP
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+3]
        STRB     R1,[R0, #+1]
//  491   uint8_t rc = errorNoScanResults;
        MOV      R0,SP
        MOVS     R1,#+6
        STRB     R1,[R0, #+0]
//  492   uint8_t j;
//  493   uint8_t bestLinkQuality = 0;  
        MOVS     R0,#+0
        MOVS     R7,R0
//  494   panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+8
        BL       __aeabi_uread4
        MOVS     R6,R0
//  495   panDescriptor_t *pPanDesc;    
//  496   
//  497  
//  498   /* Check if the scan resulted in any coordinator responses. */  
//  499   
//  500   if (panDescListSize > 0)
        MOV      R0,SP
        LDRB     R0,[R0, #+1]
        CMP      R0,#+1
        BCC      ??App_HandleScanActiveConfirm_0
//  501   {    
//  502     /* Check all PAN descriptors. */
//  503     while (NULL != pDescBlock)
??App_HandleScanActiveConfirm_1:
        CMP      R6,#+0
        BEQ      ??App_HandleScanActiveConfirm_0
//  504     {
//  505       for (j = 0; j < pDescBlock->descriptorCount; j++)
        MOVS     R0,#+0
        MOVS     R4,R0
??App_HandleScanActiveConfirm_2:
        MOVS     R0,#+110
        LDRB     R0,[R6, R0]
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,R0
        BCS      ??App_HandleScanActiveConfirm_3
//  506       {            
//  507         pPanDesc = &pDescBlock->descriptorList[j];
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+22
        MULS     R0,R4,R0
        ADDS     R0,R6,R0
        MOVS     R5,R0
//  508 
//  509         /* Only attempt to associate if the coordinator
//  510            accepts associations and is non-beacon. */
//  511         if( ( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) && 
//  512             ((pPanDesc->superFrameSpec[0] & gSuperFrameSpecLsbBO_c) == 0x0F) )
        LDRB     R0,[R5, #+16]
        LSLS     R0,R0,#+24
        BPL      ??App_HandleScanActiveConfirm_4
        LDRB     R0,[R5, #+15]
        LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
        LSRS     R0,R0,#+28
        CMP      R0,#+15
        BNE      ??App_HandleScanActiveConfirm_4
//  513         {        
//  514           
//  515           /* Find the nearest coordinator using the link quality measure. */
//  516           if(pPanDesc->linkQuality > bestLinkQuality)
        LDRB     R0,[R5, #+18]
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        CMP      R7,R0
        BCS      ??App_HandleScanActiveConfirm_4
//  517           {
//  518             /* Save the information of the coordinator candidate. If we
//  519                find a better candiate, the information will be replaced. */
//  520             FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
        MOVS     R2,#+22
        MOVS     R1,R5
        LDR      R0,??DataTable9
        BL       FLib_MemCpy
//  521             bestLinkQuality = pPanDesc->linkQuality;
        LDRB     R0,[R5, #+18]
        MOVS     R7,R0
//  522             rc = errorNoError;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  523           }
//  524         }      
//  525       }
??App_HandleScanActiveConfirm_4:
        ADDS     R4,R4,#+1
        B        ??App_HandleScanActiveConfirm_2
//  526       
//  527       /* Free current block */
//  528       pBlock = pDescBlock;
??App_HandleScanActiveConfirm_3:
        STR      R6,[SP, #+4]
//  529       pDescBlock = pDescBlock->pNext;              
        ADDS     R6,R6,#+111
        MOVS     R0,R6
        BL       __aeabi_uread4
        MOVS     R6,R0
//  530       MSG_Free(pBlock);
        LDR      R0,[SP, #+4]
        BL       MM_Free
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        B        ??App_HandleScanActiveConfirm_1
//  531     }
//  532   }
//  533   
//  534   if (pDescBlock)
??App_HandleScanActiveConfirm_0:
        CMP      R6,#+0
        BEQ      ??App_HandleScanActiveConfirm_5
//  535       MSG_Free(pDescBlock);
        MOVS     R0,R6
        BL       MM_Free
        MOVS     R0,#+0
        MOVS     R6,R0
//  536   
//  537   return rc;
??App_HandleScanActiveConfirm_5:
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        POP      {R1-R7}
        POP      {R3}
        BX       R3               ;; return
//  538 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable4:
        DC32     `?<Constant "Successfully associat...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable4_1:
        DC32     `?<Constant "We were assigned the ...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable4_2:
        DC32     mAddrMode

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable4_3:
        DC32     maMyAddress

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable4_4:
        DC32     `?<Constant "\\n\\r\\n\\rReady to send and...">`
//  539 
//  540 /******************************************************************************
//  541 * The App_SendAssociateRequest(void) will create an Associate Request message
//  542 * and send it to the coordinator it wishes to associate to. The function uses
//  543 * information gained about the coordinator during the scan procedure.
//  544 *
//  545 * The function may return either of the following values:
//  546 *   errorNoError:          The Associate Request message was sent successfully.
//  547 *   errorInvalidParameter: The MLME service access point rejected the
//  548 *                          message due to an invalid parameter.
//  549 *   errorAllocFailed:      A message buffer could not be allocated.
//  550 *
//  551 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  552 static uint8_t App_SendAssociateRequest(void)
//  553 {
App_SendAssociateRequest:
        PUSH     {R3-R5,LR}
//  554   mlmeMessage_t *pMsg;
//  555   mlmeAssociateReq_t *pAssocReq;
//  556 
//  557   UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable9_1
        BL       UartUtil_Print
//  558   
//  559   /* Allocate a message for the MLME message. */
//  560   pMsg = MSG_AllocType(mlmeMessage_t);
        MOVS     R0,#+15
        BL       MM_Alloc
        MOVS     R5,R0
//  561   if(pMsg != NULL)
        CMP      R5,#+0
        BEQ      ??App_SendAssociateRequest_0
//  562   {
//  563     /* This is a MLME-ASSOCIATE.req command. */
//  564     pMsg->msgType = gMlmeAssociateReq_c;
        MOVS     R0,#+0
        STRB     R0,[R5, #+0]
//  565     
//  566     /* Create the Associate request message data. */
//  567     pAssocReq = &pMsg->msgData.associateReq;
        MOVS     R0,R5
        ADDS     R0,R0,#+1
        MOVS     R4,R0
//  568  
//  569     /* Use the coordinator info we got from the Active Scan. */
//  570     FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
        MOVS     R2,#+8
        LDR      R1,??DataTable9
        MOVS     R0,R4
        BL       FLib_MemCpy
//  571     FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
        MOVS     R2,#+2
        LDR      R1,??DataTable9
        ADDS     R1,R1,#+8
        MOVS     R0,R4
        ADDS     R0,R0,#+8
        BL       FLib_MemCpy
//  572     pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
        LDR      R0,??DataTable9
        LDRB     R0,[R0, #+10]
        STRB     R0,[R4, #+10]
//  573     pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
        LDR      R0,??DataTable9
        LDRB     R0,[R0, #+11]
        STRB     R0,[R4, #+11]
//  574 #ifdef gMAC2006_d
//  575 	pAssocReq->securityLevel = 0;
//  576 #else	
//  577     pAssocReq->securityEnable     = FALSE;
        MOVS     R0,#+0
        STRB     R0,[R4, #+12]
//  578 #endif //gMAC2006_d	
//  579     /* We want the coordinator to assign a short address to us. */
//  580     pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
        MOVS     R0,#+128
        STRB     R0,[R4, #+13]
//  581       
//  582     /* Send the Associate Request to the MLME. */
//  583     if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
        MOVS     R0,R5
        BL       NWK_MLME_SapHandler
        CMP      R0,#+0
        BNE      ??App_SendAssociateRequest_1
//  584     {
//  585       UartUtil_Print("Done\n\r", gAllowToBlock_d);
        MOVS     R1,#+1
        LDR      R0,??DataTable8_2
        BL       UartUtil_Print
//  586       return errorNoError;
        MOVS     R0,#+0
        B        ??App_SendAssociateRequest_2
//  587     }
//  588     else
//  589     {
//  590       /* One or more parameters in the message were invalid. */
//  591       UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
??App_SendAssociateRequest_1:
        MOVS     R1,#+1
        LDR      R0,??DataTable8_3
        BL       UartUtil_Print
//  592       return errorInvalidParameter;
        MOVS     R0,#+5
        B        ??App_SendAssociateRequest_2
//  593     }
//  594   }
//  595   else
//  596   {
//  597     /* Allocation of a message buffer failed. */
//  598     UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
??App_SendAssociateRequest_0:
        MOVS     R1,#+1
        LDR      R0,??DataTable8_4
        BL       UartUtil_Print
//  599     return errorAllocFailed;
        MOVS     R0,#+4
??App_SendAssociateRequest_2:
        POP      {R1,R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  600   }
//  601 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     `?<Constant "Ready to send">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_1:
        DC32     `?<Constant "and receive data">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_2:
        DC32     AppPollWaitTimeout

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_3:
        DC32     mPollInterval

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_4:
        DC32     mTimer_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_5:
        DC32     `?<Constant "\\n\\rAssociate Confirm w...">`
//  602 
//  603 /******************************************************************************
//  604 * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
//  605 * Associate confirm message received from the MLME when the Association
//  606 * procedure has completed. The message contains the short address that the
//  607 * coordinator has assigned to us. This address is 0xfffe if we did not specify
//  608 * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
//  609 * request. The address and address mode are saved in global variables. They
//  610 * will be used in the next demo application when sending data.
//  611 *
//  612 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  613 static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
//  614 {
App_HandleAssociateConfirm:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  615   /* This is our own extended address (MAC address). It cannot be modified. */
//  616   extern uint8_t aExtendedAddress[8];
//  617   
//  618   /* If the coordinator assigns a short address of 0xfffe then,
//  619      that means we must use our own extended address in all
//  620      communications with the coordinator. Otherwise, we use
//  621      the short address assigned to us. */
//  622   if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BNE      ??App_HandleAssociateConfirm_0
//  623   {
//  624 
//  625 	  if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
//  626 	      (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
        LDRB     R0,[R4, #+1]
        CMP      R0,#+254
        BCC      ??App_HandleAssociateConfirm_1
        LDRB     R0,[R4, #+2]
        CMP      R0,#+255
        BNE      ??App_HandleAssociateConfirm_1
//  627 	  {
//  628 	    mAddrMode = gAddrModeLong_c;
        LDR      R0,??DataTable10
        MOVS     R1,#+3
        STRB     R1,[R0, #+0]
//  629 	    FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
        MOVS     R2,#+8
        LDR      R1,??DataTable10_1
        LDR      R0,??DataTable11
        BL       FLib_MemCpy
        B        ??App_HandleAssociateConfirm_2
//  630 	  }
//  631 	  else
//  632 	  {
//  633 	    mAddrMode = gAddrModeShort_c;
??App_HandleAssociateConfirm_1:
        LDR      R0,??DataTable10
        MOVS     R1,#+2
        STRB     R1,[R0, #+0]
//  634 	    FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
        MOVS     R2,#+2
        MOVS     R1,R4
        ADDS     R1,R1,#+1
        LDR      R0,??DataTable11
        BL       FLib_MemCpy
//  635 	  }
//  636 	    return gSuccess_c;
??App_HandleAssociateConfirm_2:
        MOVS     R0,#+0
        B        ??App_HandleAssociateConfirm_3
//  637   } 
//  638   
//  639   else 
//  640   {
//  641 	return pMsg->msgData.associateCnf.status; 
??App_HandleAssociateConfirm_0:
        LDRB     R0,[R4, #+3]
??App_HandleAssociateConfirm_3:
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  642   }
//  643 }
//  644 /******************************************************************************
//  645 * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
//  646 * messages from the MLME, e.g. poll confirm.
//  647 *
//  648 * The function may return either of the following values:
//  649 *   errorNoError:   The message was processed.
//  650 *   errorNoMessage: The message pointer is NULL.
//  651 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  652 static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
//  653 {
App_HandleMlmeInput:
        PUSH     {LR}
        MOVS     R1,R0
//  654   if(pMsg == NULL)
        CMP      R1,#+0
        BNE      ??App_HandleMlmeInput_0
//  655     return errorNoMessage;
        MOVS     R0,#+3
        B        ??App_HandleMlmeInput_1
//  656   
//  657   /* Handle the incoming message. The type determines the sort of processing.*/
//  658   switch(pMsg->msgType) {
??App_HandleMlmeInput_0:
        LDRB     R0,[R1, #+0]
        CMP      R0,#+16
        BNE      ??App_HandleMlmeInput_2
//  659   case gNwkPollCnf_c:
//  660     if(pMsg->msgData.pollCnf.status != gSuccess_c)
        LDRB     R0,[R1, #+1]
        CMP      R0,#+0
        BEQ      ??App_HandleMlmeInput_2
//  661     {
//  662       /* The Poll Confirm status was not successful. Usually this happens if
//  663          no data was available at the coordinator. In this case we start
//  664          polling at a lower rate to conserve power. */
//  665       mPollInterval = mDefaultValueOfPollIntervalSlow_c;
        LDR      R0,??DataTable10_2
        MOVS     R2,#+205
        LSLS     R2,R2,#+2        ;; #+820
        STRH     R2,[R0, #+0]
//  666       
//  667       /* If we get to this point, then no data was available, and we
//  668          allow a new poll request. Otherwise, we wait for the data
//  669          indication before allowing the next poll request. */
//  670       mWaitPollConfirm = FALSE;
        LDR      R0,??DataTable13
        MOVS     R2,#+0
        STRB     R2,[R0, #+0]
//  671     }
//  672     break;
//  673   }
//  674   return errorNoError;
??App_HandleMlmeInput_2:
        MOVS     R0,#+0
??App_HandleMlmeInput_1:
        POP      {R3}
        BX       R3               ;; return
//  675 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     mMcpsNwkInputQueue
//  676 
//  677 /******************************************************************************
//  678 * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
//  679 * messages from the MCPS, e.g. Data Confirm, and Data Indication.
//  680 *
//  681 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  682 static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
//  683 {
App_HandleMcpsInput:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  684   switch(pMsgIn->msgType)
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ      ??App_HandleMcpsInput_0
        SUBS     R0,R0,#+1
        BEQ      ??App_HandleMcpsInput_1
        B        ??App_HandleMcpsInput_2
//  685   {
//  686     /* The MCPS-Data confirm is sent by the MAC to the network 
//  687        or application layer when data has been sent. */
//  688   case gMcpsDataCnf_c:
//  689     if(mcPendingPackets)
??App_HandleMcpsInput_0:
        LDR      R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??App_HandleMcpsInput_2
//  690       mcPendingPackets--;
        LDR      R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR      R1,??DataTable10_3
        STRB     R0,[R1, #+0]
        B        ??App_HandleMcpsInput_2
//  691     break;
//  692 
//  693   case gMcpsDataInd_c:
//  694     /* Copy the received data to the UART. */
//  695     UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
??App_HandleMcpsInput_1:
        MOVS     R0,R4
        ADDS     R0,R0,#+27
        BL       __aeabi_uread4
        LDRB     R1,[R4, #+23]
        BL       UartUtil_Tx
//  696     /* Since we received data, the coordinator might have more to send. We 
//  697        reduce the polling interval to raise the throughput while data is
//  698        available. */
//  699     mPollInterval = mDefaultValueOfPollIntervalFast_c;
        LDR      R0,??DataTable10_2
        MOVS     R1,#+82
        STRH     R1,[R0, #+0]
//  700     /* Allow another MLME-Poll request. */
//  701     mWaitPollConfirm = FALSE;
        LDR      R0,??DataTable13
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  702     break;
//  703   }
//  704 }
??App_HandleMcpsInput_2:
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     gState

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8_1:
        DC32     `?<Constant "Sending the MLME-Scan...">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8_2:
        DC32     `?<Constant "Done\\n\\r">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8_3:
        DC32     `?<Constant "Invalid parameter!\\n\\r">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8_4:
        DC32     `?<Constant "Message allocation fa...">`
//  705 
//  706 /******************************************************************************
//  707 * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
//  708 * the name implies, wait for a message, thus blocking the execution of the
//  709 * state machine. Instead the function analyzes the supplied message to 
//  710 * determine whether or not the message is of the expected type.
//  711 * The function may return either of the following values:
//  712 *   errorNoError: The message was of the expected type.
//  713 *   errorNoMessage: The message pointer is NULL.
//  714 *   errorWrongConfirm: The message is not of the expected type.
//  715 *
//  716 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  717 static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
//  718 {
App_WaitMsg:
        PUSH     {LR}
        MOVS     R2,R0
//  719   /* Do we have a message? If not, the exit with error code */
//  720   if(pMsg == NULL)
        CMP      R2,#+0
        BNE      ??App_WaitMsg_0
//  721     return errorNoMessage;
        MOVS     R0,#+3
        B        ??App_WaitMsg_1
//  722 
//  723   /* Is it the expected message type? If not then exit with error code */
//  724   if(pMsg->msgType != msgType)
??App_WaitMsg_0:
        LDRB     R0,[R2, #+0]
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R0,R1
        BEQ      ??App_WaitMsg_2
//  725     return errorWrongConfirm;
        MOVS     R0,#+1
        B        ??App_WaitMsg_1
//  726 
//  727   /* Found the expected message. Return with success code */
//  728   return errorNoError;
??App_WaitMsg_2:
        MOVS     R0,#+0
??App_WaitMsg_1:
        POP      {R3}
        BX       R3               ;; return
//  729 }
//  730 
//  731 /******************************************************************************
//  732 * The App_TransmitUartData() function will perform (single/multi buffered)
//  733 * data transmissions of data received by the UART. Data could also come from
//  734 * other sources such as sensors etc. This is completely determined by the
//  735 * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
//  736 * number of packets pending for transmission in the MAC. A global variable
//  737 * is incremented each time a data packet is sent to the MCPS, and decremented
//  738 * when the corresponding MCPS-Data Confirm message is received. If the counter
//  739 * reaches the defined maximum no more data buffers are allocated until the
//  740 * counter is decreased below the maximum number of pending packets.
//  741 *
//  742 * The function uses the coordinator information gained during the Active Scan,
//  743 * and the short address assigned to us by coordinator, for building an MCPS-
//  744 * Data Request message. The message is sent to the MCPS service access point
//  745 * in the MAC.
//  746 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  747 static void App_TransmitUartData(void)
//  748 {   
App_TransmitUartData:
        PUSH     {R7,LR}
//  749   static uint8_t keysBuffer[mMaxKeysToReceive_c];
//  750   static uint8_t keysReceived = 0;
//  751   
//  752   /* get data from UART */
//  753   if( keysReceived < mMaxKeysToReceive_c ) 
        LDR      R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+32
        BCS      ??App_TransmitUartData_0
//  754   {
//  755     if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
        LDR      R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        LDR      R1,??DataTable13_2
        ADDS     R0,R1,R0
        BL       Uart1_GetByteFromRxBuffer
        CMP      R0,#+0
        BEQ      ??App_TransmitUartData_0
//  756     {
//  757     keysReceived++;
        LDR      R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable13_1
        STRB     R0,[R1, #+0]
//  758     }
//  759   }
//  760 	/* Use multi buffering for increased TX performance. It does not really
//  761      have any effect at a UART baud rate of 19200bps but serves as an
//  762      example of how the throughput may be improved in a real-world 
//  763      application where the data rate is of concern. */
//  764   if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
??App_TransmitUartData_0:
        LDR      R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BCS      ??App_TransmitUartData_1
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??App_TransmitUartData_1
//  765   {
//  766     /* If the maximum number of pending data buffes is below maximum limit 
//  767        and we do not have a data buffer already then allocate one. */
//  768     mpPacket = MSG_AllocType(nwkToMcpsMessage_t);
        MOVS     R0,#+30
        BL       MM_Alloc
        LDR      R1,??DataTable13_3
        STR      R0,[R1, #+0]
//  769   }
//  770 
//  771   if(mpPacket != NULL)
??App_TransmitUartData_1:
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??App_TransmitUartData_2
//  772   {
//  773     /* get data from UART */        
//  774       mpPacket->msgData.dataReq.pMsdu = &keysBuffer[0];
        LDR      R0,??DataTable13_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+26
        LDR      R0,??DataTable13_2
        BL       __aeabi_uwrite4
//  775       /* Data was available in the UART receive buffer. Now create an
//  776          MCPS-Data Request message containing the UART data. */
//  777       mpPacket->msgType = gMcpsDataReq_c;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  778       /* Create the header using coordinator information gained during 
//  779          the scan procedure. Also use the short address we were assigned
//  780          by the coordinator during association. */
//  781       FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, mCoordInfo.coordAddress, 8);
        MOVS     R2,#+8
        LDR      R1,??DataTable9
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+1
        BL       FLib_MemCpy
//  782       FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
        MOVS     R2,#+8
        LDR      R1,??DataTable11
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+12
        BL       FLib_MemCpy
//  783       FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
        MOVS     R2,#+2
        LDR      R1,??DataTable9
        ADDS     R1,R1,#+8
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+9
        BL       FLib_MemCpy
//  784       FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
        MOVS     R2,#+2
        LDR      R1,??DataTable9
        ADDS     R1,R1,#+8
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+20
        BL       FLib_MemCpy
//  785       mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable9
        LDRB     R1,[R1, #+10]
        STRB     R1,[R0, #+11]
//  786       mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable10
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+22]
//  787       mpPacket->msgData.dataReq.msduLength = keysReceived;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable13_1
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+23]
//  788       /* Request MAC level acknowledgement of the data packet */
//  789       mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        MOVS     R1,#+1
        STRB     R1,[R0, #+25]
//  790       /* Give the data packet a handle. The handle is
//  791          returned in the MCPS-Data Confirm message. */
//  792       mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable13_4
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+24]
        LDR      R0,??DataTable13_4
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable13_4
        STRB     R0,[R1, #+0]
//  793 #ifdef gMAC2006_d
//  794 	  /* Don't use security */
//  795 	  mpPacket->msgData.dataReq.securityLevel = 0;
//  796 #endif //gMAC2006_d      
//  797       /* Send the Data Request to the MCPS */
//  798       (void)MSG_Send(NWK_MCPS, mpPacket);
        LDR      R0,??DataTable13_3
        LDR      R0,[R0, #+0]
        BL       NWK_MCPS_SapHandler
//  799       /* Prepare for another data buffer */
//  800       mpPacket = NULL;
        LDR      R0,??DataTable13_3
        MOVS     R1,#+0
        STR      R1,[R0, #+0]
//  801       mcPendingPackets++;
        LDR      R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable10_3
        STRB     R0,[R1, #+0]
//  802       /* Receive another pressed keys */
//  803       keysReceived = 0;
        LDR      R0,??DataTable13_1
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  804   }
//  805       
//  806   /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
//  807   /* try to send it later   */
//  808   if (keysReceived)
??App_TransmitUartData_2:
        LDR      R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??App_TransmitUartData_3
//  809   {
//  810   TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
        MOVS     R1,#+2
        LDR      R0,??DataTable13_5
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  811   }
//  812 
//  813 }
??App_TransmitUartData_3:
        POP      {R0,R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable9:
        DC32     mCoordInfo

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable9_1:
        DC32     `?<Constant "Sending the MLME-Asso...">`

        SECTION `.bss`:DATA:NOROOT(2)
??keysBuffer:
        DS8 32

        SECTION `.bss`:DATA:NOROOT(0)
??keysReceived:
        DS8 1
//  814 
//  815 /******************************************************************************
//  816 * The App_ReceiveUartData() function will check if it is time to send out an
//  817 * MLME-Poll request in order to receive data from the coordinator. If its time,
//  818 * and we are permitted then a poll request is created and sent.
//  819 * 
//  820 * The function uses the coordinator information gained during the Active Scan
//  821 * for building the MLME-Poll Request message. The message is sent to the MLME
//  822 * service access point in the MAC.
//  823 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  824 static void    AppPollWaitTimeout(uint8_t tmr)
//  825 { 
AppPollWaitTimeout:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  826   
//  827   /* Just to avoid the compiler warning */
//  828   tmr++;
        ADDS     R4,R4,#+1
//  829   
//  830   /* Check if we are permitted, and if it is time to send a poll request.
//  831      The poll interval is adjusted dynamically to the current band-width
//  832      requirements. */
//  833   if(mWaitPollConfirm == FALSE)
        LDR      R0,??DataTable13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??AppPollWaitTimeout_0
//  834   {
//  835     /* This is an MLME-POLL.req command. */
//  836     mlmeMessage_t *pMlmeMsg = MSG_AllocType(mlmeMessage_t);
        MOVS     R0,#+15
        BL       MM_Alloc
        MOVS     R5,R0
//  837     if(pMlmeMsg)
        CMP      R5,#+0
        BEQ      ??AppPollWaitTimeout_0
//  838     {
//  839       /* Create the Poll Request message data. */
//  840       pMlmeMsg->msgType = gMlmePollReq_c;
        MOVS     R0,#+12
        STRB     R0,[R5, #+0]
//  841  
//  842       /* Use the coordinator information we got from the Active Scan. */
//  843       FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordAddress, mCoordInfo.coordAddress, 8);
        MOVS     R2,#+8
        LDR      R1,??DataTable10_4
        MOVS     R0,R5
        ADDS     R0,R0,#+1
        BL       FLib_MemCpy
//  844       FLib_MemCpy(pMlmeMsg->msgData.pollReq.coordPanId, mCoordInfo.coordPanId, 2);
        MOVS     R2,#+2
        LDR      R1,??DataTable10_4
        ADDS     R1,R1,#+8
        MOVS     R0,R5
        ADDS     R0,R0,#+9
        BL       FLib_MemCpy
//  845       pMlmeMsg->msgData.pollReq.coordAddrMode = mCoordInfo.coordAddrMode;
        LDR      R0,??DataTable10_4
        LDRB     R0,[R0, #+10]
        STRB     R0,[R5, #+11]
//  846 #ifdef gMAC2006_d
//  847       pMlmeMsg->msgData.pollReq.securityLevel = 0;
//  848 #else      
//  849       pMlmeMsg->msgData.pollReq.securityEnable = FALSE;
        MOVS     R0,#+0
        STRB     R0,[R5, #+12]
//  850 #endif //gMAC2006_d      
//  851       
//  852       /* Send the Poll Request to the MLME. */
//  853       if(MSG_Send(NWK_MLME, pMlmeMsg) == gSuccess_c)
        MOVS     R0,R5
        BL       NWK_MLME_SapHandler
        CMP      R0,#+0
        BNE      ??AppPollWaitTimeout_0
//  854       {
//  855         /* Do not allow another Poll request before the confirm is received. */
//  856         mWaitPollConfirm = TRUE;
        LDR      R0,??DataTable13
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  857 
//  858       }
//  859     }
//  860   }
//  861  /* Restart timer. */
//  862  TMR_StartSingleShotTimer(mTimer_c, mPollInterval, AppPollWaitTimeout);
??AppPollWaitTimeout_0:
        LDR      R2,??DataTable13_6
        LDR      R0,??DataTable10_2
        LDRH     R1,[R0, #+0]
        LDR      R0,??DataTable13_7
        LDRB     R0,[R0, #+0]
        BL       TMR_StartSingleShotTimer
//  863 }
        POP      {R0,R4,R5}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable10:
        DC32     mAddrMode

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable10_1:
        DC32     aExtendedAddress

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable10_2:
        DC32     mPollInterval

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable10_3:
        DC32     mcPendingPackets

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable10_4:
        DC32     mCoordInfo
//  864 
//  865 /*****************************************************************************
//  866 * Handles all key events for this device.
//  867 * Interface assumptions: None
//  868 * Return value: None
//  869 *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  870 static void App_HandleKeys
//  871   (
//  872   key_event_t events  /*IN: Events from keyboard modul */
//  873   )
//  874     
//  875     /*WSNProject*****************************************************************************
//  876       * A seguire:
//  877     * Alcuni controlli sugli switch: setta e controlla parametri MAC PIB
//  878 * Lo scopo di tutto ciò è verificare che le data request non vengano più mandate
//  879     *per cessare tutte le task attive
//  880 *****************************************************************************/
//  881 {
App_HandleKeys:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  882   switch ( events ) 
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,R4
        SUBS     R0,R0,#+1
        BEQ      ??App_HandleKeys_0
        SUBS     R0,R0,#+1
        BEQ      ??App_HandleKeys_1
        SUBS     R0,R0,#+1
        BEQ      ??App_HandleKeys_2
        SUBS     R0,R0,#+1
        CMP      R0,#+4
        BLS      ??App_HandleKeys_3
        B        ??App_HandleKeys_4
//  883     { 
//  884       case gKBD_EventSW1_c:
//  885         if(gState == stateListen)
??App_HandleKeys_0:
        LDR      R0,??DataTable13_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE      ??App_HandleKeys_5
//  886         {
//  887           dataSet= FALSE;
        LDR      R0,??DataTable13_9
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  888           App_SetParam(gMPibAutoRequest_c, &dataSet);
        LDR      R1,??DataTable13_9
        MOVS     R0,#+66
        BL       App_SetParam
//  889           dataSet= FALSE;
        LDR      R0,??DataTable13_9
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  890           App_SetParam(gMPibRxOnWhenIdle_c, &dataSet);
        LDR      R1,??DataTable13_9
        MOVS     R0,#+82
        BL       App_SetParam
//  891           break;
        B        ??App_HandleKeys_6
//  892         }
//  893       case gKBD_EventSW2_c:
//  894         if(gState == stateListen)
??App_HandleKeys_1:
??App_HandleKeys_5:
        LDR      R0,??DataTable13_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE      ??App_HandleKeys_7
//  895         {
//  896           App_GetParam(gMPibAutoRequest_c, &dataGet);
        LDR      R1,??DataTable13_10
        MOVS     R0,#+66
        BL       App_GetParam
//  897           UartUtil_PrintHex((uint8_t*)&dataGet, 1, 0);
        MOVS     R2,#+0
        MOVS     R1,#+1
        LDR      R0,??DataTable13_10
        BL       UartUtil_PrintHex
//  898           //verifica già fatta: RxOnWhenIdle è FALSE (val==0) di default
//  899           //(probabilmente quando la powerlib è introdotta a TRUE in AppConf.h)
//  900           App_GetParam(gMPibRxOnWhenIdle_c, &dataUGet);
        LDR      R1,??DataTable13_11
        MOVS     R0,#+82
        BL       App_GetParam
//  901           UartUtil_PrintHex((uint8_t*)&dataUGet, 1, 0);
        MOVS     R2,#+0
        MOVS     R1,#+1
        LDR      R0,??DataTable13_11
        BL       UartUtil_PrintHex
//  902           break;
        B        ??App_HandleKeys_6
//  903         }
//  904       case gKBD_EventSW3_c:
//  905         if(gState == stateListen)
??App_HandleKeys_2:
??App_HandleKeys_7:
        LDR      R0,??DataTable13_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE      ??App_HandleKeys_8
//  906         {
//  907           dataSet= TRUE;
        LDR      R0,??DataTable13_9
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  908           App_SetParam(gMPibAutoRequest_c, &dataSet);
        LDR      R1,??DataTable13_9
        MOVS     R0,#+66
        BL       App_SetParam
//  909           break;
        B        ??App_HandleKeys_6
//  910         }
//  911       case gKBD_EventSW4_c:
//  912       case gKBD_EventLongSW1_c:
//  913       case gKBD_EventLongSW2_c:
//  914       case gKBD_EventLongSW3_c:
//  915       case gKBD_EventLongSW4_c:
//  916         if(gState == stateInit)
??App_HandleKeys_3:
??App_HandleKeys_8:
        LDR      R0,??DataTable13_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??App_HandleKeys_4
//  917           {
//  918           StopLed1Flashing();
        MOVS     R0,#+1
        BL       LED_StopFlash
//  919           StopLed2Flashing();
        MOVS     R0,#+2
        BL       LED_StopFlash
//  920           StopLed3Flashing();
        MOVS     R0,#+4
        BL       LED_StopFlash
//  921           StopLed4Flashing();
        MOVS     R0,#+8
        BL       LED_StopFlash
//  922           Led1Off();
        MOVS     R1,#+0
        MOVS     R0,#+23
        BL       Gpio_SetPinData
//  923           Led2Off();
        MOVS     R1,#+0
        MOVS     R0,#+24
        BL       Gpio_SetPinData
//  924           Led3Off();
        MOVS     R1,#+0
        MOVS     R0,#+25
        BL       Gpio_SetPinData
//  925           Led4Off();
        MOVS     R1,#+0
        MOVS     R0,#+44
        BL       Gpio_SetPinData
//  926           LCD_ClearDisplay();
//  927           LCD_WriteString(1,"Application");
        LDR      R0,??DataTable13_12
//  928           LCD_WriteString(2,"    started");     
        LDR      R0,??DataTable13_13
//  929           TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
        MOVS     R1,#+1
        LDR      R0,??DataTable13_5
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  930           }
//  931     }    
//  932 }
??App_HandleKeys_4:
??App_HandleKeys_6:
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable11:
        DC32     maMyAddress
//  933 
//  934 /*****************************************************************************
//  935 * The DeepSleepWakeupStackProc(void) function is called each time the 
//  936 * application exits the DeepSleep mode .
//  937 * 
//  938 * Return value:
//  939 *     None
//  940 *****************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  941 void DeepSleepWakeupStackProc(void){
//  942   return;
DeepSleepWakeupStackProc:
        BX       LR               ;; return
//  943 }
//  944 
//  945 /******************************************************************************
//  946 * The following functions are called by the MAC to put messages into the
//  947 * Application's queue. They need to be defined even if they are not used
//  948 * in order to avoid linker errors.
//  949 ******************************************************************************/
//  950 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  951 uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
//  952 {
MLME_NWK_SapHandler:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  953   /* Put the incoming MLME message in the applications input queue. */
//  954   MSG_Queue(&mMlmeNwkInputQueue, pMsg);
        MOVS     R1,R4
        LDR      R0,??DataTable13_14
        BL       List_AddTail
//  955   TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
        MOVS     R1,#+4
        LDR      R0,??DataTable13_5
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  956   return gSuccess_c;
        MOVS     R0,#+0
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  957 }
//  958 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  959 uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
//  960 {
MCPS_NWK_SapHandler:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  961   /* Put the incoming MCPS message in the applications input queue. */
//  962   MSG_Queue(&mMcpsNwkInputQueue, pMsg);
        MOVS     R1,R4
        LDR      R0,??DataTable13_15
        BL       List_AddTail
//  963   TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
        MOVS     R1,#+8
        LDR      R0,??DataTable13_5
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  964   return gSuccess_c;
        MOVS     R0,#+0
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  965 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13:
        DC32     mWaitPollConfirm

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_1:
        DC32     ??keysReceived

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_2:
        DC32     ??keysBuffer

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_3:
        DC32     mpPacket

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_4:
        DC32     mMsduHandle

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_5:
        DC32     gAppTaskID_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_6:
        DC32     AppPollWaitTimeout

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_7:
        DC32     mTimer_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_8:
        DC32     gState

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_9:
        DC32     dataSet

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_10:
        DC32     dataGet

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_11:
        DC32     dataUGet

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_12:
        DC32     `?<Constant "Application">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_13:
        DC32     `?<Constant "    started">`

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_14:
        DC32     mMlmeNwkInputQueue

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable13_15:
        DC32     mMcpsNwkInputQueue
//  966 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  967 uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
//  968 {
ASP_APP_SapHandler:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  969   /* If the message is not handled anywhere it must be freed. */
//  970   MSG_Free(pMsg);
        MOVS     R0,R4
        BL       MM_Free
        MOVS     R0,#+0
        MOVS     R4,R0
//  971   return gSuccess_c;
        MOVS     R0,#+0
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  972 }
//  973 
//  974 /******************************************************************************/
//  975 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  976 static uint8_t App_SetParam(uint8_t attribute, bool_t *pValue)
//  977 {
App_SetParam:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
        MOVS     R5,R0
        MOVS     R4,R1
//  978   mlmeMessage_t mlmeSet;
//  979   mlmeSet.msgType=gMlmeSetReq_c;
        MOV      R0,SP
        MOVS     R1,#+9
        STRB     R1,[R0, #+0]
//  980   mlmeSet.msgData.setReq.pibAttribute=attribute;
        MOV      R0,SP
        STRB     R5,[R0, #+1]
//  981   mlmeSet.msgData.setReq.pibAttributeValue=pValue;
        MOV      R1,SP
        ADDS     R1,R1,#+2
        MOVS     R0,R4
        BL       __aeabi_uwrite4
//  982  
//  983   return MSG_Send(NWK_MLME, &mlmeSet);
        MOV      R0,SP
        BL       NWK_MLME_SapHandler
        ADD      SP,SP,#+20
        POP      {R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  984   
//  985 }
//  986 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  987 static uint8_t App_GetParam(uint8_t attribute, bool_t* pValue)
//  988 {
App_GetParam:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
        MOVS     R5,R0
        MOVS     R4,R1
//  989   mlmeMessage_t mlmeGet;
//  990   mlmeGet.msgType=gMlmeGetReq_c;
        MOV      R0,SP
        MOVS     R1,#+3
        STRB     R1,[R0, #+0]
//  991   mlmeGet.msgData.getReq.pibAttribute=attribute;
        MOV      R0,SP
        STRB     R5,[R0, #+1]
//  992   mlmeGet.msgData.getReq.pibAttributeValue=pValue;
        MOV      R1,SP
        ADDS     R1,R1,#+2
        MOVS     R0,R4
        BL       __aeabi_uwrite4
//  993  
//  994   return MSG_Send(NWK_MLME, &mlmeGet);
        MOV      R0,SP
        BL       NWK_MLME_SapHandler
        ADD      SP,SP,#+20
        POP      {R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  995 }

        END
// 
//    95 bytes in section .bss
//     1 byte  in section .data
// 1 116 bytes in section .rodata
// 2 530 bytes in section .text
// 
// 2 530 bytes of CODE  memory
// 1 116 bytes of CONST memory
//    96 bytes of DATA  memory
//
//Errors: none
//Warnings: none
