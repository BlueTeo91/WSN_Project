///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      08/Dec/2015  17:58:52 /
// IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM               /
// Copyright (C) 1999-2010 IAR Systems AB.                                    /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Configure\GlobalVars.c              /
//    Command line =  "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Configure\GlobalVars.c" -D          /
//                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D      /
//                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess    /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Debug\List\" -lC "C:\Documents and              /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" -lB "C:\Documents and  /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\List\" --diag_suppress        /
//                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and      /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Debug\Obj\" --no_cse --no_unroll    /
//                    --no_inline --no_code_motion --no_tbaa --no_clustering  /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program   /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\DLib_Config_Normal.h" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\MacPhy\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Init\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\Interface\" -I "C:\Documents and    /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Configure\" -I          /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Application\UartUtil\" -I "C:\Documents and     /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\Application\Source\" -I             /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\TS\Interface\" -I "C:\Documents and         /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\TS\Source\" -I "C:\Documents    /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\SSM\ZTC\Interface\" -I "C:\Documents and        /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\SSM\ZTC\Source\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Interface\" -I "C:\Documents and            /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\LibInterface\" -I               /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\Display\" -I "C:\Documents and       /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\Keyboard\" -I            /
//                    "C:\Documents and Settings\Administrator\Desktop\Copy   /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\NVM\" -I "C:\Documents and           /
//                    Settings\Administrator\Desktop\Copy of MyWirelessApp    /
//                    Demo Non Beacon (End Device)\MyWirelessApp Demo Non     /
//                    Beacon (End Device)\PLM\Source\TMR\" -I "C:\Documents   /
//                    and Settings\Administrator\Desktop\Copy of              /
//                    MyWirelessApp Demo Non Beacon (End                      /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\PLM\Source\UART\" -I "C:\Program Files\IAR      /
//                    Systems\Embedded Workbench 5.4 Evaluation\arm\INC\"     /
//                    --interwork --cpu_mode thumb -On                        /
//    List file    =  C:\Documents and Settings\Administrator\Desktop\Copy    /
//                    of MyWirelessApp Demo Non Beacon (End                   /
//                    Device)\MyWirelessApp Demo Non Beacon (End              /
//                    Device)\Debug\List\GlobalVars.s                         /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME GlobalVars

        EXTERN FLib_MemSet
        EXTERN MM_GetLinkRegister
        EXTERN __aeabi_uread4
        EXTERN __aeabi_uwrite4

        PUBLIC MM_AddMsgToTrackingArray
        PUBLIC MM_GetMsgIndex
        PUBLIC MM_InitMsgTracking
        PUBLIC MM_UpdateMsgTracking
        PUBLIC MsgTrackingArray
        PUBLIC NoOfWrongAddrs
        PUBLIC TotalNoOfMsgs_c
        PUBLIC gNumAclEntryDescriptors
        PUBLIC gPIBaclEntryDescriptorSet
        PUBLIC maMacHeap
        PUBLIC maMmPools
        PUBLIC pLastPool
        PUBLIC pSecondLastPool
        PUBLIC poolInfo

// C:\Documents and Settings\Administrator\Desktop\Copy of MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\Application\Configure\GlobalVars.c
//    1 /************************************************************************************
//    2 * This module implements the memory allocation, list, and message modules. The memory 
//    3 * allocation is build around N (1-4) pools with various memory allocation unit (block)
//    4 * sizes. Each pool consists of an anchor with head and tail pointers. The memory blocks
//    5 * are all linked to the anchor using a single chained list. Thus each block has a next
//    6 * pointer. The user of the functions in this module never has to be concerned with the
//    7 * list overhead since this is handled transparently. The block pointer which the user
//    8 * receives when allocating memory is pointing to the address after the next-pointer.
//    9 *
//   10 * FIFO Queues are implemented using the same list functions as used by the memory
//   11 * (de)allocation functions. The queue data object is simply an anchor (anchor_t).
//   12 * List_AddTail is used for putting allocated blocks on the queue, and List_RemoveHead
//   13 * will detach the block from the queue. Before using a queue anchor it must have been
//   14 * initialized with List_ClearAnchor. No extra header is required in order to put a
//   15 * block in a queue. However, messages should contain type information beside the
//   16 * message data so that the message handler at the receiver can reckognize the message.
//   17 *
//   18 * Messages are sent by allocating a block using MSG_Alloc, and using the MSG_Send macro
//   19 * to call the Service Access Point (SAP) of the receiver. If the SAP handles specific
//   20 * messages synchronously (returns with result immideately) then the block may be
//   21 * allocated on the stack of the calling function. The message types which allows this
//   22 * are specified in the design documents.
//   23 *
//   24 * Copyright (c) 2007, Freescale, Inc. All rights reserved.
//   25 *
//   26 *
//   27 * No part of this document must be reproduced in any form - including copied,
//   28 * transcribed, printed or by any electronic means - without specific written
//   29 * permission from Freescale Semiconductor.
//   30 *
//   31 *****************************************************************************/
//   32 
//   33 #include "MsgSystem.h"
//   34 
//   35 /* Implemented in getSP.s*/
//   36 uint32_t getSP();
//   37 /************************************************************************************
//   38 *************************************************************************************
//   39 * Private memory declarations
//   40 *************************************************************************************
//   41 ************************************************************************************/
//   42 
//   43   // The heap for MAC, NWK and application memory blocks.

        SECTION `.bss`:DATA:NOROOT(2)
//   44 uint8_t maMacHeap[mMmTotalPoolSize_c];
maMacHeap:
        DS8 1120
//   45 
//   46   // Memory pool info and anchors.

        SECTION `.bss`:DATA:NOROOT(2)
//   47 pools_t maMmPools[gMmNumPools_c];
maMmPools:
        DS8 36
//   48 
//   49   // Const array used during initialization. Describes the memory layout.
//   50   // Pools must occur in the table in ascending order according to their size.
//   51   // If coordinator capability is required, then there must always exist an
//   52   // extra MAC pool for receiving data frames. This pool is private to the MAC.
//   53   // An example of a memory layout for coordinators/routers:
//   54   // Pool3]:
//   55   //   SmallMessages[M], // Command messages of each ~22 bytes
//   56   //   BigMessages[N-1], // Data messages of each ~134 bytes
//   57   //   BigMessages[1],   // One data message of ~134 bytes, MAC private.
//   58   // MSG_Alloc ensures that only the MAC has access to the private pool.
//   59 
//   60   // An example of a memory layout for devices:
//   61   // Pool2]:
//   62   //   SmallMessages[M], // Command messages of each ~22 bytes
//   63   //   BigMessages[N],   // Data messages of each ~134 bytes
//   64   //

        SECTION `.data`:DATA:NOROOT(2)
//   65 poolInfo_t poolInfo[gMmNumPools_c] = {
poolInfo:
        DATA
        DC8 5, 24, 152, 0, 5, 152, 152, 0, 1, 152, 0, 0
//   66   gMmPoolSize0_c, mMmBlockSize0_c, mMmBlockSize1_c, 0,
//   67 #if gMmNumPools_c > 1
//   68   gMmPoolSize1_c, mMmBlockSize1_c, mMmBlockSize2_c, 0,
//   69 #if gMmNumPools_c > 2
//   70   gMmPoolSize2_c, mMmBlockSize2_c, 0, 0,
//   71 #if gMmNumPools_c > 3
//   72   gMmPoolSize3_c, mMmBlockSize3_c, 0, 0
//   73 #endif // gMmNumPools_c > 3
//   74 #endif // gMmNumPools_c > 2
//   75 #endif // gMmNumPools_c > 1
//   76 };
//   77 

        SECTION `.data`:DATA:NOROOT(2)
//   78 pools_t *pLastPool = &maMmPools[mMmLastPoolIdx_c];
pLastPool:
        DATA
        DC32 maMmPools + 18H
//   79 #if gBigMsgsMacOnly_d

        SECTION `.data`:DATA:NOROOT(2)
//   80   pools_t *pSecondLastPool = &maMmPools[mMmLastPoolIdx_c-1];
pSecondLastPool:
        DATA
        DC32 maMmPools + 0CH
//   81 #endif
//   82 
//   83 #ifndef gMAC2006_d
//   84   // Application allocated space for MAC PIB ACL Entry descriptors.
//   85 #if gNumAclEntryDescriptors_c > 0

        SECTION `.bss`:DATA:NOROOT(2)
//   86   aclEntryDescriptor_t gPIBaclEntryDescriptorSet[gNumAclEntryDescriptors_c];
gPIBaclEntryDescriptorSet:
        DS8 160
//   87 
//   88     // Set number of ACL entries. Used by the MAC.

        SECTION `.data`:DATA:NOROOT(0)
//   89   uint8_t gNumAclEntryDescriptors = gNumAclEntryDescriptors_c;
gNumAclEntryDescriptors:
        DATA
        DC8 4
//   90   #endif // gNumAclEntryDescriptors_c
//   91 #else
//   92   
//   93   #if gNumKeyTableEntries_c > 0
//   94     KeyDescriptor_t gPIBKeyTable[gNumKeyTableEntries_c];
//   95     const uint8_t gNumKeyTableEntries = gNumKeyTableEntries_c;
//   96     
//   97     /* Allocate KeyIdLookupDescriptor_t, KeyDeviceDescriptor_t, KeyUsageDescriptor_t */ 
//   98     /* These arrays are part of KeyDescriptor_t structure */
//   99     /* Allocate a continuous space for each array based on the gNumKeyTableEntries_c */
//  100     /* The MAC PIB will initialize the pointers accordingly */
//  101     
//  102     #if gNumKeyIdLookupEntries_c > 0
//  103        KeyIdLookupDescriptor_t gPIBKeyIdLookupDescriptorTable[gNumKeyIdLookupEntries_c * gNumKeyTableEntries_c];
//  104        const uint8_t gNumKeyIdLookupEntries = gNumKeyIdLookupEntries_c; /* The number of elements in each virtual array inside the gPIBKeyIdLookupDescriptorTable */
//  105     #endif //gNumKeyIdLookupEntries_c
//  106     
//  107     #if gNumKeyDeviceListEntries_c > 0
//  108        KeyDeviceDescriptor_t  gPIBKeyDeviceDescriptorTable[gNumKeyDeviceListEntries_c * gNumKeyTableEntries_c];
//  109        const uint8_t gNumKeyDeviceListEntries = gNumKeyDeviceListEntries_c; /* The number of elements for each virtual array inside the gPIBKeyDeviceDescriptorTable */
//  110     #endif //gNumKeyDeviceListEntries_c
//  111     
//  112     #if gNumKeyUsageListEntries_c > 0
//  113        KeyUsageDescriptor_t  gPIBKeyUsageDescriptorTable[gNumKeyUsageListEntries_c * gNumKeyTableEntries_c];
//  114        const uint8_t gNumKeyUsageListEntries = gNumKeyUsageListEntries_c; /* The number of elements for each virtual array inside the gPIBKeyDeviceDescriptorTable */
//  115     #endif //gNumKeyUsageListEntries_c
//  116   #endif //gNumKeyTableEntries_c
//  117   
//  118   #if gNumDeviceTableEntries_c > 0
//  119     DeviceDescriptor_t gPIBDeviceTable[gNumDeviceTableEntries_c];
//  120     const uint8_t gNumDeviceTableEntries = gNumDeviceTableEntries_c;    
//  121   #endif //gNumDeviceTableEntries_c
//  122 
//  123   #if gNumSecurityLevelTableEntries_c > 0
//  124     SecurityLevelDescriptor_t gPIBSecurityLevelTable[gNumSecurityLevelTableEntries_c];
//  125     const uint8_t gNumSecurityLevelTableEntries = gNumSecurityLevelTableEntries_c;    
//  126   #endif //gNumKeyTableEntries_d
//  127 
//  128 
//  129 #endif  //gMAC2006_d
//  130 #if MsgTracking_d

        SECTION `.rodata`:CONST:NOROOT(0)
//  131 const uint8_t TotalNoOfMsgs_c = (gTotalBigMsgs_d + gTotalSmallMsgs_d);
TotalNoOfMsgs_c:
        DATA
        DC8 11
//  132 

        SECTION `.bss`:DATA:NOROOT(2)
//  133 MsgTracking_t MsgTrackingArray[(gTotalBigMsgs_d + gTotalSmallMsgs_d)] = 0;
MsgTrackingArray:
        DS8 188

        SECTION `.bss`:DATA:NOROOT(0)
//  134 uint8_t NoOfWrongAddrs = 0;
NoOfWrongAddrs:
        DS8 1
//  135 
//  136 extern uint32_t MM_GetLinkRegister(void);
//  137 
//  138 #endif
//  139 
//  140 /************************************************************************************
//  141 *************************************************************************************
//  142 * Private prototypes
//  143 *************************************************************************************
//  144 ************************************************************************************/
//  145 
//  146 /************************************************************************************
//  147 *************************************************************************************
//  148 * Public functions
//  149 *************************************************************************************
//  150 ************************************************************************************/
//  151 /************************************************************************************
//  152 * Initialize Msg tracking array. It is called by the Msg system when the MAC is reset
//  153 *
//  154 * Interface assumptions:
//  155 *   None
//  156 *   
//  157 * Return value:
//  158 *   None.
//  159 * 
//  160 ************************************************************************************/
//  161 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  162 void MM_InitMsgTracking(void) {
MM_InitMsgTracking:
        PUSH     {R7,LR}
//  163 #if MsgTracking_d
//  164    FLib_MemSet((uint8_t* )&MsgTrackingArray[0],0,(sizeof(MsgTracking_t)/sizeof(uint8_t)) * TotalNoOfMsgs_c);
        LDR      R0,??DataTable3
        LDRB     R2,[R0, #+0]
        MOVS     R0,#+17
        MULS     R2,R0,R2
        LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
        LSRS     R2,R2,#+16
        MOVS     R1,#+0
        LDR      R0,??DataTable3_1
        BL       FLib_MemSet
//  165    NoOfWrongAddrs = 0;
        LDR      R0,??DataTable3_2
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  166 #endif   
//  167 }
        POP      {R0,R3}
        BX       R3               ;; return
//  168 /************************************************************************************
//  169 * Initialize Msg tracking array a current index with a Msg address.
//  170 * This functions is called for once for every Msg when the MAC is reset.
//  171 *
//  172 * Interface assumptions:
//  173 *   None
//  174 *   
//  175 * Return value:
//  176 *   None.
//  177 * 
//  178 ************************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  179 void   MM_AddMsgToTrackingArray(uint8_t Index, uint32_t Addr) {
MM_AddMsgToTrackingArray:
        PUSH     {R4,R5,LR}
        MOVS     R4,R0
        MOVS     R5,R1
//  180 #if MsgTracking_d
//  181       MsgTrackingArray[Index].MsgAddr = Addr;  
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+17
        MULS     R0,R4,R0
        LDR      R1,??DataTable3_1
        ADDS     R1,R1,R0
        MOVS     R0,R5
        BL       __aeabi_uwrite4
//  182 #else
//  183   /*To prevent compiler warinngs:*/
//  184   (void) Index;
//  185   (void) Addr;  
//  186 #endif      
//  187 }
        POP      {R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  188 /************************************************************************************
//  189 * This function finds the index of a Msg in the Tracking array
//  190 * -1 is returned if Msg not found and the NoOfWrongAddrs is incremented.
//  191 *
//  192 * Interface assumptions:
//  193 *   None
//  194 *   
//  195 * Return value:
//  196 *   Index of message in tracking array
//  197 * 
//  198 ************************************************************************************/  

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  199 int8_t MM_GetMsgIndex(const uint32_t MsgAddr)
//  200 {
MM_GetMsgIndex:
        PUSH     {R4,R5,LR}
        MOVS     R4,R0
//  201 #if MsgTracking_d
//  202   uint8_t i;    
//  203   /*Search through the Tracking array*/ 
//  204   for (i = 0; i < TotalNoOfMsgs_c; i++) 
        MOVS     R0,#+0
        MOVS     R5,R0
??MM_GetMsgIndex_0:
        LDR      R0,??DataTable3
        LDRB     R0,[R0, #+0]
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,R0
        BCS      ??MM_GetMsgIndex_1
//  205   {      
//  206     /*If Msg Addr found then exit with Index*/
//  207     if (MsgAddr == MsgTrackingArray[i].MsgAddr)
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+17
        MULS     R0,R5,R0
        LDR      R1,??DataTable3_1
        ADDS     R0,R1,R0
        BL       __aeabi_uread4
        CMP      R4,R0
        BNE      ??MM_GetMsgIndex_2
//  208       return i;
        MOVS     R0,R5
        LSLS     R0,R0,#+24       ;; SignExtS R0,R0,#+24,#+24
        ASRS     R0,R0,#+24
        B        ??MM_GetMsgIndex_3
//  209   }
??MM_GetMsgIndex_2:
        ADDS     R5,R5,#+1
        B        ??MM_GetMsgIndex_0
//  210   /*Msg addr not found, increment error counter and return*/  
//  211   NoOfWrongAddrs++;
??MM_GetMsgIndex_1:
        LDR      R0,??DataTable3_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable3_2
        STRB     R0,[R1, #+0]
//  212   return -1;
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
??MM_GetMsgIndex_3:
        POP      {R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  213 #else  
//  214   /*To prevent compiler warinngs:*/
//  215  (void) MsgAddr;
//  216  return -1;
//  217 #endif 
//  218 }
//  219 
//  220 /************************************************************************************
//  221 * This function is called when ever a Msg is freed or allocated and updates
//  222 * the tracking information for that particular Msg
//  223 * 
//  224 *
//  225 * Interface assumptions:
//  226 *   None
//  227 *   
//  228 * Return value:
//  229 *   Success status
//  230 * 
//  231 ************************************************************************************/  

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  232 bool_t MM_UpdateMsgTracking(const void *pBlock, const bool_t Alloc)
//  233 {
MM_UpdateMsgTracking:
        PUSH     {R4-R6,LR}
        MOVS     R6,R0
        MOVS     R5,R1
//  234 #if MsgTracking_d
//  235   int8_t index = MM_GetMsgIndex((uint32_t)pBlock);
        MOVS     R0,R6
        BL       MM_GetMsgIndex
        MOVS     R4,R0
//  236   if (index >= 0)
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        CMP      R4,#+0
        BMI      ??MM_UpdateMsgTracking_0
//  237   {          
//  238     
//  239     if (MsgTrackingArray[index].AllocStatus == Alloc)
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R0,#+17
        MULS     R0,R4,R0
        LDR      R1,??DataTable3_1
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+16]
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R0,R5
        BNE      ??MM_UpdateMsgTracking_1
//  240     {      
//  241      return FALSE;
        MOVS     R0,#+0
        B        ??MM_UpdateMsgTracking_2
//  242     } 
//  243         
//  244     MsgTrackingArray[index].AllocStatus = Alloc;
??MM_UpdateMsgTracking_1:
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R0,#+17
        MULS     R0,R4,R0
        LDR      R1,??DataTable3_1
        ADDS     R0,R1,R0
        STRB     R5,[R0, #+16]
//  245  
//  246     /*Update MsgTracking array counters and return address of alloc or free */  
//  247     if (Alloc) {
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BEQ      ??MM_UpdateMsgTracking_3
//  248       MsgTrackingArray[index].AllocCounter++;
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R0,#+17
        MULS     R0,R4,R0
        LDR      R1,??DataTable3_1
        ADDS     R1,R1,R0
        LDRB     R0,[R1, #+12]
        LDRB     R2,[R1, #+13]
        LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+16
        LSRS     R2,R2,#+16
        ORRS     R0,R0,R2
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R1,#+17
        MULS     R1,R4,R1
        LDR      R2,??DataTable3_1
        ADDS     R1,R2,R1
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+12]
        LSRS     R0,R0,#+8
        STRB     R0,[R1, #+13]
//  249       MsgTrackingArray[index].AllocAddr = MM_GetLinkRegister();
        BL       MM_GetLinkRegister
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R1,#+17
        MULS     R1,R4,R1
        LDR      R2,??DataTable3_1
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+4
        BL       __aeabi_uwrite4
        B        ??MM_UpdateMsgTracking_4
//  250     }
//  251     else {
//  252       MsgTrackingArray[index].FreeCounter++;        
??MM_UpdateMsgTracking_3:
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R0,#+17
        MULS     R0,R4,R0
        LDR      R1,??DataTable3_1
        ADDS     R1,R1,R0
        LDRB     R0,[R1, #+14]
        LDRB     R2,[R1, #+15]
        LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+16
        LSRS     R2,R2,#+16
        ORRS     R0,R0,R2
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R1,#+17
        MULS     R1,R4,R1
        LDR      R2,??DataTable3_1
        ADDS     R1,R2,R1
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+14]
        LSRS     R0,R0,#+8
        STRB     R0,[R1, #+15]
//  253       MsgTrackingArray[index].FreeAddr = MM_GetLinkRegister();
        BL       MM_GetLinkRegister
        LSLS     R4,R4,#+24       ;; SignExtS R4,R4,#+24,#+24
        ASRS     R4,R4,#+24
        MOVS     R1,#+17
        MULS     R1,R4,R1
        LDR      R2,??DataTable3_1
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+8
        BL       __aeabi_uwrite4
//  254     }
//  255     return TRUE;
??MM_UpdateMsgTracking_4:
        MOVS     R0,#+1
        B        ??MM_UpdateMsgTracking_2
//  256       
//  257   }      
//  258   else  
//  259     return FALSE;
??MM_UpdateMsgTracking_0:
        MOVS     R0,#+0
??MM_UpdateMsgTracking_2:
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
//  260 #else
//  261   /*To prevent compiler warinngs:*/
//  262   (void) pBlock;
//  263   (void) Alloc;  
//  264   return TRUE;
//  265 #endif  
//  266 }

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3:
        DC32     TotalNoOfMsgs_c

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_1:
        DC32     MsgTrackingArray

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable3_2:
        DC32     NoOfWrongAddrs

        END
//  267 
// 
// 1 505 bytes in section .bss
//    21 bytes in section .data
//     1 byte  in section .rodata
//   358 bytes in section .text
// 
//   358 bytes of CODE  memory
//     1 byte  of CONST memory
// 1 526 bytes of DATA  memory
//
//Errors: none
//Warnings: none
