###############################################################################
#                                                                             #
#                                                       15/Oct/2012  16:29:14 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\ZTC\Source\ZtcCopyData.c               #
#    Command line =  "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\ZTC\Source\ZtcCopyData.c" -D           #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xNCB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\" -lC "C:\Documents and         #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\List\" -lB "C:\Documents and         #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\List\" --diag_suppress               #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\Obj\" --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\MacPhy\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Application\Init\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Application\Interface\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\Application\Configure\" -I          #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\UartUtil\" -I "C:\Documents    #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\Application\Source\" -I             #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\TS\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\TS\Source\" -I "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\ZTC\Interface\" -I "C:\Documents and   #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\ZTC\Source\" -I "C:\Documents and      #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Interface\" -I "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\LibInterface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Source\Display\" -I "C:\Documents and  #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Source\Keyboard\" -I "C:\Documents     #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\NVM\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\TMR\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\UART\" -I "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\ZtcCopyData.lst                 #
#    Object file  =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\Obj\ZtcCopyData.o                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\My Documents\MyWirelessApp Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon (Coordinator)\SSM\ZTC\Source\ZtcCopyData.c
      1          /******************************************************************************
      2          * ZTC data format conversion routines.
      3          *
      4          * Copyright (c) 2008, Freescale, Inc.  All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          * Ztc needs to copy external packet client to/from SAP Handler message data.
     12          * The sometimes the formats are just a length + data (simple format), but
     13          * sometimes they are more complicated, involving variable length arrays
     14          * and/or pointers to data.
     15          *
     16          * *warning* In general, no effort is made to verify the correctness or
     17          * internal consistency of the data.
     18          ******************************************************************************/
     19          
     20          #include "EmbeddedTypes.h"
     21          #if gBeeStackIncluded_d
     22          #include "ZigBee.h"
     23          #include "BeeStackFunctionality.h"
     24          #include "BeeStackConfiguration.h"
     25          #endif
     26          
     27          #include "ZtcInterface.h"
     28          
     29          #if gZtcIncluded_d
     30          
     31          #if gBeeStackIncluded_d
     32          #include "BeeCommon.h"
     33          #endif
     34          #include "MsgSystem.h"
     35          #include "FunctionLib.h"
     36          #include "FunctionalityDefines.h"
     37          #include "PublicConst.h"
     38          
     39          #include "AppAspInterface.h"
     40          #if gBeeStackIncluded_d
     41          #include "AppZdoInterface.h"
     42          #include "ZdoNwkInterface.h"
     43          #include "ZdoApsInterface.h"
     44          #include "AfApsInterface.h"
     45          #include "NwkCommon.h"
     46          #endif
     47          
     48          #include "AspZtc.h"
     49          #include "LlcZtc.h"
     50          
     51          #include "ZtcPrivate.h"
     52          #include "ZtcClientCommunication.h"
     53          #include "ZtcMsgTypeInfo.h"
     54          #include "ZtcSAPHandlerInfo.h"
     55          #include "ZtcMacPIB.h"
     56          #include "ZtcCopyData.h"
     57          
     58          /******************************************************************************
     59          *******************************************************************************
     60          * Private macros
     61          *******************************************************************************
     62          ******************************************************************************/
     63          /* 26 channels bit mapped into 32 bits,ie 4 Bytes(0-3) */
     64          #define ByteOffset              0x03
     65          /* mask everything except 3rd */
     66          #define MaskAllExceptThirdByte  0x04
     67          #define ShiftRightByOne         0x01
     68          
     69          /******************************************************************************
     70          *******************************************************************************
     71          * Private type definitions
     72          *******************************************************************************
     73          ******************************************************************************/
     74          
     75          /******************************************************************************
     76          *******************************************************************************
     77          * Private memory declarations
     78          *******************************************************************************
     79          ******************************************************************************/
     80          #if gBeeStackIncluded_d
     81          
     82          /* Define the table used by the header-and-data data format. */
     83          #define FmtHdrAndData(name, hdrLen, offsetToCount, itemLen) \
     84            {hdrLen, offsetToCount, itemLen},
     85          
     86          ztcFmtHdrAndData_t const maZtcFmtHdrAndDataTable[] = {
     87          #include "ZtcCopyDataTbl.h"
     88          };
     89          #endif /* gBeeStackIncluded_d */
     90          
     91          #if gSAPMessagesEnableMlme_d || gSAPMessagesEnableNlme_d
     92          static uint8_t maScanChannels[ 4 ];    /* Buffer to hold Scanned Channels */
     93          #endif
     94          
     95          /****************************************************************************/
     96          
     97          /* Tables related to the length-code-and-pointer data format.
     98           *
     99           * Each entry in the main table for this format contains a pointer
    100           * to a subtable that specifies the data lengths associated with
    101           * particular values of the length code field.
    102           */
    103          
    104          /* Used for MacSetPIBAttribute.Request (85 09), aka MLME-SET.request, */
    105          /*      and MacGetPIBAttribute.Confirm (84 05), aka MLME-GET.confirm. */
    106          #if mZtcLenCodeAndPtrFormat_d
    107          #define CodeAndLenMacSetReq(index, len) \
    108            {index, len},
    109          ztcCodeAndLen_t const maZtcMacSetDataLengthsTable[] = {
    110          #include "ZtcCopyDataTbl.h"
    111          };
    112          
    113          #define FmtLenCodeAndPtr(name, hdrLen, offsetToPtr, offsetToCount, \
    114                                   offsetToLenCode, tableOfDataLengths, offsetToMsgData) \
    115            {hdrLen, offsetToPtr, offsetToCount, offsetToLenCode, tableOfDataLengths, \
    116             NumberOfElements(tableOfDataLengths), offsetToMsgData},
    117          
    118          ztcFmtLenCodeAndPtr_t const maZtcFmtLenCodeAndPtrTable[] = {
    119          #include "ZtcCopyDataTbl.h"
    120          };
    121          #endif                                  /* #if mZtcLenCodeAndPtrFormat_d */
    122          
    123          /****************************************************************************/
    124          
    125          /* Define the table for the two-array-pointers data format. */
    126          #define FmtTwoArrayPtrs(name, hdrLen, \
    127                                  offsetToPtr1, offsetToCount1, array1ElementLen, \
    128                                  offsetToMsgData,                                \
    129                                  offsetToPtr2, offsetToCount2, array2ElementLen) \
    130            {hdrLen, \
    131             offsetToPtr1, offsetToCount1, array1ElementLen, offsetToMsgData, \
    132             offsetToPtr2, offsetToCount2, array2ElementLen},
    133          
    134          ztcFmtTwoArrayPtrs_t const maZtcFmtTwoArrayPtrsTable[] = {
    135          #include "ZtcCopyDataTbl.h"
    136          };
    137          
    138          /****************************************************************************/
    139          
    140          /* Instead of pointers to functions, the main format table saves space by */
    141          /* storing indexes into tables of functions. Declare the indexes. */
    142          #define PktFromMsgFunction(index, pFunction)  pFunction,
    143          pZtcMsgFromPkt_t const maPktFromMsgFunctionTable [] = {
    144          #include "ZtcCopyDataTbl.h"
    145          };
    146          
    147          #define MsgFromPktFunction(index, pFunction)  pFunction,
    148          pZtcMsgFromPkt_t const maMsgFromPktFunctionTable[] = {
    149          #include "ZtcCopyDataTbl.h"
    150          };
    151          
    152          /****************************************************************************/
    153          
    154          /* Define the main data format table.
    155           *
    156           * Each entry in the main message type info table contains an index to this
    157           *table.
    158           *
    159           * Each entry in this table contains the pointers-to-functions and indexes-to-
    160           * parameter tables used by one format.
    161           */
    162          #define Fmt(name, pktFromMsgFuncIndex, pktFromMsgParamIndex, \
    163                      msgFromPktFuncIndex, msgFromPktParamIndex)             \
    164            {ZtcSetFmtFuncIndexes(pktFromMsgFuncIndex, msgFromPktFuncIndex), \
    165             pktFromMsgParamIndex, msgFromPktParamIndex},
    166          ztcFmtInfo_t const maZtcFmtInfoTable[] = {
    167          #include "ZtcCopyDataTbl.h"
    168          };
    169          
    170          /******************************************************************************
    171          *******************************************************************************
    172          * Public functions
    173          *******************************************************************************
    174          ******************************************************************************/
    175          
    176          /* The source packet consists of a fixed length header followed immediately
    177           * by a variable number of fixed size data items. The header contains a field
    178           * that specifies the number of items.
    179           * Copy the source header + data to the destination unchanged.
    180           *
    181           * Source packet:
    182           *  | H | D |
    183           *    ^   ^
    184           *    |   +-- Variable length data.
    185           *    +------ Header, including:
    186           *                a field specifying the length (in bytes) of the data.
    187           *
    188           * Destination message:
    189           *  Same as source.
    190           */
    191          #if gBeeStackIncluded_d
    192          
    193          index_t ZtcMsgFromPktHdrAndData
    194            (
    195            uint8_t *pMsg,
    196            index_t msgLen,
    197            uint8_t *pPkt,
    198            index_t pktLen,
    199            index_t fmtParametersIndex
    200            )
    201          {
    202            ztcFmtHdrAndData_t const *pFmtInfo;
    203            index_t totalDstLen;                  /* Risky on 8 bit CPUs. */
    204          
    205            (void) pktLen;
    206          
    207            /* Note that the information in maZtcFmtTwoArrayPtrsTable[] describes */
    208            /* the message header. The layout of the packet header must be inferred. */
    209            pFmtInfo = &(maZtcFmtHdrAndDataTable[fmtParametersIndex]);
    210            totalDstLen = pFmtInfo->hdrLen
    211                          + (pPkt[pFmtInfo->offsetToCount] * pFmtInfo->itemLen);
    212          
    213            if (totalDstLen > msgLen) {
    214              return gTooBig_c;
    215            }
    216          
    217            FLib_MemCpy(pMsg, (void *) pPkt, totalDstLen);
    218            return totalDstLen;
    219          }                                       /* ZtcMsgFromPktHdrAndData() */
    220          
    221          #endif /* gBeeStackIncluded_d */
    222          /****************************************************************************/
    223          
    224          /* The packet contains a header and some number of fixed length array elements.
    225           * The length of the array elements is specified indirectly by a length code
    226           * in the packet header.
    227           *
    228           * There are some messages that use the length code approach, but that have
    229           * either a simgle data value instead of an array, and/or that have no pointer
    230           * (the data is immediately after the header). The secondary format table,
    231           * maZtcFmtLenCodeAndPtrTable[], may contain special values (-1) for the
    232           * offset-to-number-of-elements and/or offset-to-pointer fields to indicate
    233           * these exceptions.
    234           *
    235           * Copy the packet header to the message header. Look up the length code
    236           * in the code-and-lengths table. Copy the data from the packet to the
    237           * message, at the message offset specified by offsetToMsgData. Store a
    238           * pointer to the data at the offsetToPtr offset in the message header.
    239           *
    240           * Source packet:
    241           *  | F | A | L |
    242           *    ^   ^   ^
    243           *    |   |   +-- Last part of header.
    244           *    |   +------ Variable length array.
    245           *    +---------- First part of header, including:
    246           *                a length code field, and
    247           *                a count of the number of elements in the array.
    248           *
    249           * Destination message:
    250           *  | F | P | L | G | A |
    251           *    ^   ^   ^   ^
    252           *    |   |   |   |   +-- Variable length array.
    253           *    |   |   |   +------ Gap between pointer and data. May be any length.
    254           *    |   |   +---------- Last part of header.
    255           *    |   +-------------- Pointer to "A".
    256           *    +------------------ First part of header.
    257           */
    258          #if mZtcLenCodeAndPtrFormat_d
    259          index_t ZtcMsgFromPktLenCodeAndPtr
    260            (
    261            uint8_t *pMsg,
    262            index_t msgLen,
    263            uint8_t *pPkt,
    264            index_t pktLen,
    265            index_t fmtParametersIndex
    266            )
    267          {
    268            index_t arrayLen;                     /* Risky on an 8 bit CPU. */
    269            index_t code;
    270            index_t elementLen;
    271            ztcFmtLenCodeAndPtr_t fmtInfo;
    272            index_t hdrTotalLen;
    273            index_t hdrFirstPartLen;
    274            index_t i;
    275            index_t numberOfArrayElements;
    276            index_t offsetToCount;
    277            index_t offsetToMsgArray;
    278            ztcCodeAndLen_t const *pCodeAndLenTable;
    279            index_t totalDstLen;                  /* Risky on an 8 bit CPU. */
    280            uint32_t auxArrayAddress;
    281            
    282            (void) pktLen;
    283            
    284          
    285            /* Note that the information in maZtcFmtLenCodeAndPtrTable[] describes */
    286            /* the message header. The layout of the packet header must be inferred. */
    287            FLib_MemCpy(&fmtInfo,
    288                        (void *) &(maZtcFmtLenCodeAndPtrTable[fmtParametersIndex]),
    289                        sizeof(fmtInfo));
    290          
    291            pCodeAndLenTable = fmtInfo.pCodeAndLenTable;
    292            code = pPkt[fmtInfo.offsetToLenCode];
    293            for (elementLen = (index_t) gMinusOne_c, i = 0; i < fmtInfo.codeAndLenTableLen; i++) {
    294              if (code == pCodeAndLenTable[i].code) {
    295                elementLen = pCodeAndLenTable[i].len;
    296              }
    297            }
    298          
    299            /* If the number of elements entry in the secondary format table is -1, */
    300            /* this format actually only has one array element, not a variable number */
    301            /* of them. */
    302            offsetToCount = fmtInfo.offsetToCount;
    303            numberOfArrayElements = 1;
    304            if (offsetToCount != (index_t) gMinusOne_c) {
    305              numberOfArrayElements = pPkt[offsetToCount];
    306            }
    307          
    308            offsetToMsgArray = fmtInfo.offsetToMsgData;
    309            arrayLen = elementLen * numberOfArrayElements;
    310            totalDstLen = offsetToMsgArray + arrayLen;
    311          
    312            if (elementLen == (index_t) gMinusOne_c) {
    313              ZtcError(gZtcUnknownPIB_c);
    314              return gTooBig_c;
    315            }
    316          
    317            if (totalDstLen > msgLen) {
    318              return gTooBig_c;
    319            }
    320          
    321            hdrTotalLen = fmtInfo.hdrLen;
    322            hdrFirstPartLen = fmtInfo.offsetToPtr;
    323          
    324            if (hdrFirstPartLen == (index_t) gMinusOne_c) {
    325              /* The header does not contain a pointer. */
    326              hdrFirstPartLen = hdrTotalLen;
    327            } else {
    328              /* Write the pointer. */
    329              /*  *((uint8_t **)(pMsg + hdrFirstPartLen)) = pMsg + offsetToMsgArray; */
    330              
    331              auxArrayAddress = (uint32_t)(pMsg + offsetToMsgArray);
    332              FLib_MemCpy(pMsg + hdrFirstPartLen, &auxArrayAddress, sizeofPointer);
    333              
    334              /* Copy the second part of the header. */
    335              FLib_MemCpy(pMsg + hdrFirstPartLen + sizeofPointer,
    336                          (void *) (pPkt + hdrFirstPartLen),
    337                          hdrTotalLen - hdrFirstPartLen - sizeofPointer);
    338            }                                     /* if (hdrFirstPartLen == ... */
    339          
    340            /* Copy the first part of the header, not including the pointer. */
    341            FLib_MemCpy(pMsg, (void *) pPkt, hdrFirstPartLen);
    342          
    343            /* Copy the array. */
    344            FLib_MemCpy(pMsg + offsetToMsgArray,
    345                        (void *) (pPkt + hdrFirstPartLen),
    346                        (index_t) arrayLen);
    347          
    348            return totalDstLen;
    349          }                                       /* ZtcMsgFromLenCodeAndPtr() */
    350          #endif                                  /* #if mZtcLenCodeAndPtrFormat_d */
    351          
    352          /****************************************************************************/
    353          
    354          /* Placeholder function to fill in the Fmt() table slot for message formats
    355           * that don't require message-from-packet copying.
    356           */
    357          index_t ZtcMsgFromPktUnused
    358            (
    359            uint8_t *pMsg,
    360            index_t msgLen,
    361            uint8_t *pPkt,
    362            index_t pktLen,
    363            index_t fmtParametersIndex
    364            )
    365          {
    366            /* Keep the compiler happy. */
    367            (void) pMsg;
    368            (void) msgLen;
    369            (void) pPkt;
    370            (void) pktLen;
    371            (void) fmtParametersIndex;
    372          
    373            return gTooBig_c;
    374          }                                       /* ZtcMsgFromPktUnused() */
    375          
    376          /****************************************************************************/
    377          
    378          /* The message consists of a header that contains two pointers to arrays.
    379           * Each array is described by a pointer to the data, plus a count of the
    380           * number of elements in the array. The sizes of the elements in each array
    381           * are constant, but the size of the elements of the first array is is
    382           * generally different than the size of the elements of the second array.
    383           *
    384           * The header has a first part (before the first array pointer), a second
    385           * part (between the first and second array pointers), and a third part
    386           * (after the second array pointer).
    387           *
    388           * This format is also used if there is only one array and pointer, instead
    389           * of two.
    390           *
    391           * The packet format is similar to the message, but the pointers are replaced
    392           * by the data of the arrays.
    393           *
    394           * Copy the data to a fixed offset relative to the beginning of the message
    395           * (at ztcFmtPtrToArray_t.offsetToMsgData). Copy the struct from the packet
    396           * to the message, inserting the pointers to the destination arrays at the
    397           * needed places.
    398           *
    399           * *warning* The number-of-elements fields *must* occur earlier in the
    400           * header than the corresponding pointers.
    401           *
    402           * The source packet looks like:
    403           *
    404           *  | F | 1 | M | 2 | L |
    405           *    ^   ^   ^   ^   ^
    406           *    :   :   :   :   +---- Third part of header.
    407           *    :   :   :   +-------- Contents of second array.
    408           *    :   :   +------------ Second part of header.
    409           *    :   +---------------- Contents of first array.
    410           *    +-------------------- First part of header.
    411           *
    412           * The field that specifies the number of element in the first array
    413           * must be in the first part of the header.
    414           * The field that specifies the number of elements in the second array
    415           * may be in either the first or second parts of the header.
    416           *
    417           * The destination message looks like:
    418           *
    419           *  | F | P | M | Q | L | G | 1 | 2 |
    420           *    ^   ^   ^   ^   ^   ^   ^   ^
    421           *    :   :   :   :   :   :   :   +---- Second array data.
    422           *    :   :   :   :   :   :   +-------- First array data.
    423           *    :   :   :   :   :   +------------ Gap.
    424           *    :   :   :   :   +---------------- Third part of header.
    425           *    :   :   :   +-------------------- Pointer to second array.
    426           *    :   :   +------------------------ Second part of header.
    427           *    :   +---------------------------- Pointer to first array.
    428           *    +-------------------------------- First part of header.
    429           *
    430           */
    431          index_t ZtcMsgFromPktTwoArrayPtrs
    432            (
    433            uint8_t *pMsg,                        /* Pointer to message payload. */
    434            index_t msgLen,                       /* Length  of message payload. */
    435            uint8_t *pPkt,                        /* Pointer to packet  payload. */
    436            index_t pktLen,                       /* Length  of packet  payload. */
    437            index_t fmtParametersIndex
    438            )
    439          {
    440            ztcFmtTwoArrayPtrs_t fmtInfo;
    441          
    442            /* The first, second, and third parts of the message and packet headers */
    443            /* are identical. The arrays are identical, although they are at different */
    444            /* offsets in the message and packet formats. */
    445            index_t hdrFirstPartLen;
    446            index_t hdrSecondPartLen;
    447            index_t hdrThirdPartLen;
    448            index_t array1Len;
    449            index_t array2Len;
    450          
    451            index_t offsetToMsgHdrSecondPart;
    452            index_t offsetToMsgHdrThirdPart;
    453            index_t offsetToMsgArray1;
    454            index_t offsetToMsgArray2;
    455          
    456            index_t offsetToMsgPtr2;
    457          
    458            index_t offsetToPktNumberOfArray2Elements;
    459          
    460            index_t offsetToPktHdrSecondPart;
    461            index_t offsetToPktHdrThirdPart;
    462            index_t offsetToPktArray2;
    463          
    464            index_t totalDstLen;
    465            uint32_t auxArrayAddress;
    466          
    467            (void) pktLen;
    468          
    469            /* Note that the information in maZtcFmtTwoArrayPtrsTable[] describes */
    470            /* the message header. The layout of the packet header must be inferred. */
    471            FLib_MemCpy(&fmtInfo,
    472                        (void *) &(maZtcFmtTwoArrayPtrsTable[fmtParametersIndex]),
    473                        sizeof(fmtInfo));
    474          
    475            hdrFirstPartLen = fmtInfo.offsetToPtr1;
    476          
    477            array1Len = pPkt[fmtInfo.offsetToNumberOfArray1Elements]
    478                        * fmtInfo.sizeofArray1Element;
    479          
    480            /* In the message header, the second part of the header begins after the */
    481            /* first pointer. */
    482            offsetToMsgHdrSecondPart = hdrFirstPartLen + sizeofPointer;
    483          
    484            /* The packet header does not contain the pointers. The second part of */
    485            /* the packet header begins after the first array. */
    486            offsetToPktHdrSecondPart = hdrFirstPartLen + array1Len;
    487          
    488            /* In the message header, the first array is stored at a fixed offset */
    489            /* relative to the beginning of the header. */
    490            offsetToMsgArray1 = fmtInfo.offsetToMsgData;
    491          
    492            /* If there are two pointers, the second one cannot be at offset 0. */
    493            offsetToMsgPtr2 = fmtInfo.offsetToPtr2;
    494            if (!offsetToMsgPtr2) {
    495              /* There is only one array. */
    496          
    497              /* The second part of the header is the last part of the header. */
    498              hdrSecondPartLen = fmtInfo.hdrLen - offsetToMsgHdrSecondPart;
    499              
    500              /* because the first pointer is replaced by the first array, from the*/
    501              /* total length of the packet (totalDstLen) must be subtracted sizeofPointer bytes */
    502              totalDstLen = offsetToMsgArray1 + array1Len - sizeofPointer;
    503            } else {
    504              /* There are two arrays. */
    505          
    506              /* The second part of the header ends at the second pointer. */
    507              hdrSecondPartLen = offsetToMsgPtr2 - offsetToMsgHdrSecondPart;
    508          
    509              /* In the packet, the first pointer is replaced by the first array, */
    510              /* shifting the position of the second part of the header. If the */
    511              /* number-of-elements field for the second array is in the second part */
    512              /* of the header, allow for that displacement. */
    513              offsetToPktNumberOfArray2Elements = fmtInfo.offsetToNumberOfArray2Elements;
    514              if (offsetToPktNumberOfArray2Elements >= offsetToMsgHdrSecondPart) {
    515                offsetToPktNumberOfArray2Elements += array1Len - sizeofPointer;
    516              }
    517          
    518              /* The message header contains a pointer to the first array. The packet */
    519              /* header does not contain the array pointers. */
    520              array2Len = pPkt[offsetToPktNumberOfArray2Elements]
    521                        * fmtInfo.sizeofArray2Element;
    522          
    523              offsetToMsgArray2 = offsetToMsgArray1 + array1Len;
    524              /* because the first pointer is replaced by the first array, from the*/
    525              /* total length of the packet (totalDstLen) must be subtracted sizeofPointer bytes */
    526          
    527                totalDstLen       = offsetToMsgArray2 + array2Len - (2*sizeofPointer);
    528            }
    529          
    530            if (totalDstLen > msgLen) {
    531              return gTooBig_c;
    532            }
    533          
    534            /* Copy the first part of the header, up to the pointer. */
    535            FLib_MemCpy(pMsg, (void *) pPkt, hdrFirstPartLen);
    536          
    537            /* Write the first array pointer. */
    538           /*  *((uint8_t **)(pMsg + hdrFirstPartLen)) = (pMsg + offsetToMsgArray1); */
    539          
    540              auxArrayAddress = (uint32_t)(pMsg + offsetToMsgArray1);
    541              FLib_MemCpy(pMsg + hdrFirstPartLen, &auxArrayAddress, sizeofPointer);  
    542          
    543            /* Copy the second part of the header. */
    544            FLib_MemCpy((pMsg + offsetToMsgHdrSecondPart),
    545                        (void *) (pPkt + offsetToPktHdrSecondPart),
    546                        hdrSecondPartLen);
    547          
    548            /* If the elements of the second array are zero length, there is no */
    549            /* second array. */
    550            if (fmtInfo.sizeofArray2Element) {
    551              offsetToPktArray2         = offsetToPktHdrSecondPart + hdrSecondPartLen;
    552              offsetToMsgHdrThirdPart   = offsetToMsgPtr2 + sizeofPointer;
    553              offsetToPktHdrThirdPart   = offsetToPktArray2 + array2Len;
    554              hdrThirdPartLen           = fmtInfo.hdrLen - offsetToMsgPtr2 - sizeofPointer;
    555          
    556              /* Write the second array pointer. */
    557              /*
    558              *((uint8_t **)(pMsg + offsetToMsgPtr2)) = (pMsg + offsetToMsgArray2);
    559              */
    560              auxArrayAddress = (uint32_t)(pMsg + offsetToMsgArray2);
    561              FLib_MemCpy(pMsg + offsetToMsgPtr2, &auxArrayAddress, sizeofPointer);  
    562          
    563              /* Copy the third part of the header. */
    564              FLib_MemCpy((pMsg + offsetToMsgHdrThirdPart),
    565                          (void *) (pPkt + offsetToPktHdrThirdPart),
    566                          hdrThirdPartLen);
    567          
    568              /* Copy the second array. */
    569              FLib_MemCpy((pMsg + offsetToMsgArray2), (void *) (pPkt + offsetToPktArray2), array2Len);
    570            }
    571          
    572            /* Copy the first array. */
    573            FLib_MemCpy((pMsg + offsetToMsgArray1), (void *) (pPkt + hdrFirstPartLen  ), array1Len);
    574          
    575            return totalDstLen;
    576          }                                       /* ZtcMsgFromPktTwoArrayPtrs() */
    577          
    578          /****************************************************************************/
    579          
    580          /* The packet contains a fixed length header, which is copied unchanged to
    581           * the message.
    582           *
    583           * Source packet:
    584           *  | H |
    585           *
    586           * Destination message:
    587           *  | H |
    588           */
    589          index_t ZtcMsgFromPktSimple
    590            (
    591            uint8_t *pMsg,
    592            index_t msgLen,
    593            uint8_t *pPkt,
    594            index_t pktLen,
    595            index_t fmtParametersIndex
    596            )
    597          {
    598            (void) fmtParametersIndex;          /* Keep the compiler happy. */
    599          
    600            if (pktLen > msgLen) {
    601              return gTooBig_c;
    602            }
    603          
    604            FLib_MemCpy(pMsg, (void *) pPkt, pktLen);
    605            return pktLen;
    606          }                                       /* ZtcMsgFromPktSimple() */
    607          
    608          /****************************************************************************/
    609          
    610          /* The source message consists of a fixed length header followed immediately
    611           * by a variable number of fixed length data items. The header contains a
    612           * field that specifies the number of items.
    613           * Copy the source header + data to the destination unchanged.
    614           * Except for the function prototype, this is identical to
    615           * ZtcMsgFromPktHdrAndData().
    616           *
    617           * Source message:
    618           *  | H | D |
    619           *    ^   ^
    620           *    |   +-- variable length data
    621           *    +------ header, including length (in bytes) of data
    622           *
    623           * Destination packet:
    624           *  Same as source.
    625           *
    626           */
    627          #if gBeeStackIncluded_d
    628          
    629          index_t ZtcPktFromMsgHdrAndData
    630            (
    631            uint8_t *pPkt,
    632            index_t pktLen,
    633            uint8_t *pMsg,
    634            index_t msgLen,
    635            index_t fmtParametersIndex
    636            )
    637          {
    638            ztcFmtHdrAndData_t const *pFmtInfo;
    639            index_t totalDstLen;                  /* Risky on an 8 but CPU. */
    640          
    641            (void) msgLen;
    642          
    643            /* Note that the information in maZtcFmtTwoArrayPtrsTable[] describes */
    644            /* the message header. The layout of the packet header must be inferred. */
    645            pFmtInfo = &(maZtcFmtHdrAndDataTable[fmtParametersIndex]);
    646          
    647            totalDstLen = pFmtInfo->hdrLen
    648                        + (pMsg[pFmtInfo->offsetToCount] * pFmtInfo->itemLen);
    649          
    650            if (totalDstLen > pktLen) {
    651              return gTooBig_c;
    652            }
    653          
    654            FLib_MemCpy(pPkt, (void *) pMsg, totalDstLen);
    655          
    656            return totalDstLen;
    657          }                                       /* ZtcPktFromMsgHdrAndData() */
    658          
    659          #endif /* gBeeStackIncluded_d */
    660          /****************************************************************************/
    661          
    662          /* The message contains a header and data. The header contains a pointer to
    663           * an array of fixed length elements, and the number of elements, and a code
    664           * value that can be looked up ina table to get the length of the elements.
    665           *
    666           * There are some messages that use the length code approach, but that have
    667           * either a simgle data value instead of an array, and/or that have no pointer
    668           * (the data is immediately after the header). The secondary format table,
    669           * maZtcFmtLenCodeAndPtrTable[], may contain special values (-1) for the
    670           * offset-to-number-of-elements and/or offset-to-pointer fields to indicate
    671           * these exceptions.
    672           *
    673           * In packet-from-message copies using the format, the field in the message
    674           * header that contains a pointer is replaced by a length field in the
    675           * packet header immediately followed by the array data.
    676           *
    677           * Copy the message header to the packet header. Look up the code in the
    678           * code-and-length table. THe Test Tool cannot do arithmetic, so it
    679           * cannot multiply the number of elements times the size of the elements to
    680           * find the total data length. Do the multiplication, and store the result
    681           * as a 16 bit value in the location where the message header's pointer is.
    682           * Copy the data pointed to by the message header to immediately after the
    683           * packet header.
    684           *
    685           * The offsetToMsgData field in the format parameter table is ignored in
    686           * packet-from-message copies.
    687           *
    688           * Source message:
    689           *  | F | P | S | G | A |
    690           *    ^   ^   ^   ^   ^
    691           *    |   |   |   |   +-- Variable length array.
    692           *    |   |   |   +------ Gap between pointer and data. May be any length.
    693           *    |   |   +---------- Second (and last) part of header.
    694           *    |   +-------------- Pointer to "A".
    695           *    +------------------ First part of header.
    696           *
    697           * Destination packet:
    698           *  | F | L | A | S |
    699           *    ^   ^    ^   ^
    700           *    |   |   |   +-- Second (and last) part of header.
    701           *    |   |   +------ Variable length array.
    702           *    |   +---------- Length of the array in bytes (16 bits).
    703           *    +-------------- First part of header, including:
    704           *                    a length code field, and
    705           *                    a count of the number of elements in the array.
    706           */
    707          #if mZtcLenCodeAndPtrFormat_d
    708          index_t ZtcPktFromMsgLenCodeAndPtr
    709            (
    710            uint8_t *pPkt,
    711            index_t pktLen,
    712            uint8_t *pMsg,
    713            index_t msgLen,
    714            index_t fmtParametersIndex
    715            )
    716          {
    717            index_t arrayLen;                     /* Risky on an 8 bit CPU. */
    718            index_t code;
    719            ztcFmtLenCodeAndPtr_t fmtInfo;
    720            index_t elementLen;
    721            index_t hdrTotalLen;
    722            index_t hdrFirstPartLen;
    723            index_t i;
    724            index_t numberOfArrayElements;
    725            index_t offsetToCount;
    726            ztcCodeAndLen_t const *pCodeAndLenTable;
    727            /* uint8_t const *pMsgData; */
    728            uint8_t *pMsgData;
    729            index_t totalDstLen;                  /* Risky on an 8 bit CPU. */
    730          
    731            (void) msgLen;
    732          
    733            /* Note that the information in maZtcFmtTwoArrayPtrsTable[] describes */
    734            /* the message header. The layout of the packet header must be inferred. */
    735            FLib_MemCpy(&fmtInfo,
    736                        (void *) &(maZtcFmtLenCodeAndPtrTable[fmtParametersIndex]),
    737                        sizeof(fmtInfo));
    738            hdrTotalLen = fmtInfo.hdrLen;
    739          
    740            pCodeAndLenTable = fmtInfo.pCodeAndLenTable;
    741            code = pMsg[fmtInfo.offsetToLenCode];
    742            for (elementLen = (index_t) gMinusOne_c, i = 0; i < fmtInfo.codeAndLenTableLen; i++) {
    743              if (code == pCodeAndLenTable[i].code) {
    744                elementLen = pCodeAndLenTable[i].len;
    745              }
    746            }
    747          
    748            /* If the number of elements entry in the secondary format table is -1, */
    749            /* this format actually only has one array element, not a variable number */
    750            /* of them. */
    751            offsetToCount = fmtInfo.offsetToCount;
    752            numberOfArrayElements = 1;
    753            if (offsetToCount != (index_t) gMinusOne_c) {
    754              numberOfArrayElements = pMsg[offsetToCount];
    755            }
    756            arrayLen = elementLen * numberOfArrayElements;
    757            totalDstLen = hdrTotalLen + arrayLen;
    758          
    759            if (elementLen == (index_t) gMinusOne_c) {
    760              ZtcError(gZtcUnknownPIB_c);
    761            }
    762          
    763            if (totalDstLen > pktLen) {
    764              return gTooBig_c;
    765            }
    766          
    767            hdrFirstPartLen = fmtInfo.offsetToPtr;
    768            if (hdrFirstPartLen == (index_t) gMinusOne_c) {
    769              /* There is no pointer / length field. */
    770              hdrFirstPartLen = hdrTotalLen;
    771              pMsgData = pMsg + hdrTotalLen;
    772            } else {
    773              /* Store the length of the array. */
    774              /* *warning* This is brittle; it really should be a named typedef */
    775              /* instead of uint16_t. In the message this field is a pointer; in */
    776              /* the packet, its a length. Should be a union. Also has to agree */
    777              /* with the Test Tool. */
    778              *((uint16_t *) (pPkt + hdrFirstPartLen)) = Swap2Bytes((uint16_t)arrayLen); 
    779              /* Copy the second part of the header. */
    780              FLib_MemCpy(pPkt + hdrFirstPartLen + sizeofPointer + arrayLen,
    781                          (void *) (pMsg + hdrFirstPartLen + sizeofPointer),
    782                          hdrTotalLen - hdrFirstPartLen - sizeofPointer);
    783          
    784              /* pMsgData = *((uint8_t **) (pMsg + hdrFirstPartLen));  */
    785              pMsgData = pMsg + hdrFirstPartLen+sizeofPointer;
    786            }
    787          
    788            /* Copy the first part of the header. */
    789            FLib_MemCpy(pPkt, (void *) pMsg, hdrFirstPartLen);
    790          
    791            /* Copy the data. */
    792            /* FLib_MemCpy(pPkt + hdrTotalLen, (void *) pMsgData, arrayLen); */
    793            FLib_MemCpy(pPkt + hdrTotalLen - 2, (void *) pMsgData, arrayLen);
    794          
    795            return totalDstLen;
    796          }                                       /* ZtcPktFromMsgLenCodeAndPtr() */
    797          #endif                                  /* #if mZtcLenCodeAndPtrFormat_d */
    798          
    799          /****************************************************************************/
    800          
    801          /* See the comments for ZtcMsgFromPktTwoArrayPtrs().
    802           *
    803           * The source message looks like:
    804           *
    805           *  | F | P | M | Q | L | G | 1 | 2 |
    806           *    ^   ^   ^   ^   ^   ^   ^   ^
    807           *    :   :   :   :   :   :   :   +---- Second array data.
    808           *    :   :   :   :   :   :   +-------- First array data.
    809           *    :   :   :   :   :   +------------ Gap.
    810           *    :   :   :   :   +---------------- Third part of header.
    811           *    :   :   :   +-------------------- Pointer to second array.
    812           *    :   :   +------------------------ Second part of header.
    813           *    :   +---------------------------- Pointer to first array.
    814           *    +-------------------------------- First part of header.
    815           *
    816           * The field that specifies the number of element in the first array
    817           * must be in the first part of the header.
    818           * The field that specifies the number of elements in the second array
    819           * may be in either the first or second parts of the header.
    820           *
    821           * The destination packet looks like:
    822           *
    823           *  | F | 1 | M | 2 | L |
    824           *    ^   ^   ^   ^   ^
    825           *    :   :   :   :   +---- Third part of header.
    826           *    :   :   :   +-------- Contents of second array.
    827           *    :   :   +------------ Second part of header.
    828           *    :   +---------------- Contents of first array
    829           *    +-------------------- First part of header.
    830           *
    831           * The field that specifies the number of elements in the second array may
    832           * be in either the first or second part of the header.
    833           */
    834          index_t ZtcPktFromMsgTwoArrayPtrs
    835            (
    836            uint8_t *pPkt,
    837            index_t pktLen,
    838            uint8_t *pMsg,
    839            index_t msgLen,
    840            index_t fmtParametersIndex
    841            )
    842          {
    843            ztcFmtTwoArrayPtrs_t fmtInfo;
    844          
    845            index_t array1Len;                    /* Risky on an 8 bit CPU. */
    846            index_t array2Len;                    /* Risky on an 8 bit CPU. */
    847          
    848            /* The first, second, and third parts of the msg and pkt headers are */
    849            /* identical. */
    850            index_t hdrLen;
    851            index_t hdrSecondPartLen;
    852            index_t hdrThirdPartLen;
    853          
    854            index_t offsetToMsgHdrPtr1;
    855            index_t offsetToMsgHdrSecondPart;
    856            index_t offsetToMsgHdrPtr2;
    857            index_t offsetToMsgHdrThirdPart;
    858          
    859            uint8_t *pPktArray1;
    860            uint8_t *pPktHdrSecondPart;
    861            uint8_t *pPktArray2;
    862            uint8_t *pPktHdrThirdPart;
    863          
    864          /*  uint8_t **pMsgHdrPtrToArray1; */
    865          /*  uint8_t **pMsgHdrPtrToArray2; */
    866          
    867            uint8_t *pMsgArray1;
    868            uint8_t *pMsgArray2;
    869            index_t totalDstLen;                  /* Risky on an 8 bit CPU. */
    870          
    871            (void) msgLen;
    872          
    873            /* Note that the information in maZtcFmtTwoArrayPtrsTable[] describes */
    874            /* the message header. The layout of the packet header must be inferred. */
    875            FLib_MemCpy(&fmtInfo,
    876                        (void *) &(maZtcFmtTwoArrayPtrsTable[fmtParametersIndex]),
    877                        sizeof(fmtInfo));
    878          
    879            array1Len = pMsg[fmtInfo.offsetToNumberOfArray1Elements]
    880                      * fmtInfo.sizeofArray1Element;
    881          
    882            /* If there is only one array, sizeofArray2Element will be == 0, and so */
    883            /* array2Len will be == 0. */
    884            array2Len = pMsg[fmtInfo.offsetToNumberOfArray2Elements]
    885                      * fmtInfo.sizeofArray2Element;
    886          
    887            hdrLen                    = fmtInfo.hdrLen;
    888            offsetToMsgHdrPtr1        = fmtInfo.offsetToPtr1;
    889          
    890            /* If there is only one array, there is no second pointer, and the header */
    891            /* only has two parts (first and second, with no third part). Use the total */
    892            /* size of the header to compute the length of the second part. */
    893            offsetToMsgHdrPtr2        = fmtInfo.offsetToPtr2;
    894            if (!offsetToMsgHdrPtr2) {
    895              offsetToMsgHdrPtr2 = hdrLen;
    896            }
    897          
    898            offsetToMsgHdrSecondPart  = offsetToMsgHdrPtr1 + sizeofPointer;
    899            hdrSecondPartLen          = offsetToMsgHdrPtr2 - offsetToMsgHdrSecondPart;
    900          
    901            pPktArray1                = pPkt + offsetToMsgHdrPtr1;
    902            pPktHdrSecondPart         = pPktArray1 + array1Len;
    903          /*
    904            pMsgHdrPtrToArray1        = (uint8_t **) (pMsg + offsetToMsgHdrPtr1);
    905          
    906            pMsgArray1                = *pMsgHdrPtrToArray1;
    907           */
    908          
    909            FLib_MemCpy(&pMsgArray1, pMsg + offsetToMsgHdrPtr1, sizeofPointer);
    910          
    911            /* The message version has either one or two pointers. The packet version */
    912            /* has no pointer (the arrays take the place of the pointers). */
    913            totalDstLen               = hdrLen + array1Len - sizeofPointer;
    914            if (fmtInfo.sizeofArray2Element) {
    915              totalDstLen += array2Len - sizeofPointer;   /* Allow for the 2nd array. */
    916            }
    917          
    918            if (totalDstLen > pktLen) {
    919              return gTooBig_c;
    920            }
    921          
    922            /* Copy the beginning of the header. */
    923            FLib_MemCpy(pPkt, (void *) pMsg, offsetToMsgHdrPtr1);
    924          
    925            /* Copy the data for the first array. */
    926            FLib_MemCpy(pPktArray1, (void *) pMsgArray1, array1Len);
    927          
    928            /* Copy the second of the header, between the pointers. */
    929            FLib_MemCpy(pPktHdrSecondPart,
    930                        (void *) (pMsg + offsetToMsgHdrSecondPart),
    931                        hdrSecondPartLen);
    932          
    933            /* If the elements of the second array are zero length, there is no */
    934            /* second array. */
    935            if (fmtInfo.sizeofArray2Element) {
    936              offsetToMsgHdrThirdPart   = offsetToMsgHdrPtr2 + sizeofPointer;
    937              hdrThirdPartLen           = hdrLen - offsetToMsgHdrThirdPart;
    938          
    939              pPktArray2                = pPktHdrSecondPart + hdrSecondPartLen;
    940              pPktHdrThirdPart          = pPktArray2 + array2Len;
    941              /*
    942              pMsgHdrPtrToArray2        = (uint8_t **) (pMsg + offsetToMsgHdrPtr2);
    943              pMsgArray2                = *pMsgHdrPtrToArray2;
    944              */
    945              FLib_MemCpy(&pMsgArray2, pMsg + offsetToMsgHdrPtr2, sizeofPointer);
    946          
    947              /* Copy the data for the second array. */
    948              FLib_MemCpy(pPktArray2, (void *) pMsgArray2, array2Len);
    949          
    950              /* Copy the remainder of the header. */
    951              FLib_MemCpy(pPktHdrThirdPart,
    952                          (void *) (pMsg + offsetToMsgHdrThirdPart),
    953                          hdrThirdPartLen);
    954            }
    955          
    956            return totalDstLen;
    957          }                                       /* ZtcPktFromMsgTwoArrayPtrs() */
    958          
    959          /****************************************************************************/
    960          
    961          /* The packet contains a fixed length header, which is copied unchanged to
    962           * the message.
    963           *
    964           * Source message
    965           *  | H |
    966           *
    967           * Destination packet:
    968           *  | H |
    969           */
    970          index_t ZtcPktFromMsgSimple
    971            (
    972            uint8_t *pPkt,
    973            index_t pktLen,
    974            uint8_t *pMsg,
    975            index_t msgLen,
    976            index_t fmtParametersIndex
    977            )
    978          {
    979            (void) fmtParametersIndex;
    980          
    981            if (pktLen < msgLen) {
    982              return gTooBig_c;
    983            }
    984          
    985            FLib_MemCpy(pPkt, (void *) pMsg, msgLen);
    986            return msgLen;
    987          }                                       /* ZtcPktFromMsgSimple() */
    988          
    989          /****************************************************************************/
    990          
    991          /* Placeholder function to fill in the Fmt() table slot for message formats
    992           * that don't require packet-from-message copying.
    993           */
    994          index_t ZtcPktFromMsgUnused
    995            (
    996            uint8_t *pPkt,
    997            index_t pktLen,
    998            uint8_t *pMsg,
    999            index_t msgLen,
   1000            index_t fmtParametersIndex
   1001            )
   1002          {
   1003            /* Keep the compiler happy. */
   1004            (void) pPkt;
   1005            (void) pktLen;
   1006            (void) pMsg;
   1007            (void) msgLen;
   1008            (void) fmtParametersIndex;
   1009          
   1010            return gTooBig_c;
   1011          }                                       /* ZtcPktFromMsgUnused() */
   1012          
   1013          
   1014          /****************************************************************************/
   1015          /* Custom function for copying MAC BeaconNotifyIndication from MLME message
   1016           * to ZTC packet. It is needed because the BeaconNotifyInd frame does not
   1017           * have a format that can be applied to other data copy functions. 
   1018           *
   1019           * Source message:
   1020           *  | BSN | PendAddrSpec | sduLength | *pAddrList | *pPanDescriptor | pSdu |
   1021           *
   1022           * Destination packet:
   1023           *  | BSN | PendAddrSpec | sduLength | AddrList | PanDescriptor | pSdu | 
   1024           *
   1025           */
   1026          #if gSAPMessagesEnableMlme_d
   1027          index_t ZtcPktFromMsgMacBeaconNotifyInd
   1028            (
   1029            uint8_t *pPkt,
   1030            index_t pktLen,
   1031            uint8_t *pMsg,
   1032            index_t msgLen,
   1033            index_t fmtParametersIndex
   1034            )
   1035          {
   1036            index_t currentLen;
   1037            index_t totalDstLen;  
   1038            index_t addrLen;
   1039          
   1040            /* Apply a beacon notify structure pointer to the message buffer. */
   1041            nwkBeaconNotifyInd_t *pMsgBeaconNotifyInd = (nwkBeaconNotifyInd_t *)pMsg;
   1042            uint8_t pendAddrSpec = pMsgBeaconNotifyInd->pendAddrSpec;
   1043            uint8_t sduLength = pMsgBeaconNotifyInd->sduLength;
   1044            
   1045            /* Get the short and extended address counts from the PendAddrSpec field. */
   1046            /* 802.15.4 IEEE standard 7.2.2.1.6 */
   1047            index_t shortAddrCnt = pendAddrSpec & 0x07;
   1048            index_t extAddrCnt = (pendAddrSpec & 0x70) >> 4;
   1049              
   1050            (void) msgLen;
   1051            (void) fmtParametersIndex;  
   1052            
   1053            /* Copy BSN */
   1054            pPkt[0] = pMsgBeaconNotifyInd->bsn;
   1055            /* Copy PendAddrSpec */
   1056            pPkt[1] = pendAddrSpec;  
   1057            /* Copy SDU length */
   1058            pPkt[2] = sduLength;  
   1059          
   1060            /* Get the total length in bytes of the address list  */
   1061            addrLen = (shortAddrCnt << 1) + (extAddrCnt << 3);
   1062          
   1063            /* Get total length of the ZTC packet  */
   1064            totalDstLen = 3 + addrLen + sizeof(panDescriptor_t) + sduLength;
   1065            
   1066            if (totalDstLen > pktLen) {
   1067              return gTooBig_c;
   1068            }  
   1069          
   1070            /* Copy address list */
   1071            FLib_MemCpy(&pPkt[3], pMsgBeaconNotifyInd->pAddrList, addrLen);  
   1072            
   1073            currentLen = addrLen + 3;
   1074            
   1075            /* Copy PanDescriptor from the pointer in Beacon Notify Structure */
   1076            FLib_MemCpy(&pPkt[currentLen], pMsgBeaconNotifyInd->pPanDescriptor, 
   1077                        sizeof(panDescriptor_t));
   1078            
   1079            currentLen += sizeof(panDescriptor_t);
   1080            
   1081            /* Copy SDU */
   1082            FLib_MemCpy(&pPkt[currentLen], pMsgBeaconNotifyInd->pSdu, sduLength);
   1083            
   1084            return totalDstLen;  
   1085          }                                       /* ZtcPktFromMsgMacBeaconNotifyInd() */
   1086          #endif                                  /* #if gSAPMessagesEnableMlme_d     */
   1087          
   1088          
   1089          /****************************************************************************/
   1090          /* The function saves the values specified in the channel list for each MAC 
   1091           * Scan Request given from ZTC in the static maScanChannels so that the 
   1092           * subsequent MAC Scan Confirm message from ZTC can be built correctly for 
   1093           * an Energy Detect Scan Type. For this type of scan confirm, the list of 
   1094           * energies should only contain the values given for the channels specifed
   1095           * in the scan request, so we save the list of channels and retrieve it in
   1096           * ZtcPktFromMsgMacScanCnf when building the list for the scan confirm.
   1097           * The function acts a proxy for ZtcMsgFromPktSimple as its only role is 
   1098           * to save the channel list and does not do actual data copying from pkt to
   1099           * msg.
   1100           */
   1101          #if gSAPMessagesEnableMlme_d
   1102          index_t ZtcMsgFromPktMacScanReq
   1103          (
   1104            uint8_t *pMsg,
   1105            index_t msgLen,
   1106            uint8_t *pPkt,
   1107            index_t pktLen,
   1108            index_t fmtParametersIndex
   1109            )
   1110          {
   1111            mlmeScanReq_t *pPktScanReq;
   1112            index_t result;
   1113            pPktScanReq = (mlmeScanReq_t *)pPkt;
   1114            
   1115            /* Saving channel list in MAC Scan Request */
   1116            maScanChannels[ 0 ] = pPktScanReq->scanChannels[ 0 ];
   1117            maScanChannels[ 1 ] = pPktScanReq->scanChannels[ 1 ];
   1118            maScanChannels[ 2 ] = pPktScanReq->scanChannels[ 2 ];
   1119            maScanChannels[ 3 ] = pPktScanReq->scanChannels[ 3 ];
   1120            
   1121            /* Redirect packet to simple data copy function */
   1122            result = ZtcMsgFromPktSimple(pMsg, msgLen, pPkt, pktLen, fmtParametersIndex);
   1123            return result;
   1124          }
   1125          #endif                                  /* #if gSAPMessagesEnableMlme_d */
   1126          
   1127          #if gSAPMessagesEnableMlme_d
   1128          index_t ZtcPktFromMsgMacScanReq
   1129          (
   1130            uint8_t *pMsg,
   1131            index_t msgLen,
   1132            uint8_t *pPkt,
   1133            index_t pktLen,
   1134            index_t fmtParametersIndex
   1135            )
   1136          {
   1137            mlmeScanReq_t *pPktScanReq;
   1138            index_t result;
   1139            pPktScanReq = (mlmeScanReq_t *)pPkt;
   1140           
   1141            /* Saving channel list in MAC Scan Request */
   1142            maScanChannels[ 0 ] = pPktScanReq->scanChannels[ 0 ];
   1143            maScanChannels[ 1 ] = pPktScanReq->scanChannels[ 1 ];
   1144            maScanChannels[ 2 ] = pPktScanReq->scanChannels[ 2 ];
   1145            maScanChannels[ 3 ] = pPktScanReq->scanChannels[ 3 ];
   1146            
   1147            /* Redirect packet to simple data copy function */
   1148            result = ZtcPktFromMsgSimple(pMsg, msgLen, pPkt, pktLen, fmtParametersIndex);
   1149            return result;
   1150          }
   1151          #endif                                  /* #if gSAPMessagesEnableMlme_d */
   1152          
   1153          #if gSAPMessagesEnableInterPan_d
   1154          index_t ZtcPktFromMsgInterPanDataReq
   1155          (
   1156            uint8_t *pMsg,
   1157            index_t msgLen,
   1158            uint8_t *pPkt,
   1159            index_t pktLen,
   1160            index_t fmtParametersIndex
   1161            )
   1162          {
   1163            index_t result;
   1164            
   1165            /* Redirect packet to simple data copy function, but insure that the pasduhandle is not copied */
   1166            msgLen = msgLen - MbrSizeof(zbInterPanDataReq_t, pAsduHandle);
   1167            result = ZtcPktFromMsgTwoArrayPtrs(pMsg, msgLen, pPkt, pktLen, fmtParametersIndex);
   1168            return result;
   1169          }
   1170          #endif                                  /* #if gSAPMessagesEnableInterPan_d */
   1171          
   1172          #if gSAPMessagesEnableInterPan_d
   1173          index_t ZtcMsgFromPktInterPanDataReq
   1174          (
   1175            uint8_t *pMsg,
   1176            index_t msgLen,
   1177            uint8_t *pPkt,
   1178            index_t pktLen,
   1179            index_t fmtParametersIndex
   1180            )
   1181          {
   1182            zbInterPanDataReq_t *pPktInterPanDataReq;
   1183            index_t result;  
   1184            pPktInterPanDataReq = (zbInterPanDataReq_t*)pMsg;
   1185            
   1186            result = ZtcMsgFromPktTwoArrayPtrs(pMsg, msgLen, pPkt, pktLen, fmtParametersIndex);
   1187            /*Make sure that the msdu handle pointer is set to NULL*/
   1188            pPktInterPanDataReq->pAsduHandle = NULL;  
   1189            
   1190            return result;
   1191          }
   1192          #endif                                  /* #if gSAPMessagesEnableInterPan_d */
   1193          
   1194          /****************************************************************************/
   1195          /* Custom function for copying MAC Scan Confirmation from MLME message
   1196           * to ZTC packet. It is needed because it uses the stored maScanChannels values
   1197           * in order to identify which of the channels in the Energy Detect List
   1198           * was returned in the confirmation message. 
   1199           *
   1200           */
   1201          #if gSAPMessagesEnableMlme_d || gSAPMessagesEnableNlme_d
   1202          index_t ZtcPktFromMsgMacScanCnf
   1203            (
   1204            uint8_t *pPkt,
   1205            index_t pktLen,
   1206            uint8_t *pMsg,
   1207            index_t msgLen,
   1208            index_t fmtParametersIndex
   1209            )
   1210          {
   1211            index_t totalDstLen;                  /* Risky on 8 bit CPUs. */
   1212            index_t scanType;
   1213            index_t elementLen;
   1214            index_t arrayLen;
   1215            index_t hdrLen;
   1216            nwkScanCnf_t *pMsgScanCnf;
   1217            uint8_t cChannelCounter = 0x00;  
   1218            uint8_t iIndex = ByteOffset;  
   1219            uint8_t bitMask = MaskAllExceptThirdByte;  
   1220            
   1221            (void) msgLen;
   1222            (void) fmtParametersIndex;  
   1223          
   1224            /* Apply a Scan Confirmation structure pointer to the message buffer. */
   1225            pMsgScanCnf = (nwkScanCnf_t *)pMsg;
   1226            
   1227            /* Find out fixed number of bytes to the variable-sized list */
   1228            hdrLen = MbrOfs(nwkScanCnf_t, resList);
   1229            scanType = pMsgScanCnf->scanType;
   1230          
   1231            /* Get the element lenght of the result list which is 1 for ED */
   1232            /*  and orphan scan and 22 for Active and Passive Scan types */
   1233            elementLen = IndirectMbrSizeof(nwkScanCnf_t, resList.pEnergyDetectList);
   1234            if ( scanType == gScanModeActive_c || scanType == gScanModePassive_c )
   1235              elementLen = sizeof(panDescriptor_t);
   1236            
   1237            /* arrayLen holds the size of the variable result list */
   1238            
   1239            #if gZtcExtendedScanConfirmSupport_c
   1240              arrayLen = pMsgScanCnf->resultListSize * elementLen;
   1241            #else
   1242              if(( scanType == gScanModeED_c)||
   1243                (( scanType == gScanModeActive_c || scanType == gScanModePassive_c )&&
   1244                 (pMsgScanCnf->resultListSize <= aScanResultsPerBlock)))
   1245              {
   1246                 arrayLen = pMsgScanCnf->resultListSize * elementLen;
   1247              }    
   1248              else
   1249              {
   1250                 arrayLen = elementLen*aScanResultsPerBlock;  
   1251          
   1252              }
   1253            #endif
   1254          
   1255            totalDstLen = hdrLen + arrayLen;
   1256            
   1257            if (totalDstLen > pktLen) {
   1258              return gTooBig_c;
   1259            }  
   1260          
   1261            /* copy the bytes from before the variable result list */  
   1262            FLib_MemCpy(pPkt, (void *) pMsg, hdrLen );
   1263            
   1264            /* if the MAC scan was an energy detect, we retrieve the channels */  
   1265            /* scanned from maScanChannels and copy only those energy values */  
   1266            /* from the global buffer to the ZTC packet */
   1267             if (scanType == gScanModeED_c) 
   1268             {
   1269              if(pMsgScanCnf->resultListSize != 0)
   1270              {
   1271              uint8_t *pEdList = pMsgScanCnf->resList.pEnergyDetectList;
   1272              uint8_t *pCurrentArrayIdx = pPkt + totalDstLen - 1;
   1273            
   1274              for( cChannelCounter = gNumOfChannels_c; cChannelCounter>0; cChannelCounter-- )
   1275              {   
   1276                if ( maScanChannels[ iIndex ] & bitMask ) {
   1277                  *pCurrentArrayIdx = pEdList[ cChannelCounter -1 ];
   1278                  pCurrentArrayIdx--;
   1279                }
   1280                
   1281                bitMask >>= ShiftRightByOne;
   1282                /* Check if 1 Byte (set of 8 channels ) is over */
   1283                if( 0x00 == bitMask ) {
   1284                  /* This is used to Right Shift and mask as we traverse each Channel,
   1285                      Reinitialise it to 0x80 for next channel  */
   1286                  bitMask = 0x80;
   1287                  iIndex--;
   1288                }
   1289                }
   1290              }
   1291            } 
   1292            /* any other kind of MAC scan */  
   1293            else 
   1294            {            
   1295              if(pMsgScanCnf->resultListSize <= aScanResultsPerBlock) 
   1296              {
   1297                 FLib_MemCpy(pPkt + hdrLen, 
   1298                            (void *) (&pMsgScanCnf->resList.pPanDescriptorBlocks->descriptorList), 
   1299                            arrayLen);                                    
   1300              } 
   1301              else
   1302              {  
   1303                 FLib_MemCpy(pPkt + hdrLen, 
   1304                            (void *) (&pMsgScanCnf->resList.pPanDescriptorBlocks->descriptorList), 
   1305                            (elementLen*aScanResultsPerBlock)); 
   1306                 #if gZtcExtendedScanConfirmSupport_c                  
   1307                    FLib_MemCpy(pPkt + hdrLen + elementLen*aScanResultsPerBlock + 1, 
   1308                               (void *) (&pMsgScanCnf->resList.pPanDescriptorBlocks->pNext->descriptorList), 
   1309                               (elementLen *(pMsgScanCnf->resultListSize-aScanResultsPerBlock)));                 
   1310                 #endif                
   1311              }
   1312                
   1313                             
   1314            }
   1315            return totalDstLen;  
   1316          }                                       /* ZtcPktFromMsgMacScanCnf() */
   1317          #endif                                  /* #if gSAPMessagesEnableMlme_d */
   1318          
   1319          #endif                                  /* #if gZtcIncluded_d == 1 */


 
 
 0 bytes of memory

Errors: none
Warnings: none
