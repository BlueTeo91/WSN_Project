///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      15/Oct/2012  16:29:13 /
// IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM               /
// Copyright (C) 1999-2010 IAR Systems AB.                                    /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  C:\Documents and Settings\Administrator\My              /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\PLM\Source\NVM\NV_Flash.c                 /
//    Command line =  "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\PLM\Source\NVM\NV_Flash.c" -D             /
//                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D      /
//                    gZtcIncluded_d=0 -D gTargetMC1322xNCB=1 --preprocess    /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Debug\List\" -lC "C:\Documents and        /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\List\" -lB "C:\Documents and        /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\List\" --diag_suppress              /
//                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\Obj\" --no_cse --no_unroll          /
//                    --no_inline --no_code_motion --no_tbaa --no_clustering  /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program   /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\DLib_Config_Normal.h" -I             /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\MacPhy\Interface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Application\Init\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Application\Interface\" -I "C:\Documents  /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\Application\Configure\" -I         /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Application\UartUtil\" -I "C:\Documents   /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\Application\Source\" -I            /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\SSM\TS\Interface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\TS\Source\" -I "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\ZTC\Interface\" -I "C:\Documents and  /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\ZTC\Source\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Interface\" -I "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\LibInterface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\Display\" -I "C:\Documents     /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\PLM\Source\Keyboard\" -I           /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\PLM\Source\NVM\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\TMR\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\UART\" -I "C:\Program          /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On   /
//    List file    =  C:\Documents and Settings\Administrator\My              /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Debug\List\NV_Flash.s                     /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME NV_Flash

        EXTERN CRM_VRegCntl
        EXTERN NvDataSetTable
        EXTERN NvHalEraseSector
        EXTERN NvHalInit
        EXTERN NvHalIsBlank
        EXTERN NvHalRead
        EXTERN NvHalVerify
        EXTERN NvHalWrite
        EXTERN TS_SendEvent
        EXTERN gIdleTaskID
        EXTERN maNvRawSectorAddressTable

        PUBLIC NvClearCriticalSection
        PUBLIC NvIdle
        PUBLIC NvIsDataSetDirty
        PUBLIC NvModuleInit
        PUBLIC NvPrimitiveSearch
        PUBLIC NvRestoreDataSet
        PUBLIC NvSaveOnCount
        PUBLIC NvSaveOnIdle
        PUBLIC NvSaveOnInterval
        PUBLIC NvSetCountsBetweenSaves
        PUBLIC NvSetCriticalSection
        PUBLIC NvSetMinimumTicksBetweenSaves
        PUBLIC NvTimerTick
        PUBLIC PowerDownNVM
        PUBLIC PowerUpNVM
        PUBLIC gNvMinimumTicksBetweenSaves

// C:\Documents and Settings\Administrator\My Documents\MyWirelessApp Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon (Coordinator)\PLM\Source\NVM\NV_Flash.c
//    1 /*****************************************************************************
//    2 * Non-volatile storage module local implementation.
//    3 *
//    4 * Copyright (c) 2006, Freescale, Inc. All rights reserved.
//    5 *
//    6 *
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor.
//   10 *
//   11 *****************************************************************************/
//   12 
//   13 #include "EmbeddedTypes.h"
//   14 #include "TS_Interface.h"
//   15 #include "NV_FlashHAL.h"
//   16 #include "NV_Flash.h"
//   17 #include "Crm.h"
//   18 
//   19 
//   20 /*****************************************************************************
//   21 ******************************************************************************
//   22 * Private macros
//   23 ******************************************************************************
//   24 *****************************************************************************/
//   25 
//   26 /* Size of a member of a struct. */
//   27 #ifndef MbrSizeof
//   28 #define MbrSizeof(type, member)     (sizeof(((type *) 0)->member))
//   29 #endif
//   30 
//   31 /* There must be at least one more flash page than there are data sets, to */
//   32 /* allow for one copy of each data set plus a page for a new copy of one */
//   33 /* data set. */
//   34 
//   35 #if gNvNumberOfRawPages_c <= gNvNumberOfDataSets_c
//   36 #error
//   37 #endif
//   38 
//   39 /* this macro must reflect the bit used for the idle task defined in BeeApp.c */
//   40 #define gIdleTaskNVIntervalEvent_c  ( 1 << 0 )
//   41 #define gMaxPageOffset_c  ( sizeof(NvStructuredSectorHeader_t) + gNvNumberOfRawPages_c * sizeof(NvRawPage_t))
//   42 #define gLastPageOffset_c ( sizeof(NvStructuredSectorHeader_t) + (gNvNumberOfRawPages_c - 1) * sizeof(NvRawPage_t))
//   43 #define gUninitAddress     0xffffffff
//   44 #define NvOpenSector(nvRawSectorAddress, sequenceNumber)     NvOpen_Validate_Sector( nvRawSectorAddress , sequenceNumber, TRUE )
//   45 #define NvValidateSector(nvRawSectorAddress, sequenceNumber) NvOpen_Validate_Sector( nvRawSectorAddress , sequenceNumber, FALSE )
//   46 #define g_CopyBufferSize_c  64
//   47 
//   48 /*****************************************************************************
//   49 ******************************************************************************
//   50 * Private prototypes
//   51 ******************************************************************************
//   52 *****************************************************************************/
//   53 #if gNvStorageIncluded_d
//   54 void PowerUpNVM(void);
//   55 void PowerDownNVM(void);
//   56 static index_t NvDataSetIndexFromID(NvDataSetID_t dataSetID);
//   57 static bool_t NvIsValidPage( NvRawPageAddress_t nvRawPageAddress , NvDataSetID_t *pDataSetID );
//   58 static bool_t NvIsValidSector (  NvRawSectorAddress_t nvRawSectorAddress  );
//   59 static bool_t NvSaveDataSetLowLevel(  index_t dataSetIndex , NvRawPageAddress_t pageAddress  );
//   60 static void NvSaveDataSet( index_t dataSetIndex );
//   61 static void NvGetFirstBlankPageInfo(NvRawPageAddress_t nvRawSectorAddress, NvRawPageAddress_t* pBlankPage, index_t* pBlankPageIndex);
//   62 static NvSectorSequenceNumber_t NvGetSectorSequenceNumber( NvRawSectorAddress_t nvRawSectorAddress );
//   63 static bool_t NvCopyDataSet  (  NvRawPageAddress_t sourcePage , NvRawPageAddress_t destPage  );
//   64 static bool_t NvOpen_Validate_Sector(NvRawSectorAddress_t nvRawSectorAddress, NvSectorSequenceNumber_t sequenceNumber, bool_t open );
//   65 static NvSectorSequenceNumber_t NvLastSectorSequence ( NvSectorSequenceNumber_t sectorSeqA,NvSectorSequenceNumber_t sectorSeqB );
//   66 static void NvGetSectorPageInfo ( NvRawSectorAddress_t nvRawSectorAddress, NvSectPageInfo_t* pSectPageInfo );
//   67 static bool_t  NvCopyTheRemainsDataSets ( NvSectPageInfo_t* oldSectPageInfo, NvSectPageInfo_t* newSectPageInfo, NvRawPageAddress_t firstBlankPageAddress,index_t firstBlankPageIndex );
//   68 #endif
//   69 
//   70 #if gNvSelfTest_d
//   71 static void NvSelfTest(void);
//   72 #endif
//   73 
//   74 /*****************************************************************************
//   75 ******************************************************************************
//   76 * Private type definitions
//   77 ******************************************************************************
//   78 *****************************************************************************/
//   79 
//   80 /* One entry per data set. */
//   81 typedef struct NvDataSetInfo_tag {
//   82   bool_t saveNextInterval;
//   83   NvSaveInterval_t ticksToNextSave;
//   84   NvSaveCounter_t countsToNextSave;
//   85 } NvDataSetInfo_t;
//   86 
//   87 
//   88 /*****************************************************************************
//   89 ******************************************************************************
//   90 * Private memory declarations
//   91 ******************************************************************************
//   92 *****************************************************************************/
//   93 
//   94 #if gNvStorageIncluded_d
//   95 /* Table of dirty flags, one per dataset in NvDataSetDescriptionTable[]. */

        SECTION `.bss`:DATA:NOROOT(2)
//   96 static NvDataSetInfo_t maNvDirtyFlags[gNvNumberOfDataSets_c];
maNvDirtyFlags:
        DS8 12
//   97 
//   98 /* Minimum number of calls to NvTimerTick() between saves of a given dataset. */

        SECTION `.data`:DATA:NOROOT(1)
//   99 NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
gNvMinimumTicksBetweenSaves:
        DATA
        DC16 4
//  100 /* Minimum number of calls to NvSaveOnIdle() between saves of a given dataset. */

        SECTION `.data`:DATA:NOROOT(1)
//  101 static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
gNvCountsBetweenSaves:
        DATA
        DC16 256
//  102 
//  103 /* If this counter is != 0, do not save to NV Storage. */

        SECTION `.bss`:DATA:NOROOT(0)
//  104 static uint8_t mNvCriticalSectionFlag = 0;
mNvCriticalSectionFlag:
        DS8 1
//  105 #endif                                  /* #if gNvStorageIncluded_d */
//  106 
//  107 /* Scratch data sets used by the internal unit test. */
//  108 
//  109 
//  110 /*****************************************************************************
//  111 ******************************************************************************
//  112 * Public functions
//  113 ******************************************************************************
//  114 *****************************************************************************/
//  115 
//  116 /* There may be operations that take place over extended times that must
//  117  * be atomic from the point of view of NV Storage saves. These routines
//  118  * increment/decrement a counter; when the counter is non-zero, no NV
//  119  * saves will be done. Note that this does not affect NV restores.
//  120  */
//  121 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  122 void NvClearCriticalSection(void) {
NvClearCriticalSection:
        PUSH     {LR}
//  123 #if gNvStorageIncluded_d
//  124   if(mNvCriticalSectionFlag)  /* dg - in case of set/clear mismatch */
        LDR      R0,??DataTable5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??NvClearCriticalSection_0
//  125     --mNvCriticalSectionFlag;
        LDR      R0,??DataTable5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR      R1,??DataTable5
        STRB     R0,[R1, #+0]
//  126 #endif /* gNvStorageIncluded_d */
//  127 }
??NvClearCriticalSection_0:
        POP      {R3}
        BX       R3               ;; return
//  128 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  129 void NvSetCriticalSection(void) {
//  130 #if gNvStorageIncluded_d
//  131   ++mNvCriticalSectionFlag;
NvSetCriticalSection:
        LDR      R0,??DataTable5
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable5
        STRB     R0,[R1, #+0]
//  132 #endif /* gNvStorageIncluded_d */
//  133 }
        BX       LR               ;; return
//  134 
//  135 
//  136 /****************************************************************************/
//  137 
//  138 /* Called from the idle task to process save-on-next-idle and save-on-count. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  139 void NvIdle(void)
//  140 {
NvIdle:
        PUSH     {R4,LR}
//  141 #if gNvStorageIncluded_d
//  142   index_t i;
//  143 
//  144   if (mNvCriticalSectionFlag) {
        LDR      R0,??DataTable5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??NvIdle_0
//  145     return;
//  146   }
//  147    
//  148   for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
??NvIdle_1:
        MOVS     R0,#+0
        MOVS     R4,R0
??NvIdle_2:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvIdle_3
//  149     if (!maNvDirtyFlags[i].countsToNextSave) {
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+6
        MULS     R0,R4,R0
        LDR      R1,??DataTable5_1
        ADDS     R0,R1,R0
        LDRH     R0,[R0, #+4]
        CMP      R0,#+0
        BNE      ??NvIdle_4
//  150       NvSaveDataSet(i);
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvSaveDataSet
//  151     }
//  152   }
??NvIdle_4:
        ADDS     R4,R4,#+1
        B        ??NvIdle_2
//  153 #endif
//  154 }                                       /* NvIdle() */
??NvIdle_3:
??NvIdle_0:
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return
//  155 
//  156 /****************************************************************************/
//  157 
//  158 /* Return TRUE if the given data set is dirty. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  159 bool_t NvIsDataSetDirty
//  160   (
//  161   NvDataSetID_t dataSetID
//  162   )
//  163 {
NvIsDataSetDirty:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  164 #if !gNvStorageIncluded_d
//  165   (void) dataSetID;
//  166   return FALSE;
//  167 #else
//  168   index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvDataSetIndexFromID
        MOVS     R5,R0
//  169   return (    maNvDirtyFlags[dataSetIndex].saveNextInterval
//  170           || (maNvDirtyFlags[dataSetIndex].countsToNextSave != gNvCountsBetweenSaves_c));
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable5_1
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BNE      ??NvIsDataSetDirty_0
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R5,R0,R5
        LDR      R0,??DataTable5_1
        ADDS     R0,R0,R5
        LDRH     R0,[R0, #+4]
        MOVS     R1,#+128
        LSLS     R1,R1,#+1        ;; #+256
        CMP      R0,R1
        BEQ      ??NvIsDataSetDirty_1
??NvIsDataSetDirty_0:
        MOVS     R0,#+1
        B        ??NvIsDataSetDirty_2
??NvIsDataSetDirty_1:
        MOVS     R0,#+0
??NvIsDataSetDirty_2:
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        POP      {R1,R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  171 #endif                                  /* #if !gNvStorageIncluded_d #else */
//  172 }                                       /* NvIsDataSetDirty() */
//  173 
//  174 /****************************************************************************/
//  175 
//  176 /* Call this once, before calling any other NV function.
//  177  *
//  178  * Any page that does not contain a valid, recognized data set is erased, in
//  179  * preparation for later reuse.
//  180  *
//  181  * It is unlikely, but possible, that there could be more than one copy of one
//  182  * or more data sets in NV storage. Normally the page containing the older
//  183  * version is erased after the new version is written, but a reset at just
//  184  * the wrong time could prevent the erasure.
//  185  *
//  186  * Having more than one copy of any data set is 1) unnecessary, 2) uses space
//  187  * that may be needed for future writes, and 3) would complicate other NV code.
//  188  * This function scans NV storage for alternate versions of the same data set,
//  189  * and if it finds one, erases the older copy (or copies).
//  190  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  191 void NvModuleInit(void)
//  192 {
NvModuleInit:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+28
//  193 #if gNvStorageIncluded_d
//  194 #if gNvDebug_d
//  195   NvDataItemDescription_t const *pDataItemDescriptions;
//  196   index_t dataSetIndex;
//  197   NvSize_t dataSetSize;
//  198 #endif
//  199   index_t i;
//  200   index_t sectorIndex;
//  201   NvRawSectorAddress_t      oldSectAddress , newSectAddress;
//  202   NvSectorSequenceNumber_t  oldSectSeq , newSectSeq;
//  203   NvSectPageInfo_t oldSectPageInfo ,  newSectPageInfo;
//  204   NvRawPageAddress_t firstBlankPageAddress;
//  205   index_t firstBlankPageIndex;
//  206   
//  207 #if gNvDebug_d
//  208   /* The CodeWarrior HCS08 compiler complains about constant == constant. */
//  209   uint16_t NvMaxDataSetSize = gNvMaxDataSetSize_c;
//  210 #endif
//  211   /* Power up the NVM */
//  212   PowerUpNVM();
        BL       PowerUpNVM
//  213   /* initialize flash layer */
//  214   NvHalInit();
        BL       NvHalInit
//  215   
//  216   /* No data set starts dirty. */
//  217   for (i = 0; i < gNvNumberOfDataSets_c; ++i)
        MOVS     R0,#+0
        MOVS     R5,R0
??NvModuleInit_0:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BCS      ??NvModuleInit_1
//  218   {
//  219     maNvDirtyFlags[i].saveNextInterval = FALSE;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable5_1
        MOVS     R2,#+0
        STRB     R2,[R1, R0]
//  220     maNvDirtyFlags[i].countsToNextSave = gNvCountsBetweenSaves;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable5_1
        ADDS     R0,R1,R0
        LDR      R1,??DataTable7
        LDRH     R1,[R1, #+0]
        STRH     R1,[R0, #+4]
//  221   }
        ADDS     R5,R5,#+1
        B        ??NvModuleInit_0
//  222   
//  223   /* Scan for and erase duplicate copies of data sets. This code is very */
//  224   /* slow (N^2), but it only runs once, and N is small. Data set IDs are */
//  225   /* arbitrary values, so its necessary to search through the list. */
//  226   
//  227   /* Visit every raw page. If it isn't a valid data set, and it isn't clean, */
//  228   /* erase it. */
//  229   
//  230   newSectAddress = gUninitAddress;
??NvModuleInit_1:
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
        MOVS     R6,R0
//  231   for (sectorIndex = 0; sectorIndex < gNvNumberOfRawSectors_c; ++sectorIndex)
        MOVS     R0,#+0
        MOVS     R4,R0
??NvModuleInit_2:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvModuleInit_3
//  232   {
//  233     
//  234     if (!NvIsValidSector(maNvRawSectorAddressTable[sectorIndex])) 
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        BL       NvIsValidSector
        CMP      R0,#+0
        BNE      ??NvModuleInit_4
//  235     {
//  236       if( !NvHalIsBlank(maNvRawSectorAddressTable[sectorIndex] , 0 , sizeof(NvRawSector_t)) )
        MOVS     R2,#+128
        LSLS     R2,R2,#+5        ;; #+4096
        MOVS     R1,#+0
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R3,??DataTable8
        LDR      R0,[R3, R0]
        BL       NvHalIsBlank
        CMP      R0,#+0
        BNE      ??NvModuleInit_5
//  237       {
//  238         NvHalEraseSector(maNvRawSectorAddressTable[sectorIndex]);
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        BL       NvHalEraseSector
        B        ??NvModuleInit_5
//  239       }
//  240     } 
//  241     else
//  242     {
//  243       if(newSectAddress != gUninitAddress )
??NvModuleInit_4:
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
        CMP      R6,R0
        BEQ      ??NvModuleInit_6
//  244       {
//  245         newSectSeq = NvGetSectorSequenceNumber(newSectAddress);
        MOVS     R0,R6
        BL       NvGetSectorSequenceNumber
        MOV      R1,SP
        STRB     R0,[R1, #+6]
//  246         oldSectSeq =   NvGetSectorSequenceNumber(maNvRawSectorAddressTable[sectorIndex]);
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        BL       NvGetSectorSequenceNumber
        MOV      R1,SP
        STRB     R0,[R1, #+4]
//  247         if(oldSectSeq ==  NvLastSectorSequence ( newSectSeq ,oldSectSeq )  )
        MOV      R0,SP
        LDRB     R1,[R0, #+4]
        STR      R1,[SP, #+0]
        MOV      R0,SP
        LDRB     R1,[R0, #+4]
        MOV      R0,SP
        LDRB     R0,[R0, #+6]
        BL       NvLastSectorSequence
        LDR      R1,[SP, #+0]
        CMP      R1,R0
        BNE      ??NvModuleInit_7
//  248         {
//  249           oldSectAddress = newSectAddress ;
        MOVS     R7,R6
//  250           newSectAddress = maNvRawSectorAddressTable[sectorIndex];
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        MOVS     R6,R0
        B        ??NvModuleInit_8
//  251         }
//  252         else
//  253         {
//  254           oldSectAddress = maNvRawSectorAddressTable[sectorIndex];
??NvModuleInit_7:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        MOVS     R7,R0
//  255         }
//  256         NvGetSectorPageInfo ( newSectAddress, &newSectPageInfo );
??NvModuleInit_8:
        ADD      R1,SP,#+12
        MOVS     R0,R6
        BL       NvGetSectorPageInfo
//  257         NvGetSectorPageInfo ( oldSectAddress, &oldSectPageInfo );
        ADD      R1,SP,#+20
        MOVS     R0,R7
        BL       NvGetSectorPageInfo
//  258         NvGetFirstBlankPageInfo ( newSectAddress , &firstBlankPageAddress, &firstBlankPageIndex );
        ADD      R2,SP,#+4
        ADDS     R2,R2,#+1
        ADD      R1,SP,#+8
        MOVS     R0,R6
        BL       NvGetFirstBlankPageInfo
//  259         if( NvCopyTheRemainsDataSets(  &oldSectPageInfo , &newSectPageInfo, firstBlankPageAddress,firstBlankPageIndex))
        MOV      R0,SP
        LDRB     R3,[R0, #+5]
        LDR      R2,[SP, #+8]
        ADD      R1,SP,#+12
        ADD      R0,SP,#+20
        BL       NvCopyTheRemainsDataSets
        CMP      R0,#+0
        BEQ      ??NvModuleInit_9
//  260         {
//  261           // copy of te rest of data sets failed
//  262           NvHalEraseSector(newSectAddress);
        MOVS     R0,R6
        BL       NvHalEraseSector
//  263           newSectAddress = oldSectAddress;
        MOVS     R6,R7
        B        ??NvModuleInit_5
//  264         }
//  265         else
//  266         {
//  267           NvHalEraseSector(oldSectAddress);
??NvModuleInit_9:
        MOVS     R0,R7
        BL       NvHalEraseSector
        B        ??NvModuleInit_5
//  268         }
//  269       }
//  270       else // if(newSectAddress != gUninitAddress )
//  271       {
//  272         newSectAddress = maNvRawSectorAddressTable[sectorIndex];
??NvModuleInit_6:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        MOVS     R6,R0
//  273       }
//  274     }                                   /* if (!NvIsValidDataSet(... else */
//  275   }
??NvModuleInit_5:
        ADDS     R4,R4,#+1
        B        ??NvModuleInit_2
//  276   
//  277   
//  278   
//  279   
//  280   /* for (pageIndex = 0; ... */
//  281   
//  282 #if gNvDebug_d
//  283   /* NVM_Interface.h defines the size of the client area of a page as an */
//  284   /* unjustified immediate integer constant. Make sure that its correct. */
//  285   /* Assert if it isn't. */
//  286   if (NvMaxDataSetSize != MbrSizeof(NvStructuredPage_t, clientData)) {
//  287     for (;;)
//  288     { }
//  289   }
//  290   
//  291   /* Verify that all of the data sets defined by the client code will */
//  292   /* fit into the NV storage page size. Doing this once here simplifies */
//  293   /* other code. */
//  294   for (dataSetIndex = 0; dataSetIndex < gNvNumberOfDataSets_c; ++dataSetIndex) {
//  295     pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
//  296     if (!pDataItemDescriptions) {
//  297       continue;
//  298     }
//  299     dataSetSize = 0;
//  300     
//  301     while (pDataItemDescriptions->length) {
//  302       dataSetSize += pDataItemDescriptions->length;
//  303       ++pDataItemDescriptions;
//  304     }
//  305     
//  306     /* Assert if the data set is too big. */
//  307     if (dataSetSize > MbrSizeof(NvStructuredPage_t, clientData)) {
//  308       for (;;)
//  309       { }
//  310     }
//  311   }
//  312 #endif                                  /* #if gNvDebug_d */
//  313   
//  314   /* Power down the NVM */
//  315   PowerDownNVM();
??NvModuleInit_3:
        BL       PowerDownNVM
//  316   
//  317 #if gNvSelfTest_d
//  318   NvSelfTest();
//  319 #endif
//  320 #endif                                  /* #if gNvStorageIncluded_d */
//  321 }                                       /* NvModuleInit() */
        ADD      SP,SP,#+28
        POP      {R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  322 
//  323 /****************************************************************************/
//  324 
//  325 /* Search for a specific data structure in NV storage, delimited by a known
//  326  * string at the beginning and end of the struct, and a known structure length.
//  327  * The length includes both strings. The "strings" contain arbitrary bytes;
//  328  * they are not assumed to be null-terminated C strings.
//  329  *
//  330  * This function is only indended for use by by the early startup code (crt0
//  331  * and PlatformInit), which needs to find a struct containing hardware
//  332  * initialization values.
//  333  *
//  334  * At that point in the startup process, the stack is available, but no data
//  335  * in RAM has been initialized yet. ONLY const data (in ROM) is dependable.
//  336  * NvModuleInit() has not been called yet to initialize this module. Be very
//  337  * careful about calling local functions.
//  338  * NvHalInit() has not been called yet. Do not call HAL functions, directly
//  339  * or indirectly.
//  340  *
//  341  * Return a pointer to the NV storage copy of the data if found.
//  342  * Return NULL if not found.
//  343  */
//  344 //void const *pNvPrimitiveSearch

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  345 uint32_t NvPrimitiveSearch
//  346   (
//  347   unsigned char *pDelimiterString,
//  348   index_t delimiterStringLen,
//  349   NvSize_t totalStructLen
//  350   )
//  351 {
NvPrimitiveSearch:
        PUSH     {R0-R2,R4-R7,LR}
        SUB      SP,SP,#+16
//  352 #if !gNvStorageIncluded_d
//  353   (void) pDelimiterString;
//  354   (void) delimiterStringLen;
//  355   (void) totalStructLen;
//  356   return 0;
//  357 #else
//  358   NvSize_t lastStartingOffset;
//  359   index_t pageIndex;
//  360   NvSize_t pageOffset;
//  361   index_t sectorIndex;
//  362   NvSectPageInfo_t sectPageInfo;
//  363   NvRawPageAddress_t pageAddress;
//  364   /* If the first string isn't found by lastStartingOffset, the struct */
//  365   /* is not present in the page. */
//  366   lastStartingOffset = sizeof(NvRawPage_t)
//  367                      - sizeof(NvStructuredPageHeader_t)     /* Trailer. */
//  368                      - totalStructLen;
        MOV      R0,SP
        MOVS     R1,#+253
        LSLS     R1,R1,#+1        ;; #+506
        MOV      R2,SP
        LDRH     R2,[R2, #+24]
        SUBS     R1,R1,R2
        STRH     R1,[R0, #+0]
//  369   /* Power up the NVM */
//  370   PowerUpNVM();
        BL       PowerUpNVM
//  371   /* Scan the NV storage pages. Invalid pages are ignored. */
//  372     for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
        MOVS     R0,#+0
        MOVS     R5,R0
??NvPrimitiveSearch_0:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BCS      ??NvPrimitiveSearch_1
//  373        {
//  374         if(NvIsValidSector(maNvRawSectorAddressTable[sectorIndex]))
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        BL       NvIsValidSector
        CMP      R0,#+0
        BNE      ??NvPrimitiveSearch_1
//  375          {
//  376           break;
//  377          }
//  378        }
??NvPrimitiveSearch_2:
        ADDS     R5,R5,#+1
        B        ??NvPrimitiveSearch_0
//  379     if(sectorIndex == gNvNumberOfRawSectors_c)
??NvPrimitiveSearch_1:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BNE      ??NvPrimitiveSearch_3
//  380       {
//  381        PowerDownNVM();
        BL       PowerDownNVM
//  382        return 0;
        MOVS     R0,#+0
        B        ??NvPrimitiveSearch_4
//  383       }
//  384     NvGetSectorPageInfo ( maNvRawSectorAddressTable[sectorIndex], &sectPageInfo );
??NvPrimitiveSearch_3:
        ADD      R1,SP,#+4
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R2,??DataTable8
        LDR      R0,[R2, R0]
        BL       NvGetSectorPageInfo
//  385     
//  386     for(pageIndex = 0; pageIndex < gNvNumberOfDataSets_c; pageIndex++)
        MOVS     R0,#+0
        MOVS     R6,R0
??NvPrimitiveSearch_5:
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        CMP      R6,#+2
        BCS      ??NvPrimitiveSearch_6
//  387       {
//  388          if(sectPageInfo[pageIndex] != gUninitAddress)
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MOVS     R0,#+4
        MULS     R0,R6,R0
        ADD      R1,SP,#+4
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BEQ      ??NvPrimitiveSearch_7
//  389          {
//  390             pageAddress = sectPageInfo[pageIndex];
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MOVS     R0,#+4
        MULS     R0,R6,R0
        ADD      R1,SP,#+4
        LDR      R0,[R1, R0]
        MOVS     R7,R0
//  391             for (pageOffset = sizeof(NvStructuredPageHeader_t); pageOffset <= lastStartingOffset;  ++pageOffset)
        MOVS     R0,#+2
        MOVS     R4,R0
??NvPrimitiveSearch_8:
        MOV      R0,SP
        LDRH     R0,[R0, #+0]
        LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
        LSRS     R4,R4,#+16
        CMP      R0,R4
        BCC      ??NvPrimitiveSearch_7
//  392                {               	
//  393 
//  394                if (NvHalVerify(pageAddress,pageOffset,pDelimiterString,delimiterStringLen )
//  395                 && NvHalVerify(pageAddress,pageOffset+totalStructLen - delimiterStringLen,pDelimiterString,delimiterStringLen ))
        MOV      R0,SP
        LDRB     R3,[R0, #+20]
        LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
        LSRS     R3,R3,#+16
        LDR      R2,[SP, #+16]
        MOVS     R1,R4
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R7
        BL       NvHalVerify
        CMP      R0,#+0
        BEQ      ??NvPrimitiveSearch_9
        MOV      R0,SP
        LDRB     R3,[R0, #+20]
        LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
        LSRS     R3,R3,#+16
        LDR      R2,[SP, #+16]
        MOV      R0,SP
        LDRH     R0,[R0, #+24]
        ADDS     R0,R4,R0
        MOV      R1,SP
        LDRB     R1,[R1, #+20]
        SUBS     R1,R0,R1
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R7
        BL       NvHalVerify
        CMP      R0,#+0
        BEQ      ??NvPrimitiveSearch_9
//  396                    {
//  397                        /* Power down the NVM */
//  398                      PowerDownNVM();
        BL       PowerDownNVM
//  399                      return pageAddress + pageOffset;
        LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
        LSRS     R4,R4,#+16
        ADDS     R0,R7,R4
        B        ??NvPrimitiveSearch_4
//  400           
//  401                    }                               /* if (NvHalVerify(pageIndex,pag ... */
//  402                }                                   /* for (pageOffset = sizeof ... */
??NvPrimitiveSearch_9:
        ADDS     R4,R4,#+1
        B        ??NvPrimitiveSearch_8
//  403            
//  404          }
//  405       }
??NvPrimitiveSearch_7:
        ADDS     R6,R6,#+1
        B        ??NvPrimitiveSearch_5
//  406     
//  407   
//  408   /* Power down the NVM */
//  409   PowerDownNVM();
??NvPrimitiveSearch_6:
        BL       PowerDownNVM
//  410   return 0;
        MOVS     R0,#+0
??NvPrimitiveSearch_4:
        ADD      SP,SP,#+28
        POP      {R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  411 #endif                                  /* #if !gNvStorageIncluded_d #else */
//  412 }                                       /* pNvPrimitiveSearch() */

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5:
        DC32     mNvCriticalSectionFlag

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable5_1:
        DC32     maNvDirtyFlags
//  413 
//  414                                        /* NvRestoreDataSet() */
//  415 
//  416 /****************************************************************************/
//  417 
//  418 /* Copy the most recent version of a data set from NV storage to RAM. */
//  419 /* Note that the copy will succeed if a valid copy of the data set is found */
//  420 /* in NV storage, regardless of the state of the data set's dirty flag. */
//  421 /* Return TRUE if the copy is successful. */
//  422 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  423 bool_t NvRestoreDataSet
//  424   (
//  425   NvDataSetID_t dataSetID
//  426  )
//  427 {
NvRestoreDataSet:
        PUSH     {R0,R4-R7,LR}
        SUB      SP,SP,#+16
//  428 #if !gNvStorageIncluded_d
//  429   (void) dataSetID;
//  430   return FALSE;
//  431 #else
//  432   NvDataItemDescription_t const *pDataItemDescriptions;
//  433   index_t dataSetIndex;
//  434   index_t sectorIndex;
//  435   NvRawSectorAddress_t sectorAddress;
//  436   NvSectPageInfo_t sectPageInfo;
//  437   NvSize_t pageOffset;
//  438   /* Power up the NVM */
//  439   PowerUpNVM();
        BL       PowerUpNVM
//  440   /* Find the data set description. */
//  441   dataSetIndex = NvDataSetIndexFromID(dataSetID);
        MOV      R0,SP
        LDRB     R0,[R0, #+16]
        BL       NvDataSetIndexFromID
        MOVS     R7,R0
//  442   
//  443   for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
        MOVS     R0,#+0
        MOVS     R4,R0
??NvRestoreDataSet_0:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvRestoreDataSet_1
//  444        {
//  445        sectorAddress = maNvRawSectorAddressTable[sectorIndex];  
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable8
        LDR      R0,[R1, R0]
        STR      R0,[SP, #+0]
//  446        if(NvIsValidSector(sectorAddress))
        LDR      R0,[SP, #+0]
        BL       NvIsValidSector
        CMP      R0,#+0
        BNE      ??NvRestoreDataSet_1
//  447          {
//  448           break;
//  449          }
//  450        }
??NvRestoreDataSet_2:
        ADDS     R4,R4,#+1
        B        ??NvRestoreDataSet_0
//  451   if(sectorIndex == gNvNumberOfRawSectors_c)
??NvRestoreDataSet_1:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BNE      ??NvRestoreDataSet_3
//  452   {
//  453     // there are no valid sectors
//  454     PowerDownNVM(); 
        BL       PowerDownNVM
//  455     return FALSE;
        MOVS     R0,#+0
        B        ??NvRestoreDataSet_4
//  456   }
//  457 
//  458   NvGetSectorPageInfo(sectorAddress , &sectPageInfo);
??NvRestoreDataSet_3:
        ADD      R1,SP,#+4
        LDR      R0,[SP, #+0]
        BL       NvGetSectorPageInfo
//  459   if(sectPageInfo[dataSetIndex] == gUninitAddress)
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R0,#+4
        MULS     R0,R7,R0
        ADD      R1,SP,#+4
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BNE      ??NvRestoreDataSet_5
//  460   {
//  461     // the page does not exist in the valid sector
//  462     PowerDownNVM(); 
        BL       PowerDownNVM
//  463     return FALSE;
        MOVS     R0,#+0
        B        ??NvRestoreDataSet_4
//  464   }
//  465   pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
??NvRestoreDataSet_5:
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R0,#+8
        MULS     R0,R7,R0
        LDR      R1,??DataTable17
        ADDS     R0,R1,R0
        LDR      R0,[R0, #+4]
        MOVS     R6,R0
//  466 
//  467   /* Start reading just after the page header. */
//  468   pageOffset = sizeof(NvStructuredPageHeader_t);
        MOVS     R0,#+2
        MOVS     R5,R0
//  469 
//  470   /* Copy data from the NV storage page to the destination data set. */
//  471   while (pDataItemDescriptions->length)
??NvRestoreDataSet_6:
        LDRH     R0,[R6, #+4]
        CMP      R0,#+0
        BEQ      ??NvRestoreDataSet_7
//  472   {
//  473     NvHalRead(sectPageInfo[dataSetIndex], pageOffset, (uint8_t*)pDataItemDescriptions->pointer, pDataItemDescriptions->length);
        LDRH     R3,[R6, #+4]
        LDR      R2,[R6, #+0]
        MOVS     R1,R5
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R5,R1
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R1,#+4
        MULS     R1,R7,R1
        ADD      R0,SP,#+4
        LDR      R0,[R0, R1]
        MOVS     R1,R5
        BL       NvHalRead
//  474     pageOffset += pDataItemDescriptions->length;
        LDRH     R0,[R6, #+4]
        ADDS     R5,R5,R0
//  475     ++pDataItemDescriptions;
        ADDS     R6,R6,#+8
        B        ??NvRestoreDataSet_6
//  476   }
//  477 
//  478   maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
??NvRestoreDataSet_7:
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R0,#+6
        MULS     R0,R7,R0
        LDR      R1,??DataTable7_1
        MOVS     R2,#+0
        STRB     R2,[R1, R0]
//  479   maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R0,#+6
        MULS     R0,R7,R0
        LDR      R1,??DataTable7_1
        ADDS     R0,R1,R0
        MOVS     R1,#+128
        LSLS     R1,R1,#+1        ;; #+256
        STRH     R1,[R0, #+4]
//  480   /* Power down the NVM */
//  481   PowerDownNVM();
        BL       PowerDownNVM
//  482   return TRUE;
        MOVS     R0,#+1
??NvRestoreDataSet_4:
        ADD      SP,SP,#+20
        POP      {R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  483 #endif                                  /* #if !gNvStorageIncluded_d #else */
//  484 }
//  485 /****************************************************************************/
//  486 
//  487 /* Save the data set on the next call to NvIdle(). */
//  488 /* Use the save-on-count mechanism. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  489 void NvSaveOnIdle
//  490   (
//  491   NvDataSetID_t dataSetID
//  492  )
//  493 {
NvSaveOnIdle:
        PUSH     {R4,LR}
        MOVS     R4,R0
//  494 #if !gNvStorageIncluded_d
//  495   (void) dataSetID;
//  496 #else
//  497   maNvDirtyFlags[NvDataSetIndexFromID(dataSetID)].countsToNextSave = 0;
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvDataSetIndexFromID
        MOVS     R1,#+6
        MULS     R0,R1,R0
        LDR      R1,??DataTable18
        ADDS     R0,R1,R0
        MOVS     R1,#+0
        STRH     R1,[R0, #+4]
//  498 #endif
//  499 }
        POP      {R4}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable7:
        DC32     gNvCountsBetweenSaves

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable7_1:
        DC32     maNvDirtyFlags
//  500 
//  501 /****************************************************************************/
//  502 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  503 void NvSaveOnInterval
//  504   (
//  505   NvDataSetID_t dataSetID
//  506  )
//  507 {
NvSaveOnInterval:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  508 #if !gNvStorageIncluded_d
//  509   (void) dataSetID;
//  510 #else
//  511   index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvDataSetIndexFromID
        MOVS     R5,R0
//  512 
//  513   if (!maNvDirtyFlags[dataSetIndex].saveNextInterval) {
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable18
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BNE      ??NvSaveOnInterval_0
//  514     maNvDirtyFlags[dataSetIndex].ticksToNextSave  = gNvMinimumTicksBetweenSaves_c;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable18
        ADDS     R0,R1,R0
        MOVS     R1,#+4
        STRH     R1,[R0, #+2]
//  515     maNvDirtyFlags[dataSetIndex].saveNextInterval = TRUE;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable18
        MOVS     R2,#+1
        STRB     R2,[R1, R0]
//  516     TS_SendEvent(gIdleTaskID, gIdleTaskNVIntervalEvent_c);  
        MOVS     R1,#+1
        LDR      R0,??DataTable18_1
        LDRB     R0,[R0, #+0]
        BL       TS_SendEvent
//  517   }
//  518 #endif
//  519 }                                       /* NvSaveOnInterval() */
??NvSaveOnInterval_0:
        POP      {R0,R4,R5}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable8:
        DC32     maNvRawSectorAddressTable
//  520 
//  521 /****************************************************************************/
//  522 
//  523 /* Decrement the counter. Once it reaches 0, the next call to NvIdle() will */
//  524 /* save the data set. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  525 void NvSaveOnCount
//  526   (
//  527   NvDataSetID_t dataSetID
//  528   )
//  529 {
NvSaveOnCount:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  530 #if !gNvStorageIncluded_d
//  531   (void) dataSetID;
//  532 #else
//  533   index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvDataSetIndexFromID
        MOVS     R5,R0
//  534 
//  535   if (maNvDirtyFlags[dataSetIndex].countsToNextSave) {
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable18
        ADDS     R0,R1,R0
        LDRH     R0,[R0, #+4]
        CMP      R0,#+0
        BEQ      ??NvSaveOnCount_0
//  536     --maNvDirtyFlags[dataSetIndex].countsToNextSave;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+6
        MULS     R0,R5,R0
        LDR      R1,??DataTable18
        ADDS     R0,R1,R0
        LDRH     R0,[R0, #+4]
        SUBS     R0,R0,#+1
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R1,#+6
        MULS     R1,R5,R1
        LDR      R2,??DataTable18
        ADDS     R1,R2,R1
        STRH     R0,[R1, #+4]
//  537   }
//  538 #endif
//  539 }                                       /* NvSaveOnCount() */
??NvSaveOnCount_0:
        POP      {R0,R4,R5}
        POP      {R3}
        BX       R3               ;; return
//  540 
//  541 /****************************************************************************/
//  542 
//  543 /* Set the timer used by NvSaveOnInterval(). Takes effect after the next */
//  544 /* save. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  545 void NvSetMinimumTicksBetweenSaves
//  546   (
//  547   NvSaveInterval_t newInterval
//  548  )
//  549 {
//  550 #if !gNvStorageIncluded_d
//  551   (void) newInterval;
//  552 #else
//  553   gNvMinimumTicksBetweenSaves = newInterval;
NvSetMinimumTicksBetweenSaves:
        LDR      R1,??DataTable18_2
        STRH     R0,[R1, #+0]
//  554 #endif
//  555 }                                       /* NvSetMinimumTicksBetweenSaves() */
        BX       LR               ;; return
//  556 
//  557 /****************************************************************************/
//  558 
//  559 /* Set the counter trigger value used by NvSaveOnCount(). Takes effect */
//  560 /* after the next save. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  561 void NvSetCountsBetweenSaves
//  562   (
//  563   NvSaveCounter_t newCounter
//  564  )
//  565 {
//  566 #if !gNvStorageIncluded_d
//  567   (void) newCounter;
//  568 #else
//  569   gNvCountsBetweenSaves = newCounter;
NvSetCountsBetweenSaves:
        LDR      R1,??DataTable18_3
        STRH     R0,[R1, #+0]
//  570 #endif
//  571 }                                       /* NvSetCountsBetweenSaves() */
        BX       LR               ;; return
//  572 
//  573 /****************************************************************************/
//  574 
//  575 /* Called from the idle task to process save-on-interval requests. */
//  576 /* Returns FALSE if the timer tick counters for all data sets have reached */
//  577 /* zero. In this case, the timer can be turned off. */
//  578 /* Returns TRUE if any of the data sets' timer tick counters have not yet */
//  579 /* counted down to zero. In this case, the timer should be active. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  580 bool_t NvTimerTick(bool_t countTick)
//  581 {
NvTimerTick:
        PUSH     {R3-R7,LR}
        MOVS     R7,R0
//  582 #if !gNvStorageIncluded_d
//  583   (void) countTick;
//  584   return FALSE;
//  585 #else
//  586   index_t i;
//  587   bool_t fTicksLeft = FALSE;
        MOVS     R0,#+0
        MOVS     R5,R0
//  588   NvDataSetInfo_t *pDirtyFlags;
//  589 
//  590   if (countTick) {
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        CMP      R7,#+0
        BEQ      ??NvTimerTick_0
//  591     pDirtyFlags = maNvDirtyFlags;
        LDR      R0,??DataTable18
        MOVS     R6,R0
//  592     for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
        MOVS     R0,#+0
        MOVS     R4,R0
??NvTimerTick_1:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvTimerTick_0
//  593       
//  594       if(pDirtyFlags->ticksToNextSave)
        LDRH     R0,[R6, #+2]
        CMP      R0,#+0
        BEQ      ??NvTimerTick_2
//  595         --(pDirtyFlags->ticksToNextSave);
        LDRH     R0,[R6, #+2]
        SUBS     R0,R0,#+1
        STRH     R0,[R6, #+2]
//  596       if(pDirtyFlags->ticksToNextSave)
??NvTimerTick_2:
        LDRH     R0,[R6, #+2]
        CMP      R0,#+0
        BEQ      ??NvTimerTick_3
//  597         fTicksLeft = TRUE;
        MOVS     R0,#+1
        MOVS     R5,R0
//  598 
//  599       if (pDirtyFlags->saveNextInterval
//  600           && !pDirtyFlags->ticksToNextSave
//  601           && !mNvCriticalSectionFlag) {
??NvTimerTick_3:
        LDRB     R0,[R6, #+0]
        CMP      R0,#+0
        BEQ      ??NvTimerTick_4
        LDRH     R0,[R6, #+2]
        CMP      R0,#+0
        BNE      ??NvTimerTick_4
        LDR      R0,??DataTable18_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??NvTimerTick_4
//  602         NvSaveDataSet(i);
        MOVS     R0,R4
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        BL       NvSaveDataSet
//  603       }
//  604 
//  605       ++pDirtyFlags;
??NvTimerTick_4:
        ADDS     R6,R6,#+6
//  606     }
        ADDS     R4,R4,#+1
        B        ??NvTimerTick_1
//  607   }
//  608 
//  609   return fTicksLeft;
??NvTimerTick_0:
        MOVS     R0,R5
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        POP      {R1,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  610 #endif
//  611 }                                       /* NvTimerTick() */
//  612 
//  613 /*****************************************************************************
//  614 ******************************************************************************
//  615 * Private functions
//  616 ******************************************************************************
//  617 *****************************************************************************/
//  618 /*****************************************************************************
//  619 *  PowerUpNVM - Turns on the NVM voltage regulator
//  620 ******************************************************************************/
//  621 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  622 void PowerUpNVM(void)
//  623 {
PowerUpNVM:
        PUSH     {LR}
        SUB      SP,SP,#+12
//  624   crmVRegCntl_t VRegCntl;
//  625 
//  626   VRegCntl.vReg = g1P8VReg_c;
        MOV      R0,SP
        MOVS     R1,#+2
        STRB     R1,[R0, #+0]
//  627   VRegCntl.cntl.vReg1P8VEn =1;
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+4]
//  628   CRM_VRegCntl(&VRegCntl);
        MOV      R0,SP
        BL       CRM_VRegCntl
//  629   while(!CRM_VRegIsReady(V_REG_MASK_1P8V)){};
??PowerUpNVM_0:
        LDR      R0,??DataTable19  ;; 0x80003018
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        LSLS     R1,R1,#+13       ;; ZeroExtS R1,R1,#+13,#+31
        LSRS     R1,R1,#+31
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??PowerUpNVM_0
//  630 }
        POP      {R0-R3}
        BX       R3               ;; return
//  631 
//  632 /*****************************************************************************
//  633 *  PowerDownNVM - Turns off the NVM voltage regulator
//  634 ******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  635 void PowerDownNVM(void)
//  636 {
PowerDownNVM:
        PUSH     {LR}
        SUB      SP,SP,#+12
//  637   crmVRegCntl_t VRegCntl;
//  638 
//  639   VRegCntl.vReg = g1P8VReg_c;
        MOV      R0,SP
        MOVS     R1,#+2
        STRB     R1,[R0, #+0]
//  640   VRegCntl.cntl.vReg1P8VEn =0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+4]
//  641   CRM_VRegCntl(&VRegCntl);
        MOV      R0,SP
        BL       CRM_VRegCntl
//  642 }
        POP      {R0-R3}
        BX       R3               ;; return
//  643 
//  644 
//  645 /****************************************************************************/
//  646 
//  647 /* Given a data set ID, return it's index in the NvDataSetTable[].
//  648  * Data set IDs are arbitrary values, so they have to be searched for.
//  649  */
//  650 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  651 static index_t NvDataSetIndexFromID
//  652   (
//  653   NvDataSetID_t dataSetID
//  654  )
//  655 {
NvDataSetIndexFromID:
        PUSH     {LR}
        MOVS     R1,R0
//  656   index_t i;
//  657 
//  658   for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
        MOVS     R2,#+0
        MOVS     R0,R2
??NvDataSetIndexFromID_0:
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+2
        BCS      ??NvDataSetIndexFromID_1
//  659     if (NvDataSetTable[i].pItemDescriptions
//  660          && (NvDataSetTable[i].dataSetID == dataSetID)) {
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        MOVS     R2,#+8
        MULS     R2,R0,R2
        LDR      R3,??DataTable17
        ADDS     R2,R3,R2
        LDR      R2,[R2, #+4]
        CMP      R2,#+0
        BEQ      ??NvDataSetIndexFromID_2
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        MOVS     R2,#+8
        MULS     R2,R0,R2
        LDR      R3,??DataTable17
        LDRB     R2,[R3, R2]
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R2,R1
        BNE      ??NvDataSetIndexFromID_2
//  661       return i;
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        B        ??NvDataSetIndexFromID_3
//  662     }
//  663   }
??NvDataSetIndexFromID_2:
        ADDS     R0,R0,#+1
        B        ??NvDataSetIndexFromID_0
//  664 
//  665   /* Can't find it. Must be a programming error in the caller. There's */
//  666   /* no good way to handle errors, but at least this makes it obvious */
//  667   /* during debugging. */
//  668   for (;;) { }
??NvDataSetIndexFromID_1:
        B        ??NvDataSetIndexFromID_1
??NvDataSetIndexFromID_3:
        POP      {R3}
        BX       R3               ;; return
//  669 }                                       /* NvDataSetIndexFromID() */
//  670 #endif                                  /* #if gNvStorageIncluded_d */
//  671 
//  672 
//  673 /****************************************************************************/
//  674 
//  675 /* Examine an NV storage page. Check the magic number, check that the header
//  676  * and trailer match, and check that the data set ID is recognized by the
//  677  * application's table of data set descriptions.
//  678  * Return TRUE if it looks legit; FALSE otherwise.
//  679  */
//  680 
//  681 
//  682 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  683 static bool_t NvIsValidPage
//  684   (
//  685   NvRawPageAddress_t nvRawPageAddress , NvDataSetID_t *pDataSetID
//  686   )
//  687 {
NvIsValidPage:
        PUSH     {R3-R7,LR}
        MOVS     R5,R0
        MOVS     R7,R1
//  688   bool_t legitDataSetID;
//  689   index_t i;
//  690   NvStructuredPageHeader_t pageHeader;
//  691   
//  692   NvHalRead(nvRawPageAddress,0,(unsigned char*)&pageHeader,sizeof(NvStructuredPageHeader_t));
        MOVS     R3,#+2
        MOV      R2,SP
        MOVS     R1,#+0
        MOVS     R0,R5
        BL       NvHalRead
//  693    
//  694 
//  695   /* Is the data set ID legit? */
//  696   for (legitDataSetID = FALSE, i = 0; i < gNvNumberOfDataSets_c; ++i) 
        MOVS     R0,#+0
        MOVS     R6,R0
        MOVS     R0,#+0
        MOVS     R4,R0
??NvIsValidPage_0:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvIsValidPage_1
//  697     {
//  698     if(NvDataSetTable[i].dataSetID && (NvDataSetTable[i].dataSetID == pageHeader.dataSetID)) 
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+8
        MULS     R0,R4,R0
        LDR      R1,??DataTable17
        LDRB     R0,[R1, R0]
        CMP      R0,#+0
        BEQ      ??NvIsValidPage_2
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+8
        MULS     R0,R4,R0
        LDR      R1,??DataTable17
        LDRB     R0,[R1, R0]
        MOV      R1,SP
        LDRB     R1,[R1, #+1]
        CMP      R0,R1
        BNE      ??NvIsValidPage_2
//  699       {
//  700       legitDataSetID = TRUE;
        MOVS     R0,#+1
        MOVS     R6,R0
//  701       *pDataSetID = pageHeader.dataSetID;
        MOV      R0,SP
        LDRB     R0,[R0, #+1]
        STRB     R0,[R7, #+0]
//  702       break;
        B        ??NvIsValidPage_1
//  703       }
//  704     }
??NvIsValidPage_2:
        ADDS     R4,R4,#+1
        B        ??NvIsValidPage_0
//  705 
//  706   /* Do the header and trailer match? */
//  707   /* Is the magic number legit? */
//  708   if (legitDataSetID
//  709        && NvHalVerify( nvRawPageAddress , sizeof(NvRawPage_t)- sizeof(NvStructuredPageHeader_t),(unsigned char*)&pageHeader,sizeof(NvStructuredPageHeader_t))
//  710   
//  711  
//  712        && (pageHeader.magicNumber == mNvMagicNumber_c)) {
??NvIsValidPage_1:
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        CMP      R6,#+0
        BEQ      ??NvIsValidPage_3
        MOVS     R3,#+2
        MOV      R2,SP
        MOVS     R1,#+253
        LSLS     R1,R1,#+1        ;; #+506
        MOVS     R0,R5
        BL       NvHalVerify
        CMP      R0,#+0
        BEQ      ??NvIsValidPage_3
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+39
        BNE      ??NvIsValidPage_3
//  713     return TRUE;
        MOVS     R0,#+1
        B        ??NvIsValidPage_4
//  714   }
//  715 
//  716   return FALSE;
??NvIsValidPage_3:
        MOVS     R0,#+0
??NvIsValidPage_4:
        POP      {R1,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  717 }                                       /* NvIsValidDataSet() */
//  718 #endif                                  /* #if gNvStorageIncluded_d */
//  719 /****************************************************************************/
//  720 
//  721 /* Examine an NV sector. Check the magic number, check that the header
//  722  * and trailer match
//  723  * Return TRUE if it looks legit; FALSE otherwise.
//  724  */
//  725 
//  726 /********************************************************/
//  727 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  728 static bool_t NvIsValidSector
//  729   (
//  730   NvRawSectorAddress_t nvRawSectorAddress
//  731   )
//  732 {
NvIsValidSector:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  733 
//  734   NvStructuredSectorHeader_t sectorHeader;
//  735   
//  736   NvHalRead(nvRawSectorAddress,0,(unsigned char*)&sectorHeader,sizeof(NvStructuredSectorHeader_t));
        MOVS     R3,#+2
        MOV      R2,SP
        MOVS     R1,#+0
        MOVS     R0,R4
        BL       NvHalRead
//  737   
//  738   /* Do the header and trailer match? */
//  739   /* Is the magic number legit? */
//  740   if (NvHalVerify( nvRawSectorAddress , sizeof(NvRawSector_t)- sizeof(NvStructuredSectorHeader_t),(unsigned char*)&sectorHeader,sizeof(NvStructuredSectorHeader_t))
//  741   
//  742  
//  743        && (sectorHeader.magicNumber == mNvMagicNumber_c)) {
        MOVS     R3,#+2
        MOV      R2,SP
        LDR      R1,??DataTable19_1  ;; 0xffe
        MOVS     R0,R4
        BL       NvHalVerify
        CMP      R0,#+0
        BEQ      ??NvIsValidSector_0
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+39
        BNE      ??NvIsValidSector_0
//  744     return TRUE;
        MOVS     R0,#+1
        B        ??NvIsValidSector_1
//  745   }
//  746 
//  747   return FALSE;
??NvIsValidSector_0:
        MOVS     R0,#+0
??NvIsValidSector_1:
        POP      {R1,R2,R4}
        POP      {R3}
        BX       R3               ;; return
//  748 }                                       /* NvIsValidDataSet() */
//  749 #endif                                  /* #if gNvStorageIncluded_d */
//  750 
//  751 
//  752 /********************************************************/
//  753 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  754 static bool_t NvOpen_Validate_Sector(NvRawSectorAddress_t nvRawSectorAddress, NvSectorSequenceNumber_t sequenceNumber, bool_t open )
//  755   {
NvOpen_Validate_Sector:
        PUSH     {R3-R7,LR}
        MOVS     R7,R0
        MOVS     R6,R1
        MOVS     R5,R2
//  756   NvStructuredSectorHeader_t sectorHeader;
//  757   NvSize_t pageOffset;
//  758   sectorHeader.magicNumber = mNvMagicNumber_c;
        MOV      R0,SP
        MOVS     R1,#+39
        STRB     R1,[R0, #+0]
//  759   sectorHeader.sequenceNumber = sequenceNumber;
        MOV      R0,SP
        STRB     R6,[R0, #+1]
//  760   pageOffset = open ? 0 : ( sizeof(NvRawSector_t) - sizeof(NvStructuredSectorHeader_t) );
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+0
        BEQ      ??NvOpen_Validate_Sector_0
        MOVS     R4,#+0
        B        ??NvOpen_Validate_Sector_1
??NvOpen_Validate_Sector_0:
        LDR      R4,??DataTable19_1  ;; 0xffe
//  761   if( NvHalWrite( nvRawSectorAddress , pageOffset , (uint8_t*)&sectorHeader , sizeof(NvStructuredSectorHeader_t)))
??NvOpen_Validate_Sector_1:
        MOVS     R3,#+2
        MOV      R2,SP
        MOVS     R1,R4
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R7
        BL       NvHalWrite
        CMP      R0,#+0
        BEQ      ??NvOpen_Validate_Sector_2
//  762    {
//  763     return FALSE;  
        MOVS     R0,#+0
        B        ??NvOpen_Validate_Sector_3
//  764    }
//  765   return TRUE;
??NvOpen_Validate_Sector_2:
        MOVS     R0,#+1
??NvOpen_Validate_Sector_3:
        POP      {R1,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  766   }                                       /* NvIsValidDataSet() */

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable17:
        DC32     NvDataSetTable
//  767 #endif                                  /* #if gNvStorageIncluded_d */
//  768 
//  769   /****************************************************************************/
//  770 
//  771 /* Examine an NV sector. Check the magic number, check that the header
//  772  * and trailer match
//  773  * Return TRUE if it looks legit; FALSE otherwise.
//  774  */
//  775 
//  776 
//  777 #if gNvStorageIncluded_d
//  778 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  779 static void NvGetFirstBlankPageInfo
//  780   (
//  781   NvRawSectorAddress_t nvRawSectorAddress, NvRawPageAddress_t* pBlankPage, index_t* pBlankPageIndex 
//  782   )
//  783 {
NvGetFirstBlankPageInfo:
        PUSH     {R0,R4-R7,LR}
        MOVS     R7,R1
        MOVS     R6,R2
//  784   NvRawPageAddress_t pageAddress;
//  785   index_t pageIndex;
//  786   *pBlankPage = gMaxPageOffset_c + nvRawSectorAddress;
        LDR      R0,[SP, #+0]
        LDR      R1,??DataTable19_2  ;; 0xfe2
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
//  787   pageAddress  =   gLastPageOffset_c + nvRawSectorAddress;
        LDR      R0,[SP, #+0]
        LDR      R1,??DataTable19_3  ;; 0xde6
        ADDS     R0,R0,R1
        MOVS     R4,R0
//  788   *pBlankPageIndex = pageIndex  = gNvNumberOfRawPages_c;
        MOVS     R0,#+8
        MOVS     R5,R0
        STRB     R0,[R6, #+0]
//  789   
//  790   while(pageIndex --)
??NvGetFirstBlankPageInfo_0:
        MOVS     R0,R5
        SUBS     R5,R0,#+1
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+0
        BEQ      ??NvGetFirstBlankPageInfo_1
//  791   {
//  792     if( NvHalIsBlank ( pageAddress, 0 , sizeof(NvRawPage_t)))
        MOVS     R2,#+254
        LSLS     R2,R2,#+1        ;; #+508
        MOVS     R1,#+0
        MOVS     R0,R4
        BL       NvHalIsBlank
        CMP      R0,#+0
        BEQ      ??NvGetFirstBlankPageInfo_2
//  793       {
//  794       *pBlankPage = pageAddress;
        STR      R4,[R7, #+0]
//  795       *pBlankPageIndex = pageIndex;
        STRB     R5,[R6, #+0]
//  796       }
//  797     else
//  798       {
//  799         return;
//  800       }
//  801     pageAddress -= sizeof(NvRawPage_t);
        LDR      R0,??DataTable19_4  ;; 0xfffffe04
        ADDS     R4,R4,R0
        B        ??NvGetFirstBlankPageInfo_0
??NvGetFirstBlankPageInfo_2:
        B        ??NvGetFirstBlankPageInfo_3
//  802   }  
//  803 
//  804 }                                      
??NvGetFirstBlankPageInfo_1:
??NvGetFirstBlankPageInfo_3:
        POP      {R0,R4-R7}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable18:
        DC32     maNvDirtyFlags

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable18_1:
        DC32     gIdleTaskID

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable18_2:
        DC32     gNvMinimumTicksBetweenSaves

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable18_3:
        DC32     gNvCountsBetweenSaves

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable18_4:
        DC32     mNvCriticalSectionFlag
//  805 #endif                                  /* #if gNvStorageIncluded_d */
//  806   /****************************************************************************/
//  807 
//  808 /* Examine an NV sector. Check the magic number, check that the header
//  809  * and trailer match
//  810  * Return TRUE if it looks legit; FALSE otherwise.
//  811  */
//  812 
//  813 
//  814 #if gNvStorageIncluded_d
//  815       
//  816 /*typedef struct NvSectInfo_tag {
//  817   NvSectorSequenceNumber_t sequenceNumber;
//  818   NvRawPageAddress_t pageAddress[gNvNumberOfDataSets_c];
//  819 } NvSectInfo_t;
//  820  typedef NvRawPageAddress_t NvSectPageInfo_t[ gNvNumberOfDataSets_c ];     
//  821       */
//  822 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  823 static void NvGetSectorPageInfo
//  824   (
//  825   NvRawSectorAddress_t nvRawSectorAddress, NvSectPageInfo_t* pSectPageInfo
//  826   )
//  827 {
NvGetSectorPageInfo:
        PUSH     {R3-R7,LR}
        MOVS     R6,R0
        MOVS     R7,R1
//  828   
//  829   NvRawPageAddress_t pageAddress;
//  830   index_t pageIndex;
//  831   NvDataSetID_t dataSetID;
//  832   for(pageIndex = 0; pageIndex < gNvNumberOfDataSets_c; pageIndex++)
        MOVS     R0,#+0
        MOVS     R5,R0
??NvGetSectorPageInfo_0:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BCS      ??NvGetSectorPageInfo_1
//  833   {
//  834     (*pSectPageInfo)[pageIndex] = (NvRawPageAddress_t)gUninitAddress;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        STR      R1,[R7, R0]
//  835   }
        ADDS     R5,R5,#+1
        B        ??NvGetSectorPageInfo_0
//  836   
//  837  
//  838   for(pageIndex = 0 ,pageAddress  = nvRawSectorAddress + sizeof(NvStructuredSectorHeader_t); pageIndex < gNvNumberOfRawPages_c ; pageIndex++ , pageAddress += sizeof(NvRawPage_t ))
??NvGetSectorPageInfo_1:
        MOVS     R0,#+0
        MOVS     R5,R0
        MOVS     R0,R6
        ADDS     R0,R0,#+2
        MOVS     R4,R0
??NvGetSectorPageInfo_2:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+8
        BCS      ??NvGetSectorPageInfo_3
//  839   {
//  840     
//  841         if( NvIsValidPage( pageAddress , &dataSetID ))
        MOV      R1,SP
        MOVS     R0,R4
        BL       NvIsValidPage
        CMP      R0,#+0
        BEQ      ??NvGetSectorPageInfo_4
//  842           {
//  843             (*pSectPageInfo)[NvDataSetIndexFromID(dataSetID)] = pageAddress;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        BL       NvDataSetIndexFromID
        MOVS     R1,#+4
        MULS     R0,R1,R0
        STR      R4,[R7, R0]
//  844           }
//  845           
//  846   }
??NvGetSectorPageInfo_4:
        ADDS     R5,R5,#+1
        MOVS     R0,#+254
        LSLS     R0,R0,#+1        ;; #+508
        ADDS     R4,R4,R0
        B        ??NvGetSectorPageInfo_2
//  847 
//  848 }                                      
??NvGetSectorPageInfo_3:
        POP      {R0,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  849 #endif                                  /* #if gNvStorageIncluded_d */      
//  850             
//  851   /****************************************************************************/
//  852 
//  853 /* Examine an NV sector. Check the magic number, check that the header
//  854  * and trailer match
//  855  * Return TRUE if it looks legit; FALSE otherwise.
//  856  */
//  857 
//  858 
//  859 #if gNvStorageIncluded_d
//  860 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  861 static NvSectorSequenceNumber_t NvGetSectorSequenceNumber
//  862   (
//  863   NvRawSectorAddress_t nvRawSectorAddress
//  864   )
//  865 {
NvGetSectorSequenceNumber:
        PUSH     {R4,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
//  866   NvSectorSequenceNumber_t sectorSequenceNumber;
//  867   NvHalRead( nvRawSectorAddress,  sizeof(NvMagicNumber_t) , (uint8_t *)&sectorSequenceNumber, sizeof(sectorSequenceNumber));
        MOVS     R3,#+1
        MOV      R2,SP
        MOVS     R1,#+1
        MOVS     R0,R4
        BL       NvHalRead
//  868   return sectorSequenceNumber;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        POP      {R1,R2,R4}
        POP      {R3}
        BX       R3               ;; return
//  869 }                                      
//  870 #endif                                  /* #if gNvStorageIncluded_d */                  
//  871   /****************************************************************************/
//  872 
//  873 /* Examine an NV sector. Check the magic number, check that the header
//  874  * and trailer match
//  875  * Return TRUE if it looks legit; FALSE otherwise.
//  876  */
//  877 
//  878 
//  879 #if gNvStorageIncluded_d
//  880 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  881 static NvSectorSequenceNumber_t NvLastSectorSequence
//  882 (
//  883 NvSectorSequenceNumber_t sectorSeqA,NvSectorSequenceNumber_t sectorSeqB
//  884 )
//  885 {
NvLastSectorSequence:
        PUSH     {LR}
//  886   NvSectorSequenceNumber_t seqDiff;
//  887   seqDiff = sectorSeqA - sectorSeqB;
        SUBS     R3,R0,R1
        MOVS     R2,R3
//  888   return (seqDiff == 1) ? sectorSeqA : sectorSeqB ;
        LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
        LSRS     R2,R2,#+24
        CMP      R2,#+1
        BEQ      ??NvLastSectorSequence_0
??NvLastSectorSequence_1:
        MOVS     R0,R1
??NvLastSectorSequence_0:
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        POP      {R3}
        BX       R3               ;; return
//  889 }                                      
//  890 #endif                                  /* #if gNvStorageIncluded_d */                  
//  891             
//  892 /****************************************************************************/
//  893 
//  894 /* Save the contents of a data set, regardless of the state of the set's
//  895  * dirty flag. Always writes a full page.
//  896  *
//  897  * Retry if the HAL reports an error. There isn't anything that the caller
//  898  * can do about errors, so reporting one would be pointless.
//  899  *
//  900  * The flash controller reports errors that it detects, but power supply
//  901  * fluctuations may still cause undetected errors. Its tempting to compute
//  902  * some kind of checksum, and verify it after write, and also when a data
//  903  * set is restored. This would complicate the code somewhat, and may not
//  904  * be a common enough problem to be worth the extra code space.
//  905  */
//  906 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  907 static bool_t NvSaveDataSetLowLevel
//  908   (
//  909   index_t dataSetIndex , NvRawPageAddress_t pageAddress
//  910   )
//  911 {
NvSaveDataSetLowLevel:
        PUSH     {R3-R7,LR}
        MOVS     R7,R0
        MOVS     R6,R1
//  912   NvDataItemDescription_t const *pDataItemDescriptions;
//  913   NvDataSetID_t dataSetID;
//  914   static NvStructuredPageHeader_t pageHeader;
//  915   NvSize_t pageOffset;
//  916   
//  917   dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
        MOV      R0,SP
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R1,#+8
        MULS     R1,R7,R1
        LDR      R2,??NvCopyDataSet_0
        LDRB     R1,[R2, R1]
        STRB     R1,[R0, #+0]
//  918 
//  919   /* Set up the page header/trailer. */
//  920   pageHeader.magicNumber = mNvMagicNumber_c;
        LDR      R0,??DataTable20
        MOVS     R1,#+39
        STRB     R1,[R0, #+0]
//  921   pageHeader.dataSetID = dataSetID;
        LDR      R0,??DataTable20
        MOV      R1,SP
        LDRB     R1,[R1, #+0]
        STRB     R1,[R0, #+1]
//  922   pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        MOVS     R0,#+8
        MULS     R0,R7,R0
        LDR      R1,??NvCopyDataSet_0
        ADDS     R0,R1,R0
        LDR      R0,[R0, #+4]
        MOVS     R5,R0
//  923   pageOffset = 0;
        MOVS     R0,#+0
        MOVS     R4,R0
//  924 
//  925     /* Write the page header to the beginning of the page. */
//  926    if( FALSE == NvHalWrite( pageAddress,  pageOffset,  (uint8_t*) &pageHeader,  sizeof(pageHeader)) )
        MOVS     R3,#+2
        LDR      R2,??DataTable20
        MOVS     R1,R4
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R6
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvSaveDataSetLowLevel_0
//  927      {
//  928        return FALSE;
        MOVS     R0,#+0
        B        ??NvSaveDataSetLowLevel_1
//  929      }
//  930    pageOffset += sizeof(pageHeader);
??NvSaveDataSetLowLevel_0:
        ADDS     R4,R4,#+2
//  931 
//  932     /* Write the client data to the page. Note that the sizes of all of the */
//  933     /* data sets in NvDataSetTable[] were validated in NvModuleInit(), so it */
//  934     /* isn't necesary to check it here. */
//  935     while ( pDataItemDescriptions->length) 
??NvSaveDataSetLowLevel_2:
        LDRH     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ      ??NvSaveDataSetLowLevel_3
//  936       {
//  937        if( FALSE == NvHalWrite( pageAddress, pageOffset, (uint8_t*)(pDataItemDescriptions->pointer), pDataItemDescriptions->length))
        LDRH     R3,[R5, #+4]
        LDR      R2,[R5, #+0]
        MOVS     R1,R4
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R6
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvSaveDataSetLowLevel_4
//  938          {
//  939            return FALSE;
        MOVS     R0,#+0
        B        ??NvSaveDataSetLowLevel_1
//  940          }
//  941        pageOffset += pDataItemDescriptions->length;
??NvSaveDataSetLowLevel_4:
        LDRH     R0,[R5, #+4]
        ADDS     R4,R4,R0
//  942       ++pDataItemDescriptions;
        ADDS     R5,R5,#+8
        B        ??NvSaveDataSetLowLevel_2
//  943       }
//  944 
//  945     /* Write the terminal copy of the header. If this works, we're done. */
//  946     pageOffset =   sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t);
??NvSaveDataSetLowLevel_3:
        MOVS     R0,#+253
        LSLS     R0,R0,#+1        ;; #+506
        MOVS     R4,R0
//  947     if( FALSE == NvHalWrite( pageAddress, pageOffset, (uint8_t *) &pageHeader, sizeof(pageHeader)) )
        MOVS     R3,#+2
        LDR      R2,??DataTable20
        MOVS     R1,R4
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        MOVS     R0,R6
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvSaveDataSetLowLevel_5
//  948       {
//  949        return FALSE;
        MOVS     R0,#+0
        B        ??NvSaveDataSetLowLevel_1
//  950       }
//  951     return TRUE;
??NvSaveDataSetLowLevel_5:
        MOVS     R0,#+1
??NvSaveDataSetLowLevel_1:
        POP      {R1,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  952 }                                       /* NvSaveDataSetLowLevel() */

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable19:
        DC32     0x80003018

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable19_1:
        DC32     0xffe

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable19_2:
        DC32     0xfe2

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable19_3:
        DC32     0xde6

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable19_4:
        DC32     0xfffffe04

        SECTION `.bss`:DATA:NOROOT(2)
??pageHeader:
        DS8 4
//  953 
//  954 
//  955 #endif                                  /* #if !gNvStorageIncluded_d */
//  956 
//  957 /****************************************************************************/
//  958 
//  959 /* Save the contents of a data set, regardless of the state of the set's
//  960  * dirty flag. Always writes a full page.
//  961  *
//  962  * Retry if the HAL reports an error. There isn't anything that the caller
//  963  * can do about errors, so reporting one would be pointless.
//  964  *
//  965  * The flash controller reports errors that it detects, but power supply
//  966  * fluctuations may still cause undetected errors. Its tempting to compute
//  967  * some kind of checksum, and verify it after write, and also when a data
//  968  * set is restored. This would complicate the code somewhat, and may not
//  969  * be a common enough problem to be worth the extra code space.
//  970  */
//  971 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  972 static void NvSaveDataSet
//  973 (
//  974 index_t dataSetIndex 
//  975 )
//  976 {
NvSaveDataSet:
        PUSH     {R0,R4-R7,LR}
        SUB      SP,SP,#+32
//  977   index_t i;
//  978   NvRawSectorAddress_t activeSectorAddress , oldSectorAddress ;
//  979   NvRawPageAddress_t firstBlankPageAddress;
//  980   bool_t sectorChange;
//  981   bool_t sectorOpen;
//  982   bool_t dataSaved;
//  983   bool_t nvmError ;
//  984   index_t sectorIndex;
//  985   index_t firstBlankPageIndex;
//  986   uint8_t retries;
//  987   NvSectorSequenceNumber_t sectSeqNo;
//  988   NvSectPageInfo_t validSectPageInfo, newSectPageInfo;
//  989   
//  990   PowerUpNVM();   
        BL       PowerUpNVM
//  991   retries = mNvFlashCmdRetries_c;
        MOV      R0,SP
        MOVS     R1,#+32
        STRB     R1,[R0, #+8]
//  992   while(retries--)  
??NvSaveDataSet_0:
        MOV      R0,SP
        LDRB     R0,[R0, #+8]
        MOV      R1,SP
        SUBS     R2,R0,#+1
        STRB     R2,[R1, #+8]
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+0
        BNE      .+4
        B        ??NvSaveDataSet_1
//  993   {
//  994     nvmError = FALSE;  
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  995     sectorChange = FALSE;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+2]
//  996     sectorOpen = FALSE;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+3]
//  997     activeSectorAddress = gUninitAddress;
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
        MOVS     R6,R0
//  998     dataSaved = FALSE;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+9]
//  999     // search for the valid sector
// 1000     for( sectorIndex=0; sectorIndex < gNvNumberOfRawSectors_c;sectorIndex++ )
        MOVS     R0,#+0
        MOVS     R4,R0
??NvSaveDataSet_2:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+2
        BCS      ??NvSaveDataSet_3
// 1001     {
// 1002       if(NvIsValidSector(maNvRawSectorAddressTable[sectorIndex]))
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable21
        LDR      R0,[R1, R0]
        BL       NvIsValidSector
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_4
// 1003       {
// 1004         activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable21
        LDR      R0,[R1, R0]
        MOVS     R6,R0
// 1005         NvGetFirstBlankPageInfo(activeSectorAddress, &firstBlankPageAddress, &firstBlankPageIndex);
        ADD      R2,SP,#+0
        ADDS     R2,R2,#+1
        ADD      R1,SP,#+4
        MOVS     R0,R6
        BL       NvGetFirstBlankPageInfo
// 1006         break;
        B        ??NvSaveDataSet_3
// 1007       }
// 1008     }
??NvSaveDataSet_4:
        ADDS     R4,R4,#+1
        B        ??NvSaveDataSet_2
// 1009     while(dataSaved == FALSE)
??NvSaveDataSet_3:
        MOV      R0,SP
        LDRB     R0,[R0, #+9]
        CMP      R0,#+0
        BEQ      .+4
        B        ??NvSaveDataSet_5
// 1010     {
// 1011       if(activeSectorAddress == gUninitAddress)
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
        CMP      R6,R0
        BNE      ??NvSaveDataSet_6
// 1012       {
// 1013         // There is no valid sector.Is the first time when a page is saved.  
// 1014         sectorIndex = 0;
        MOVS     R0,#+0
        MOVS     R4,R0
// 1015         sectSeqNo = 0;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1016         activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable21
        LDR      R0,[R1, R0]
        MOVS     R6,R0
// 1017         firstBlankPageAddress = activeSectorAddress + sizeof(NvStructuredSectorHeader_t);
        MOVS     R0,R6
        ADDS     R0,R0,#+2
        STR      R0,[SP, #+4]
// 1018         firstBlankPageIndex = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+1]
// 1019         if (nvmError =  NvOpenSector(activeSectorAddress, sectSeqNo))
        MOVS     R2,#+1
        MOVS     R1,R7
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        MOVS     R0,R6
        BL       NvOpen_Validate_Sector
        MOV      R1,SP
        STRB     R0,[R1, #+0]
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+0
        BNE      ??NvSaveDataSet_5
// 1020         {
// 1021           break;
// 1022         }
// 1023         sectorOpen = TRUE;
??NvSaveDataSet_7:
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+3]
        B        ??NvSaveDataSet_8
// 1024       }
// 1025       else   
// 1026       {   
// 1027         if( gNvNumberOfRawPages_c == firstBlankPageIndex )
??NvSaveDataSet_6:
        MOV      R0,SP
        LDRB     R0,[R0, #+1]
        CMP      R0,#+8
        BNE      ??NvSaveDataSet_8
// 1028         {
// 1029           // there is no room to save all data sets  
// 1030           if(sectorChange || sectorOpen)
        MOV      R0,SP
        LDRB     R0,[R0, #+2]
        MOV      R1,SP
        LDRB     R1,[R1, #+3]
        ORRS     R1,R1,R0
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??NvSaveDataSet_9
// 1031           {
// 1032             nvmError = TRUE;
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
// 1033             break;
        B        ??NvSaveDataSet_5
// 1034             //after a sector change or after a sectorOpen data sets cannot be saved in the new sector.
// 1035             // must be a hardware issue. leave the loop and erase the sector again
// 1036           }
// 1037           else
// 1038           {
// 1039             
// 1040             sectSeqNo = NvGetSectorSequenceNumber(activeSectorAddress);
??NvSaveDataSet_9:
        MOVS     R0,R6
        BL       NvGetSectorSequenceNumber
        MOVS     R7,R0
// 1041             oldSectorAddress = activeSectorAddress;
        STR      R6,[SP, #+12]
// 1042             NvGetSectorPageInfo(activeSectorAddress , &validSectPageInfo);
        ADD      R1,SP,#+24
        MOVS     R0,R6
        BL       NvGetSectorPageInfo
// 1043             sectSeqNo  +=  1;
        ADDS     R7,R7,#+1
// 1044             for(i=0 ; i < gNvNumberOfDataSets_c; i++ )
        MOVS     R0,#+0
        MOVS     R5,R0
??NvSaveDataSet_10:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BCS      ??NvSaveDataSet_11
// 1045             {
// 1046               newSectPageInfo[i] = (NvRawPageAddress_t)gUninitAddress;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        ADD      R1,SP,#+16
        MOVS     R2,#+0
        MVNS     R2,R2            ;; #-1
        STR      R2,[R1, R0]
// 1047             }
        ADDS     R5,R5,#+1
        B        ??NvSaveDataSet_10
// 1048             sectorIndex = ((sectorIndex + 1) < gNvNumberOfRawSectors_c)?(sectorIndex + 1):0 ;
??NvSaveDataSet_11:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,R4
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
        LSRS     R0,R0,#+16
        CMP      R0,#+2
        BCS      ??NvSaveDataSet_12
        ADDS     R4,R4,#+1
        B        ??NvSaveDataSet_13
??NvSaveDataSet_12:
        MOVS     R4,#+0
// 1049             activeSectorAddress = maNvRawSectorAddressTable[sectorIndex];
??NvSaveDataSet_13:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+4
        MULS     R0,R4,R0
        LDR      R1,??DataTable21
        LDR      R0,[R1, R0]
        MOVS     R6,R0
// 1050             firstBlankPageAddress = activeSectorAddress + sizeof(NvStructuredSectorHeader_t);
        MOVS     R0,R6
        ADDS     R0,R0,#+2
        STR      R0,[SP, #+4]
// 1051             firstBlankPageIndex = 0;
        MOV      R0,SP
        MOVS     R1,#+0
        STRB     R1,[R0, #+1]
// 1052             
// 1053             if (nvmError =  NvOpenSector(activeSectorAddress , sectSeqNo) )
        MOVS     R2,#+1
        MOVS     R1,R7
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        MOVS     R0,R6
        BL       NvOpen_Validate_Sector
        MOV      R1,SP
        STRB     R0,[R1, #+0]
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
        CMP      R0,#+0
        BNE      ??NvSaveDataSet_5
// 1054             {
// 1055               break;
// 1056             }
// 1057             sectorChange = TRUE;
??NvSaveDataSet_14:
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+2]
// 1058             
// 1059             // if a sector change all data sets to be saved must be saved in the new sector 
// 1060             //and after that the remains data sets must be copied from the old sector
// 1061           }
// 1062         }
// 1063       }//else from (activeSectorAddress == 0)
// 1064       if(NvSaveDataSetLowLevel(dataSetIndex,firstBlankPageAddress ))
??NvSaveDataSet_8:
        LDR      R1,[SP, #+4]
        ADD      R0,SP,#+32
        LDRB     R0,[R0, #+0]
        BL       NvSaveDataSetLowLevel
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_15
// 1065       {
// 1066         dataSaved = TRUE; 
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+9]
// 1067         if(sectorChange)
        MOV      R0,SP
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_15
// 1068         {
// 1069           newSectPageInfo[dataSetIndex] = firstBlankPageAddress;
        ADD      R0,SP,#+32
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+4
        MULS     R0,R1,R0
        ADD      R1,SP,#+16
        LDR      R2,[SP, #+4]
        STR      R2,[R1, R0]
// 1070         }
// 1071       }  
// 1072       firstBlankPageAddress +=  sizeof(NvRawPage_t);
??NvSaveDataSet_15:
        LDR      R0,[SP, #+4]
        MOVS     R1,#+254
        LSLS     R1,R1,#+1        ;; #+508
        ADDS     R0,R0,R1
        STR      R0,[SP, #+4]
// 1073       firstBlankPageIndex ++;
        MOV      R0,SP
        LDRB     R0,[R0, #+1]
        ADDS     R0,R0,#+1
        MOV      R1,SP
        STRB     R0,[R1, #+1]
        B        ??NvSaveDataSet_3
// 1074       
// 1075     }//  while(dataSaved == FALSE))
// 1076     if((sectorChange || sectorOpen) && (nvmError == FALSE))
??NvSaveDataSet_5:
        MOV      R0,SP
        LDRB     R0,[R0, #+2]
        MOV      R1,SP
        LDRB     R1,[R1, #+3]
        ORRS     R1,R1,R0
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+0
        BEQ      ??NvSaveDataSet_16
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??NvSaveDataSet_16
// 1077       {
// 1078       //the sector must be marked as a valid one(write the magic number and the sequence number at the end of the sector)
// 1079       nvmError = NvValidateSector(activeSectorAddress, sectSeqNo);
        MOVS     R2,#+0
        MOVS     R1,R7
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        MOVS     R0,R6
        BL       NvOpen_Validate_Sector
        MOV      R1,SP
        STRB     R0,[R1, #+0]
// 1080       }
// 1081     
// 1082     if(sectorChange &&(nvmError == FALSE))
??NvSaveDataSet_16:
        MOV      R0,SP
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_17
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??NvSaveDataSet_17
// 1083     {
// 1084       // the remains data sets must be copied from the old sector
// 1085       nvmError =NvCopyTheRemainsDataSets(&validSectPageInfo, &newSectPageInfo,firstBlankPageAddress,firstBlankPageIndex);
        MOV      R0,SP
        LDRB     R3,[R0, #+1]
        LDR      R2,[SP, #+4]
        ADD      R1,SP,#+16
        ADD      R0,SP,#+24
        BL       NvCopyTheRemainsDataSets
        MOV      R1,SP
        STRB     R0,[R1, #+0]
// 1086     }
// 1087 
// 1088     if((sectorChange ) && (nvmError == FALSE))
??NvSaveDataSet_17:
        MOV      R0,SP
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_18
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??NvSaveDataSet_18
// 1089     {
// 1090       NvHalEraseSector(oldSectorAddress);  
        LDR      R0,[SP, #+12]
        BL       NvHalEraseSector
// 1091     } 
// 1092     if(nvmError)
??NvSaveDataSet_18:
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??NvSaveDataSet_19
// 1093     {
// 1094       NvHalEraseSector(activeSectorAddress);
        MOVS     R0,R6
        BL       NvHalEraseSector
// 1095       
// 1096       continue;  
        B        ??NvSaveDataSet_0
// 1097     }
// 1098     
// 1099     maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
??NvSaveDataSet_19:
        ADD      R0,SP,#+32
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+6
        MULS     R0,R1,R0
        LDR      R1,??DataTable21_1
        MOVS     R2,#+0
        STRB     R2,[R1, R0]
// 1100     maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
        ADD      R0,SP,#+32
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+6
        MULS     R0,R1,R0
        LDR      R1,??DataTable21_1
        ADDS     R0,R1,R0
        MOVS     R1,#+128
        LSLS     R1,R1,#+1        ;; #+256
        STRH     R1,[R0, #+4]
// 1101     
// 1102     
// 1103     break;
// 1104   } 
// 1105   PowerDownNVM();
??NvSaveDataSet_1:
        BL       PowerDownNVM
// 1106 }                                       /* NvSaveDataSet() */
        ADD      SP,SP,#+36
        POP      {R4-R7}
        POP      {R3}
        BX       R3               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable20:
        DC32     ??pageHeader
// 1107 
// 1108 
// 1109 #endif                                  /* #if !gNvStorageIncluded_d */            
// 1110 /****************************************************************************/
// 1111             
// 1112 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 1113 static bool_t NvCopyDataSet
// 1114   (
// 1115   NvRawPageAddress_t sourcePage , NvRawPageAddress_t destPage
// 1116   )
// 1117 {
NvCopyDataSet:
        PUSH     {R0,R1,R4-R7,LR}
        SUB      SP,SP,#+68
// 1118   NvDataItemDescription_t const *pDataItemDescriptions;
// 1119   static NvStructuredPageHeader_t pageHeader;
// 1120   index_t dataSetIndex;
// 1121   uint8_t buffer[g_CopyBufferSize_c];
// 1122   NvSize_t length;
// 1123   NvSize_t numBytes;
// 1124   NvSize_t pageOffset;
// 1125   
// 1126   NvHalRead(sourcePage, 0, (uint8_t*)&pageHeader, sizeof(pageHeader));  
        MOVS     R3,#+2
        LDR      R2,??DataTable21_2
        MOVS     R1,#+0
        LDR      R0,[SP, #+68]
        BL       NvHalRead
// 1127   dataSetIndex = NvDataSetIndexFromID(pageHeader.dataSetID); 
        LDR      R0,??DataTable21_2
        LDRB     R0,[R0, #+1]
        BL       NvDataSetIndexFromID
        MOV      R1,SP
        STRB     R0,[R1, #+0]
// 1128   /* Set up the page header/trailer. */
// 1129   pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MOVS     R1,#+8
        MULS     R0,R1,R0
        LDR      R1,??NvCopyDataSet_0
        ADDS     R0,R1,R0
        LDR      R0,[R0, #+4]
        MOVS     R6,R0
// 1130   length = 0;
        MOVS     R0,#+0
        MOVS     R4,R0
// 1131    while (pDataItemDescriptions->length)
??NvCopyDataSet_1:
        LDRH     R0,[R6, #+4]
        CMP      R0,#+0
        BEQ      ??NvCopyDataSet_2
// 1132    {
// 1133     length += pDataItemDescriptions->length;
        LDRH     R0,[R6, #+4]
        ADDS     R4,R4,R0
// 1134     ++pDataItemDescriptions;
        ADDS     R6,R6,#+8
        B        ??NvCopyDataSet_1
        Nop      
        DATA
??NvCopyDataSet_0:
        DC32     NvDataSetTable
        THUMB
// 1135    }
// 1136  
// 1137   pageOffset = 0;
??NvCopyDataSet_2:
        MOVS     R0,#+0
        MOVS     R5,R0
// 1138   if( FALSE == NvHalWrite( destPage,  pageOffset,  (uint8_t*) &pageHeader,  sizeof(pageHeader)) )
        MOVS     R3,#+2
        LDR      R2,??DataTable21_2
        MOVS     R1,R5
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        LDR      R0,[SP, #+72]
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvCopyDataSet_3
// 1139      {
// 1140        return FALSE;
        MOVS     R0,#+0
        B        ??NvCopyDataSet_4
// 1141      }
// 1142     
// 1143   pageOffset = sizeof(NvStructuredPageHeader_t);
??NvCopyDataSet_3:
        MOVS     R0,#+2
        MOVS     R5,R0
// 1144   
// 1145   while(length)
??NvCopyDataSet_5:
        LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
        LSRS     R4,R4,#+16
        CMP      R4,#+0
        BEQ      ??NvCopyDataSet_6
// 1146   {
// 1147     numBytes = (length  <  sizeof(buffer)) ? length : sizeof(buffer);
        LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
        LSRS     R4,R4,#+16
        CMP      R4,#+64
        BCS      ??NvCopyDataSet_7
        MOVS     R7,R4
        B        ??NvCopyDataSet_8
??NvCopyDataSet_7:
        MOVS     R7,#+64
// 1148     NvHalRead(sourcePage, pageOffset , buffer, numBytes);  
??NvCopyDataSet_8:
        MOVS     R3,R7
        LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
        LSRS     R3,R3,#+16
        ADD      R2,SP,#+4
        MOVS     R1,R5
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        LDR      R0,[SP, #+68]
        BL       NvHalRead
// 1149     if( FALSE == NvHalWrite( destPage,  pageOffset,  buffer, numBytes) )
        MOVS     R3,R7
        LSLS     R3,R3,#+16       ;; ZeroExtS R3,R3,#+16,#+16
        LSRS     R3,R3,#+16
        ADD      R2,SP,#+4
        MOVS     R1,R5
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        LDR      R0,[SP, #+72]
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvCopyDataSet_9
// 1150      {
// 1151        return FALSE;
        MOVS     R0,#+0
        B        ??NvCopyDataSet_4
// 1152      }
// 1153     length -= numBytes;
??NvCopyDataSet_9:
        SUBS     R4,R4,R7
// 1154     pageOffset += numBytes;
        ADDS     R5,R5,R7
        B        ??NvCopyDataSet_5
// 1155   }
// 1156    /* Write the terminal copy of the header. If this works, we're done. */
// 1157    pageOffset =   sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t);
??NvCopyDataSet_6:
        MOVS     R0,#+253
        LSLS     R0,R0,#+1        ;; #+506
        MOVS     R5,R0
// 1158     if( FALSE == NvHalWrite( destPage, pageOffset, (uint8_t *) &pageHeader, sizeof(pageHeader)) )
        MOVS     R3,#+2
        LDR      R2,??DataTable21_2
        MOVS     R1,R5
        LSLS     R1,R1,#+16       ;; ZeroExtS R1,R1,#+16,#+16
        LSRS     R1,R1,#+16
        LDR      R0,[SP, #+72]
        BL       NvHalWrite
        CMP      R0,#+0
        BNE      ??NvCopyDataSet_10
// 1159       {
// 1160        return FALSE;
        MOVS     R0,#+0
        B        ??NvCopyDataSet_4
// 1161       }
// 1162     return TRUE;
??NvCopyDataSet_10:
        MOVS     R0,#+1
??NvCopyDataSet_4:
        ADD      SP,SP,#+76
        POP      {R4-R7}
        POP      {R3}
        BX       R3               ;; return
// 1163 }                                       /* NvCopyDataSet() */

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable21:
        DC32     maNvRawSectorAddressTable

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable21_1:
        DC32     maNvDirtyFlags

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable21_2:
        DC32     ??pageHeader_1

        SECTION `.bss`:DATA:NOROOT(2)
??pageHeader_1:
        DS8 4
// 1164 
// 1165 
// 1166 #endif                                  /* #if !gNvStorageIncluded_d */
// 1167             
// 1168 /****************************************************************************/
// 1169             
// 1170 #if gNvStorageIncluded_d

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1171 static bool_t  NvCopyTheRemainsDataSets
// 1172   (
// 1173    NvSectPageInfo_t* oldSectPageInfo, NvSectPageInfo_t *newSectPageInfo, NvRawPageAddress_t firstBlankPageAddress,index_t firstBlankPageIndex
// 1174   )
// 1175 {
NvCopyTheRemainsDataSets:
        PUSH     {R0,R1,R4-R7,LR}
        SUB      SP,SP,#+4
        MOVS     R6,R2
        MOVS     R7,R3
// 1176   index_t dataSetsToCopy;
// 1177   index_t dataSetIndex;
// 1178   for(dataSetIndex = 0 , dataSetsToCopy = 0 ; dataSetIndex < gNvNumberOfDataSets_c ; dataSetIndex++ )
        MOVS     R0,#+0
        MOVS     R5,R0
        MOVS     R0,#+0
        MOVS     R4,R0
??NvCopyTheRemainsDataSets_0:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+2
        BCS      ??NvCopyTheRemainsDataSets_1
// 1179     {
// 1180       if( ( (*oldSectPageInfo)[dataSetIndex] != gUninitAddress ) && ((*newSectPageInfo)[dataSetIndex] == gUninitAddress))
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R1,[SP, #+4]
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BEQ      ??NvCopyTheRemainsDataSets_2
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R1,[SP, #+8]
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BNE      ??NvCopyTheRemainsDataSets_2
// 1181       {
// 1182         dataSetsToCopy++;
        ADDS     R4,R4,#+1
// 1183       }
// 1184     }
??NvCopyTheRemainsDataSets_2:
        ADDS     R5,R5,#+1
        B        ??NvCopyTheRemainsDataSets_0
// 1185   if(!dataSetsToCopy)
??NvCopyTheRemainsDataSets_1:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+0
        BNE      ??NvCopyTheRemainsDataSets_3
// 1186     return FALSE;
        MOVS     R0,#+0
        B        ??NvCopyTheRemainsDataSets_4
// 1187   dataSetIndex = 0;
??NvCopyTheRemainsDataSets_3:
        MOVS     R0,#+0
        MOVS     R5,R0
// 1188   while(dataSetsToCopy)
??NvCopyTheRemainsDataSets_5:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+0
        BEQ      ??NvCopyTheRemainsDataSets_6
// 1189   {
// 1190      if((gNvNumberOfRawPages_c - firstBlankPageIndex) < dataSetsToCopy )
        MOVS     R0,#+8
        LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
        LSRS     R7,R7,#+24
        SUBS     R0,R0,R7
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R0,R4
        BGE      ??NvCopyTheRemainsDataSets_7
// 1191        return TRUE;
        MOVS     R0,#+1
        B        ??NvCopyTheRemainsDataSets_4
// 1192      if( ( (*oldSectPageInfo)[dataSetIndex] != gUninitAddress ) && ((*newSectPageInfo)[dataSetIndex] == gUninitAddress))
??NvCopyTheRemainsDataSets_7:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R1,[SP, #+4]
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BEQ      ??NvCopyTheRemainsDataSets_8
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R1,[SP, #+8]
        LDR      R0,[R1, R0]
        MOVS     R1,#+0
        MVNS     R1,R1            ;; #-1
        CMP      R0,R1
        BNE      ??NvCopyTheRemainsDataSets_8
// 1193       {
// 1194         if( NvCopyDataSet( (*oldSectPageInfo)[dataSetIndex] , firstBlankPageAddress))
        MOVS     R1,R6
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+4
        MULS     R0,R5,R0
        LDR      R2,[SP, #+4]
        LDR      R0,[R2, R0]
        BL       NvCopyDataSet
        CMP      R0,#+0
        BEQ      ??NvCopyTheRemainsDataSets_9
// 1195         {
// 1196           dataSetsToCopy--;
        SUBS     R4,R4,#+1
// 1197           dataSetIndex++;
        ADDS     R5,R5,#+1
// 1198         }
// 1199         firstBlankPageAddress +=  sizeof(NvRawPage_t);
??NvCopyTheRemainsDataSets_9:
        MOVS     R0,#+254
        LSLS     R0,R0,#+1        ;; #+508
        ADDS     R6,R6,R0
// 1200         firstBlankPageIndex ++;
        ADDS     R7,R7,#+1
        B        ??NvCopyTheRemainsDataSets_5
// 1201       }
// 1202      else
// 1203        {
// 1204         dataSetIndex++;
??NvCopyTheRemainsDataSets_8:
        ADDS     R5,R5,#+1
        B        ??NvCopyTheRemainsDataSets_5
// 1205        }
// 1206   }
// 1207    
// 1208   return FALSE;
??NvCopyTheRemainsDataSets_6:
        MOVS     R0,#+0
??NvCopyTheRemainsDataSets_4:
        POP      {R1-R7}
        POP      {R3}
        BX       R3               ;; return
// 1209 
// 1210 }                                       /* NvCopyDataSet() */

        END
// 1211 
// 1212 
// 1213 #endif                                  /* #if !gNvStorageIncluded_d */            
// 1214 
// 1215     
// 
//    21 bytes in section .bss
//     4 bytes in section .data
// 3 132 bytes in section .text
// 
// 3 132 bytes of CODE memory
//    25 bytes of DATA memory
//
//Errors: none
//Warnings: none
