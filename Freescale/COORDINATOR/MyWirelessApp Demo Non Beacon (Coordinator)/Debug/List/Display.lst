###############################################################################
#                                                                             #
#                                                       15/Oct/2012  16:29:11 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\Display\Display.c               #
#    Command line =  "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\Display\Display.c" -D           #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xNCB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\" -lC "C:\Documents and         #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\List\" -lB "C:\Documents and         #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\List\" --diag_suppress               #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Debug\Obj\" --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\MacPhy\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Application\Init\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\Application\Interface\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\Application\Configure\" -I          #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\UartUtil\" -I "C:\Documents    #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\Application\Source\" -I             #
#                    "C:\Documents and Settings\Administrator\My              #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\TS\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\TS\Source\" -I "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\ZTC\Interface\" -I "C:\Documents and   #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\SSM\ZTC\Source\" -I "C:\Documents and      #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Interface\" -I "C:\Documents and       #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\LibInterface\" -I "C:\Documents and    #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Source\Display\" -I "C:\Documents and  #
#                    Settings\Administrator\My Documents\MyWirelessApp Demo   #
#                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon   #
#                    (Coordinator)\PLM\Source\Keyboard\" -I "C:\Documents     #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\NVM\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\TMR\" -I "C:\Documents   #
#                    and Settings\Administrator\My Documents\MyWirelessApp    #
#                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non     #
#                    Beacon (Coordinator)\PLM\Source\UART\" -I "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\Display.lst                     #
#    Object file  =  C:\Documents and Settings\Administrator\My               #
#                    Documents\MyWirelessApp Demo Non Beacon                  #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\Obj\Display.o                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\My Documents\MyWirelessApp Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon (Coordinator)\PLM\Source\Display\Display.c
      1          /************************************************************************************
      2          * This is the source file for Display Driver.
      3          *
      4          *
      5          * (c) Copyright 2008, Freescale, Inc.  All rights reserved.
      6          *
      7          *
      8          * No part of this document must be reproduced in any form - including copied,
      9          * transcribed, printed or by any electronic means - without specific written
     10          * permission from Freescale Semiconductor.
     11          ************************************************************************************/
     12          
     13          #include "EmbeddedTypes.h"
     14          #include "Display.h"
     15          #include "LCD_Font.h"
     16          #include "TS_Interface.h"
     17          #include "GPIO_Interface.h"
     18          #include "Delay.h"
     19          #include "FunctionLib.h"
     20          
     21          
     22          #ifndef gZtcIncluded_d
     23          #define gZtcIncluded_d FALSE
     24          #endif
     25          
     26          #ifndef gMacStandAlone_d
     27          #define gMacStandAlone_d FALSE
     28          #endif
     29          
     30          #ifndef gBeeStackIncluded_d
     31          #define gBeeStackIncluded_d FALSE
     32          #endif
     33          
     34          #ifndef ECNetIncluded_d
     35          #define ECNetIncluded_d FALSE
     36          #endif
     37          
     38          #ifndef SynkroIncluded_d
     39          #define SynkroIncluded_d FALSE
     40          #endif
     41          
     42          #ifndef gRF4CEIncluded_d
     43          #define gRF4CEIncluded_d FALSE
     44          #endif 
     45          
     46          #if gMacStandAlone_d
     47          #include "Mac_Globals.h"
     48          #endif
     49          
     50          #if gBeeStackIncluded_d
     51          #include "beestack_globals.h"
     52          #endif
     53          
     54          #if ECNetIncluded_d
     55          #include "ECNet_Globals.h"
     56          #endif
     57          
     58          #if SynkroIncluded_d
     59          #include "NwkGlobals.h"
     60          #endif
     61          
     62          #if gRF4CEIncluded_d
     63          #include "NwkGlobals.h"
     64          #endif 
     65          
     66          #if gZtcIncluded_d
     67          #include "ZtcInterface.h"
     68          #endif
     69          
     70          
     71          
     72          #if (gLCDSupported_d == 1)
     73          
     74          /************************************************************************************
     75          *************************************************************************************
     76          * Private macros
     77          *************************************************************************************
     78          ************************************************************************************/
     79          
     80          #define gLcdBackLightEnabled_d TRUE
     81          
     82          /* pin defines */
     83          
     84          /* D0  = SPI_SS    (GPIO  4) , PORT LO */
     85          /* D1  = SPI_MISO  (GPIO  5) , PORT LO */
     86          /* D2  = SPI_MOSI  (GPIO  6) , PORT LO */
     87          /* D3  = SPI_SCK   (GPIO  7) , PORT LO */
     88          /* D4  = ADC2      (GPIO  32), PORT HI */
     89          /* D5  = ADC3      (GPIO  33), PORT HI */
     90          /* D6  = ADC4      (GPIO  34), PORT HI */
     91          /* D7  = ADC5      (GPIO  35), PORT HI */
     92          #define LCD_D0  gGpioPin4_c
     93          #define LCD_D1  gGpioPin5_c
     94          #define LCD_D2  gGpioPin6_c
     95          #define LCD_D3  gGpioPin7_c
     96          #define LCD_D4  gGpioPin32_c
     97          #define LCD_D5  gGpioPin33_c
     98          #define LCD_D6  gGpioPin34_c
     99          #define LCD_D7  gGpioPin35_c
    100          
    101          #define LCD_DATA_LO_MASK  0x000000F0
    102          #define LCD_DATA_LO_PORT  gGpioPort0_c
    103          #define LCD_DATA_LO_WRITE(x) (x)<<4
    104          #define LCD_DATA_LO_READ(x)  (x)>>4
    105          
    106          #define LCD_DATA_HI_MASK  0x0000000F
    107          #define LCD_DATA_HI_PORT  gGpioPort1_c
    108          #define LCD_DATA_HI_WRITE(x) (x)>>4
    109          #define LCD_DATA_HI_READ(x)  (x)<<4
    110          
    111          /* A0     = UART2_RTS (GPIO  21)   inverted, 0-data, 1-command */
    112          /* RD     = TMR0      (GPIO  8)    double inverted, active high */
    113          /* WR     = TMR1      (GPIO  9)    double inverted, active high */
    114          /* CS     = UART2_CTS (GPIO  20)   double inverted, active high */
    115          /* BL_PWM = TMR2      (GPIO  10)   1 - light, 0 - dark or PWM variable duty cycle */
    116          /* RST    = RX_ON     (GPIO  45)   active low */
    117          /* RST    = UART2_RX  (GPIO  19)   active low */
    118          #define LCD_A0          gGpioPin21_c
    119          #define LCD_RD          gGpioPin8_c
    120          #define LCD_WR          gGpioPin9_c
    121          #define LCD_CS          gGpioPin20_c
    122          #define LCD_BL_PWM      gGpioPin10_c
    123          #define LCD_RSTN        gGpioPin45_c
    124          #define LCD_RSTN_debug  gGpioPin19_c
    125          
    126          
    127          /* pin states */
    128          #define LCD_A0_COMMAND  gGpioPinStateHigh_c
    129          #define LCD_A0_DATA     gGpioPinStateLow_c
    130          #define LCD_CS_ACTIVE   gGpioPinStateHigh_c
    131          #define LCD_CS_INACTIVE gGpioPinStateLow_c
    132          #define LCD_WR_ACTIVE   gGpioPinStateHigh_c
    133          #define LCD_WR_INACTIVE gGpioPinStateLow_c
    134          #define LCD_RD_ACTIVE   gGpioPinStateHigh_c
    135          #define LCD_RD_INACTIVE gGpioPinStateLow_c
    136          #define LCD_BL_ON       gGpioPinStateHigh_c
    137          #define LCD_BL_OFF      gGpioPinStateLow_c
    138          #define LCD_RSTN_IDLE   gGpioPinStateHigh_c
    139          #define LCD_RSTN_RESET  gGpioPinStateLow_c
    140          
    141          #define ON                      1
    142          #define OFF                     0
    143          
    144          #define mFontOffset_c          32
    145          
    146          /* number of columns to be cleared in LCD_Task */
    147          #define mMaxDeleteColumns_c    32
    148          #define mMaxLineNumber_c        8
    149          #define mMaxQueueEntries_c     45
    150          #define mEmptyQueue_c          0xFF
    151          
    152          /* number of characters to be displayed in LCD_Task */
    153          #define mNumberOfCharToWrite_c  3
    154          
    155          /* symbol width in pixels */
    156          #define mSymbolWidth            8
    157          
    158          /************************************************************************************
    159          *************************************************************************************
    160          * Private type definitions
    161          *************************************************************************************
    162          ************************************************************************************/
    163          /* #pragma pack(1) */
    164          
    165          typedef struct displayParams_tag{
    166            uint8_t currentXCoord;
    167            uint8_t currentYCoord;
    168            uint8_t currentLine;
    169            /* Bitmask: 
    170            *       line i is cleared, bit i from writtenLines is 0
    171            *       line i is written, bit i from writtenLines is 1 
    172            */
    173            uint8_t writtenLines;
    174            /* Bitmask: 
    175            *       line i will not be written, bit i from linesToWrite is 0
    176            *       line i will be written, bit i from linesToWrite is 1 
    177            */
    178            uint8_t linesToWrite;  
    179            uint8_t linesWidthWritten[mMaxLineNumber_c];
    180            uint8_t currentFontType;
    181            uint8_t currentStringIndex;
    182            uint8_t currentString[mMaxLineNumber_c][gMAX_LCD_CHARS_c];
    183            uint8_t currentBitmap[mMaxLineNumber_c][gMAX_LCD_CHARS_c];  
    184          }displayParams_t;
    185          
    186          typedef struct lineParams_tag{
    187            uint8_t xCoord;
    188            uint8_t yCoord;
    189            uint8_t page;  
    190          }lineParams_t;
    191          
    192          typedef struct pageParams_tag{
    193            uint8_t xStartCoord;
    194            uint8_t xEndCoord;
    195            uint8_t yCoord;
    196            uint8_t line;
    197          }pageParams_t;
    198          
    199          typedef enum operation_tag{
    200            gLCD_WriteOp_c = 0,
    201            gLCD_ClearDisplayOp_c,
    202            gLCD_ClearLineOp_c,
    203            gLCD_WriteBitmapOp_c,  
    204            gLCD_MaxOp_c = 0xFF
    205          }operation_t;
    206          
    207          typedef struct opLine_tag{
    208            operation_t opQueue;
    209            uint8_t lineQueue;  
    210          }opLine_t;
    211          
    212          typedef struct queue_tag{
    213            uint8_t head;
    214            uint8_t tail;
    215            opLine_t opLine[mMaxQueueEntries_c];
    216          }queue_t;
    217          
    218          /* #pragma pack() */
    219          
    220          /************************************************************************************
    221          *************************************************************************************
    222          * Private prototypes
    223          *************************************************************************************
    224          ************************************************************************************/
    225          
    226          void LCD_Task(event_t events);
    227          void LCD_TaskInit(void);
    228          void LCD_SetBacklight(uint8_t brightnessValue);
    229          void LCD_WritePixel(uint8_t xStartCoord, uint8_t yStartCoord, bool_t mode);
    230          void LCD_WriteCharacter(uint8_t symbol, uint8_t xCoord, uint8_t yCoord);
    231          void LCD_WriteSymbol(uint8_t index, uint8_t xCoord, uint8_t yCoord, uint8_t* bitmap);
    232          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord);
    233          uint8_t LCD_ClearLine(uint8_t line);
    234          
    235          static void ProcessOperation(opLine_t operationAndLine); 
    236          static void SendData(uint8_t data);
    237          static void SetHiZ(void);
    238          static void SetOutput(void);
    239          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord);
    240          static uint8_t ReadData(void);
    241          static uint8_t GetData(void);
    242          static uint8_t GetStrlen(const uint8_t *pString);
    243          
    244          static void     InitQueue(void);
    245          static bool_t   AddToQueue(opLine_t operationLine);
    246          static opLine_t RemoveFromQueue(void);
    247          static bool_t   IsQueueEmpty(void);
    248          static bool_t   IsQueueFull(void);
    249          
    250          /************************************************************************************
    251          *************************************************************************************
    252          * Private memory declarations
    253          *************************************************************************************
    254          ************************************************************************************/
    255          

   \                                 In section .data, align 4
    256          static displayParams_t mDisplayParams = {
   \                     mDisplayParams:
   \   00000000   000000FF0000       DC8 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              000000      
   \   00000015   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000025   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000035   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000045   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000055   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000065   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000075   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000085   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000095   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000A5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000B5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000C5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000D5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000E5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000F5   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000105   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0000000000  
    257            /* currentXCoord */
    258            0x00,
    259            /* currentYCoord */
    260            0x00,
    261            /* currentLine */
    262            0x00,
    263            /* writtenLines */
    264            0xFF,
    265            /* linesToWrite */
    266            0x00,
    267            /* linesWidthWritten */
    268            0x00,
    269            /* currentFontType */
    270            0x00,
    271            /* currentStringIndex */
    272            0x00,  
    273            /* currentString */
    274            0x00,
    275            /* currentBitmap */
    276            0x00
    277          };
    278          

   \                                 In section .data, align 4
    279          static lineParams_t mLineParams[mMaxLineNumber_c] = {
   \                     mLineParams:
   \   00000000   000000000801       DC8 0, 0, 0, 0, 8, 1, 0, 16, 2, 0, 24, 3, 0, 32, 4, 0, 40, 5, 0, 48, 6
   \              001002001803
   \              002004002805
   \              003006      
   \   00000015   003807             DC8 0, 56, 7
    280            {0, 0, 0},
    281            {0, 8, 1},
    282            {0, 16, 2},
    283            {0, 24, 3},
    284            {0, 32, 4},
    285            {0, 40, 5},
    286            {0, 48, 6},
    287            {0, 56, 7},
    288          };  
    289          

   \                                 In section .data, align 1
    290          static bool_t mOperationCompleted = TRUE;
   \                     mOperationCompleted:
   \   00000000   01                 DC8 1
    291          

   \                                 In section .bss, align 4
    292          static queue_t mQueue;
   \                     mQueue:
   \   00000000                      DS8 92
    293          
    294          /* after initialization, all LCD lines must be erased */

   \                                 In section .bss, align 1
    295          static bool_t mIsLcdInitialized = FALSE;
   \                     mIsLcdInitialized:
   \   00000000                      DS8 1
    296          
    297          /* error indicator, used for error reporting */

   \                                 In section .bss, align 1
    298          static volatile lcdError_t mErrorIndicator = gLCD_NoError_c;
   \                     mErrorIndicator:
   \   00000000                      DS8 1
    299          

   \                                 In section .bss, align 4
    300          static uint8_t* mReceivedBitmap = NULL;
   \                     mReceivedBitmap:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    301          static uint8_t  mBitmapSpace[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
   \                     mBitmapSpace:
   \   00000000                      DS8 8
    302          
    303          /******************************************************************************
    304          *******************************************************************************
    305          * Public memory definitions
    306          *******************************************************************************
    307          ******************************************************************************/
    308          

   \                                 In section .bss, align 1
    309          tsTaskID_t gLCDTaskID;
   \                     gLCDTaskID:
   \   00000000                      DS8 1

   \                                 In section .rodata, align 4
    310          const uint8_t gaHexValue[] = "0123456789ABCDEF";
   \                     gaHexValue:
   \   00000000   303132333435       DC8 "0123456789ABCDEF"
   \              363738394142
   \              4344454600  
   \   00000011   000000             DC8 0, 0, 0
    311          

   \                                 In section .rodata, align 4
    312          const font_t aLCDFont[gLCDNumFonts_c] = 
   \                     aLCDFont:
   \   00000000   ............       DC32 gLCDNormalIndex, gLCDNormalFont
   \              ....        
   \   00000008   01000000           DC8 1, 0, 0, 0
   \   0000000C   ............       DC32 gLCDVerdanaIndex, gLCDVerdanaFont
   \              ....        
   \   00000014   02000000           DC8 2, 0, 0, 0
    313          {
    314            /* character font with fixed width */ 
    315            {gLCDNormalIndex,  gLCDNormalFont,  1},
    316            /* character font with variable width */ 
    317            {gLCDVerdanaIndex, gLCDVerdanaFont, 2}   
    318          };
    319          
    320          /************************************************************************************
    321          *************************************************************************************
    322          * Public functions
    323          *************************************************************************************
    324          ************************************************************************************/
    325          
    326          /******************************************************************************
    327          * This function initializes the display
    328          *
    329          * Interface assumptions:
    330          *
    331          *
    332          * Return value:
    333          * None
    334          *
    335          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    336          void LCD_Init(void)
    337          {
   \                     LCD_Init:
   \   00000000   80B5               PUSH     {R7,LR}
    338          #if ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE))
    339              uint8_t ctr;
    340          #endif /* ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE)) */     
    341          
    342              Gpio_SetPinFunction(LCD_WR, gGpioNormalMode_c);
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0920               MOVS     R0,#+9
   \   00000006   ........           BL       Gpio_SetPinFunction
    343              Gpio_SetPinFunction(LCD_CS, gGpioNormalMode_c);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   1420               MOVS     R0,#+20
   \   0000000E   ........           BL       Gpio_SetPinFunction
    344              Gpio_SetPinFunction(LCD_RD, gGpioNormalMode_c);
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   0820               MOVS     R0,#+8
   \   00000016   ........           BL       Gpio_SetPinFunction
    345              Gpio_SetPinFunction(LCD_A0, gGpioNormalMode_c);
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   1520               MOVS     R0,#+21
   \   0000001E   ........           BL       Gpio_SetPinFunction
    346              Gpio_SetPinFunction(LCD_RSTN, gGpioNormalMode_c);
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   2D20               MOVS     R0,#+45
   \   00000026   ........           BL       Gpio_SetPinFunction
    347              Gpio_SetPinFunction(LCD_RSTN_debug, gGpioNormalMode_c);
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   1320               MOVS     R0,#+19
   \   0000002E   ........           BL       Gpio_SetPinFunction
    348          
    349              Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   0920               MOVS     R0,#+9
   \   00000036   ........           BL       Gpio_SetPinData
    350              Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \   0000003A   0021               MOVS     R1,#+0
   \   0000003C   1420               MOVS     R0,#+20
   \   0000003E   ........           BL       Gpio_SetPinData
    351              Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   0820               MOVS     R0,#+8
   \   00000046   ........           BL       Gpio_SetPinData
    352              Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   1520               MOVS     R0,#+21
   \   0000004E   ........           BL       Gpio_SetPinData
    353              Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
   \   00000052   0121               MOVS     R1,#+1
   \   00000054   2D20               MOVS     R0,#+45
   \   00000056   ........           BL       Gpio_SetPinData
    354              Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   1320               MOVS     R0,#+19
   \   0000005E   ........           BL       Gpio_SetPinData
    355          
    356              /* define the LCD pins as output pins */
    357              (void)Gpio_SetPinReadSource(LCD_CS,     gGpioPinReadReg_c);
   \   00000062   0121               MOVS     R1,#+1
   \   00000064   1420               MOVS     R0,#+20
   \   00000066   ........           BL       Gpio_SetPinReadSource
    358              (void)Gpio_SetPinReadSource(LCD_A0,     gGpioPinReadReg_c);
   \   0000006A   0121               MOVS     R1,#+1
   \   0000006C   1520               MOVS     R0,#+21
   \   0000006E   ........           BL       Gpio_SetPinReadSource
    359              (void)Gpio_SetPinReadSource(LCD_RD,     gGpioPinReadReg_c);
   \   00000072   0121               MOVS     R1,#+1
   \   00000074   0820               MOVS     R0,#+8
   \   00000076   ........           BL       Gpio_SetPinReadSource
    360              (void)Gpio_SetPinReadSource(LCD_WR,     gGpioPinReadReg_c);
   \   0000007A   0121               MOVS     R1,#+1
   \   0000007C   0920               MOVS     R0,#+9
   \   0000007E   ........           BL       Gpio_SetPinReadSource
    361              (void)Gpio_SetPinReadSource(LCD_BL_PWM, gGpioPinReadReg_c);
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   0A20               MOVS     R0,#+10
   \   00000086   ........           BL       Gpio_SetPinReadSource
    362              (void)Gpio_SetPinReadSource(LCD_RSTN,   gGpioPinReadReg_c);
   \   0000008A   0121               MOVS     R1,#+1
   \   0000008C   2D20               MOVS     R0,#+45
   \   0000008E   ........           BL       Gpio_SetPinReadSource
    363              (void)Gpio_SetPinReadSource(LCD_RSTN_debug,   gGpioPinReadReg_c);
   \   00000092   0121               MOVS     R1,#+1
   \   00000094   1320               MOVS     R0,#+19
   \   00000096   ........           BL       Gpio_SetPinReadSource
    364          
    365              (void)Gpio_SetPinDir(LCD_CS,     gGpioDirOut_c);
   \   0000009A   0121               MOVS     R1,#+1
   \   0000009C   1420               MOVS     R0,#+20
   \   0000009E   ........           BL       Gpio_SetPinDir
    366              (void)Gpio_SetPinDir(LCD_A0,     gGpioDirOut_c);
   \   000000A2   0121               MOVS     R1,#+1
   \   000000A4   1520               MOVS     R0,#+21
   \   000000A6   ........           BL       Gpio_SetPinDir
    367              (void)Gpio_SetPinDir(LCD_RD,     gGpioDirOut_c);
   \   000000AA   0121               MOVS     R1,#+1
   \   000000AC   0820               MOVS     R0,#+8
   \   000000AE   ........           BL       Gpio_SetPinDir
    368              (void)Gpio_SetPinDir(LCD_WR,     gGpioDirOut_c);
   \   000000B2   0121               MOVS     R1,#+1
   \   000000B4   0920               MOVS     R0,#+9
   \   000000B6   ........           BL       Gpio_SetPinDir
    369              (void)Gpio_SetPinDir(LCD_BL_PWM, gGpioDirOut_c);
   \   000000BA   0121               MOVS     R1,#+1
   \   000000BC   0A20               MOVS     R0,#+10
   \   000000BE   ........           BL       Gpio_SetPinDir
    370              (void)Gpio_SetPinDir(LCD_RSTN,   gGpioDirOut_c);
   \   000000C2   0121               MOVS     R1,#+1
   \   000000C4   2D20               MOVS     R0,#+45
   \   000000C6   ........           BL       Gpio_SetPinDir
    371              (void)Gpio_SetPinDir(LCD_RSTN_debug,   gGpioDirOut_c);
   \   000000CA   0121               MOVS     R1,#+1
   \   000000CC   1320               MOVS     R0,#+19
   \   000000CE   ........           BL       Gpio_SetPinDir
    372          
    373              /* data pins */
    374          #if gLCDGpioPinMode_c
    375              (void)Gpio_SetPinFunction(LCD_D0,      gGpioNormalMode_c);
    376              (void)Gpio_SetPinFunction(LCD_D1,      gGpioNormalMode_c);
    377              (void)Gpio_SetPinFunction(LCD_D2,      gGpioNormalMode_c);
    378              (void)Gpio_SetPinFunction(LCD_D3,      gGpioNormalMode_c);
    379              (void)Gpio_SetPinFunction(LCD_D4,      gGpioNormalMode_c);
    380              (void)Gpio_SetPinFunction(LCD_D5,      gGpioNormalMode_c);
    381              (void)Gpio_SetPinFunction(LCD_D6,      gGpioNormalMode_c);
    382              (void)Gpio_SetPinFunction(LCD_D7,      gGpioNormalMode_c);
    383          
    384              /* define data pins as inputs */
    385              (void)Gpio_EnPinPullup(LCD_D0,      TRUE);
    386              (void)Gpio_EnPinPullup(LCD_D1,      TRUE);
    387              (void)Gpio_EnPinPullup(LCD_D2,      TRUE);
    388              (void)Gpio_EnPinPullup(LCD_D3,      TRUE);
    389              (void)Gpio_EnPinPullup(LCD_D4,      TRUE);
    390              (void)Gpio_EnPinPullup(LCD_D5,      TRUE);
    391              (void)Gpio_EnPinPullup(LCD_D6,      TRUE);
    392              (void)Gpio_EnPinPullup(LCD_D7,      TRUE);
    393          
    394              (void)Gpio_SelectPinPullup(LCD_D0,      gGpioPinPullup_c);
    395              (void)Gpio_SelectPinPullup(LCD_D1,      gGpioPinPullup_c);
    396              (void)Gpio_SelectPinPullup(LCD_D2,      gGpioPinPullup_c);
    397              (void)Gpio_SelectPinPullup(LCD_D3,      gGpioPinPullup_c);
    398              (void)Gpio_SelectPinPullup(LCD_D4,      gGpioPinPullup_c);
    399              (void)Gpio_SelectPinPullup(LCD_D5,      gGpioPinPullup_c);
    400              (void)Gpio_SelectPinPullup(LCD_D6,      gGpioPinPullup_c);
    401              (void)Gpio_SelectPinPullup(LCD_D7,      gGpioPinPullup_c);
    402          
    403              (void)Gpio_EnPinPuKeeper(LCD_D0,      TRUE);
    404              (void)Gpio_EnPinPuKeeper(LCD_D1,      TRUE);
    405              (void)Gpio_EnPinPuKeeper(LCD_D2,      TRUE);
    406              (void)Gpio_EnPinPuKeeper(LCD_D3,      TRUE);
    407              (void)Gpio_EnPinPuKeeper(LCD_D4,      TRUE);
    408              (void)Gpio_EnPinPuKeeper(LCD_D5,      TRUE);
    409              (void)Gpio_EnPinPuKeeper(LCD_D6,      TRUE);
    410              (void)Gpio_EnPinPuKeeper(LCD_D7,      TRUE);
    411          
    412              (void)Gpio_SetPinReadSource(LCD_D0,      gGpioPinReadPad_c);
    413              (void)Gpio_SetPinReadSource(LCD_D1,      gGpioPinReadPad_c);
    414              (void)Gpio_SetPinReadSource(LCD_D2,      gGpioPinReadPad_c);
    415              (void)Gpio_SetPinReadSource(LCD_D3,      gGpioPinReadPad_c);
    416              (void)Gpio_SetPinReadSource(LCD_D4,      gGpioPinReadPad_c);
    417              (void)Gpio_SetPinReadSource(LCD_D5,      gGpioPinReadPad_c);
    418              (void)Gpio_SetPinReadSource(LCD_D6,      gGpioPinReadPad_c);
    419              (void)Gpio_SetPinReadSource(LCD_D7,      gGpioPinReadPad_c);
    420          
    421              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
    422              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
    423              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
    424              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
    425              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
    426              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
    427              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
    428              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
    429          #else /* gLCDGpioPinMode_c */
    430              Gpio_SetPortFunction(LCD_DATA_LO_PORT, gGpioNormalMode_c, LCD_DATA_LO_MASK);
   \   000000D2   F022               MOVS     R2,#+240
   \   000000D4   0021               MOVS     R1,#+0
   \   000000D6   0020               MOVS     R0,#+0
   \   000000D8   ........           BL       Gpio_SetPortFunction
    431              Gpio_SetPortFunction(LCD_DATA_HI_PORT, gGpioNormalMode_c, LCD_DATA_HI_MASK);
   \   000000DC   0F22               MOVS     R2,#+15
   \   000000DE   0021               MOVS     R1,#+0
   \   000000E0   0120               MOVS     R0,#+1
   \   000000E2   ........           BL       Gpio_SetPortFunction
    432          
    433              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpEnAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \   000000E6   F023               MOVS     R3,#+240
   \   000000E8   F022               MOVS     R2,#+240
   \   000000EA   0321               MOVS     R1,#+3
   \   000000EC   0020               MOVS     R0,#+0
   \   000000EE   ........           BL       Gpio_WrPortSetting
    434              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpEnAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \   000000F2   0F23               MOVS     R3,#+15
   \   000000F4   0F22               MOVS     R2,#+15
   \   000000F6   0321               MOVS     R1,#+3
   \   000000F8   0120               MOVS     R0,#+1
   \   000000FA   ........           BL       Gpio_WrPortSetting
    435          
    436              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpSelAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \   000000FE   F023               MOVS     R3,#+240
   \   00000100   F022               MOVS     R2,#+240
   \   00000102   0421               MOVS     R1,#+4
   \   00000104   0020               MOVS     R0,#+0
   \   00000106   ........           BL       Gpio_WrPortSetting
    437              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpSelAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \   0000010A   0F23               MOVS     R3,#+15
   \   0000010C   0F22               MOVS     R2,#+15
   \   0000010E   0421               MOVS     R1,#+4
   \   00000110   0120               MOVS     R0,#+1
   \   00000112   ........           BL       Gpio_WrPortSetting
    438          
    439              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \   00000116   F023               MOVS     R3,#+240
   \   00000118   F022               MOVS     R2,#+240
   \   0000011A   0621               MOVS     R1,#+6
   \   0000011C   0020               MOVS     R0,#+0
   \   0000011E   ........           BL       Gpio_WrPortSetting
    440              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioPullUpKeepAttr_c, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \   00000122   0F23               MOVS     R3,#+15
   \   00000124   0F22               MOVS     R2,#+15
   \   00000126   0621               MOVS     R1,#+6
   \   00000128   0120               MOVS     R0,#+1
   \   0000012A   ........           BL       Gpio_WrPortSetting
    441              
    442              Gpio_WrPortSetting(LCD_DATA_LO_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \   0000012E   F023               MOVS     R3,#+240
   \   00000130   F022               MOVS     R2,#+240
   \   00000132   D243               MVNS     R2,R2            ;; #-241
   \   00000134   0221               MOVS     R1,#+2
   \   00000136   0020               MOVS     R0,#+0
   \   00000138   ........           BL       Gpio_WrPortSetting
    443              Gpio_WrPortSetting(LCD_DATA_HI_PORT, gGpioInputDataSelAttr_c, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \   0000013C   0F23               MOVS     R3,#+15
   \   0000013E   0F22               MOVS     R2,#+15
   \   00000140   D243               MVNS     R2,R2            ;; #-16
   \   00000142   0221               MOVS     R1,#+2
   \   00000144   0120               MOVS     R0,#+1
   \   00000146   ........           BL       Gpio_WrPortSetting
    444              
    445              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);
   \   0000014A   F022               MOVS     R2,#+240
   \   0000014C   F021               MOVS     R1,#+240
   \   0000014E   C943               MVNS     R1,R1            ;; #-241
   \   00000150   0020               MOVS     R0,#+0
   \   00000152   ........           BL       Gpio_SetPortDir
    446              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);
   \   00000156   0F22               MOVS     R2,#+15
   \   00000158   0F21               MOVS     R1,#+15
   \   0000015A   C943               MVNS     R1,R1            ;; #-16
   \   0000015C   0120               MOVS     R0,#+1
   \   0000015E   ........           BL       Gpio_SetPortDir
    447          #endif /* gLCDGpioPinMode_c */
    448          
    449          
    450            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_RESET);
   \   00000162   0021               MOVS     R1,#+0
   \   00000164   2D20               MOVS     R0,#+45
   \   00000166   ........           BL       Gpio_SetPinData
    451            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_RESET);
   \   0000016A   0021               MOVS     R1,#+0
   \   0000016C   1320               MOVS     R0,#+19
   \   0000016E   ........           BL       Gpio_SetPinData
    452            DelayUs(10);
   \   00000172   0A20               MOVS     R0,#+10
   \   00000174   ........           BL       DelayUs
    453            Gpio_SetPinData(LCD_RSTN, LCD_RSTN_IDLE);
   \   00000178   0121               MOVS     R1,#+1
   \   0000017A   2D20               MOVS     R0,#+45
   \   0000017C   ........           BL       Gpio_SetPinData
    454            Gpio_SetPinData(LCD_RSTN_debug, LCD_RSTN_IDLE);
   \   00000180   0121               MOVS     R1,#+1
   \   00000182   1320               MOVS     R0,#+19
   \   00000184   ........           BL       Gpio_SetPinData
    455            DelayMs(1);
   \   00000188   0120               MOVS     R0,#+1
   \   0000018A   ........           BL       DelayMs
    456          
    457              /* Turn ON the VDD-VSS power keeping the RES pin = LOW for 0.5us */
    458              /* When power is stabilized, relese the RES pin (RES pin = HIGH) */
    459              
    460              /* Default initialized state: 
    461               - Display off
    462          	   - Normal display (COM0 --> COM63)
    463          	   - ADC select: normal (RAM column address n <-> SEGn)
    464          	   - Power control register: Booster circuit OFF, Voltage regulator circuit OFF, Voltage follower circuit OFF
    465          	   - LCD power supply bias rate = 1/9
    466          	   - All-indicator lamps-on OFF
    467          	   - Power saving clear
    468          	   - V5 voltage regulator internal resistors Ra and Rb separation
    469          	   - Output conditions of SEG and COM terminals SEG:V2/V3; COM: V1/V4
    470          	   - Read modify write OFF
    471          	   - Static indicator OFF
    472          	   - Display start line set to first line
    473          	   - Column address set to Address 0
    474          	   - Page address set to Page 0
    475          	   - Common output status normal
    476          	   - V5 voltage regulator internal resistor ratio set mode clear
    477          	   - Electronic volume register set mode clear
    478          	   - Test mode clear 
    479              */
    480          
    481              /* reset display */
    482              LCD_WriteCommand(gLCDResetCommand_c);
   \   0000018E   E220               MOVS     R0,#+226
   \   00000190   ........           BL       LCD_WriteCommand
    483              DelayUs(10);
   \   00000194   0A20               MOVS     R0,#+10
   \   00000196   ........           BL       DelayUs
    484          
    485              /* set LCD bias to 1/9 */
    486              LCD_WriteCommand(gLCD19BiasCommand_c);
   \   0000019A   A220               MOVS     R0,#+162
   \   0000019C   ........           BL       LCD_WriteCommand
    487          
    488              /* set ADC selection to normal: RAM column address n <-> SEGn */
    489              /* LCD_WriteCommand(gLCDADCNormalCommand_c); */
    490              LCD_WriteCommand(gLCDADCReverseCommand_c);
   \   000001A0   A120               MOVS     R0,#+161
   \   000001A2   ........           BL       LCD_WriteCommand
    491          
    492              /* set scan direction of the COM to normal: COM0 --> COM63 */
    493              LCD_WriteCommand(gLCDComNormalCommand_c);
   \   000001A6   C020               MOVS     R0,#+192
   \   000001A8   ........           BL       LCD_WriteCommand
    494          
    495              /* set the Rb/Ra ratio for V5 to medium (D2D1D0 = 0b100) */
    496              LCD_WriteCommand( gLCDDefaultRatioCommand_c | (gLCDRatioValue_c & 0x07) );
   \   000001AC   2420               MOVS     R0,#+36
   \   000001AE   ........           BL       LCD_WriteCommand
    497          
    498              /* enable the electronic volume register set command */
    499              /* this command must always be followed by an electronic volume register set command */
    500              LCD_WriteCommand(gLCDElectronicVolumeModeSetCommand_c);
   \   000001B2   8120               MOVS     R0,#+129
   \   000001B4   ........           BL       LCD_WriteCommand
    501              
    502              LCD_WriteCommand(gLCDElectronicVolumeInitCommand_c);
   \   000001B8   3020               MOVS     R0,#+48
   \   000001BA   ........           BL       LCD_WriteCommand
    503          
    504          
    505              /* disable booster circuit, disable voltage regulator circuit, disable voltage follower circuit */
    506              LCD_WriteCommand(0x2F);
   \   000001BE   2F20               MOVS     R0,#+47
   \   000001C0   ........           BL       LCD_WriteCommand
    507              DelayUs(10);
   \   000001C4   0A20               MOVS     R0,#+10
   \   000001C6   ........           BL       DelayUs
    508              /** turn ON */
    509              LCD_WriteCommand(gLCDDisplayOnCommand_c);
   \   000001CA   AF20               MOVS     R0,#+175
   \   000001CC   ........           BL       LCD_WriteCommand
    510              DelayUs(10);
   \   000001D0   0A20               MOVS     R0,#+10
   \   000001D2   ........           BL       DelayUs
    511              
    512              /* create LCD task */
    513              LCD_TaskInit();
   \   000001D6   ........           BL       LCD_TaskInit
    514              
    515              /* turn on the backlight */
    516              LCD_SetBacklight(1);
   \   000001DA   0120               MOVS     R0,#+1
   \   000001DC   ........           BL       LCD_SetBacklight
    517              
    518              /* set default font */
    519              (void)LCD_SetFont(gLCD_NormalFont_c);
   \   000001E0   0020               MOVS     R0,#+0
   \   000001E2   ........           BL       LCD_SetFont
    520              InitQueue();  
   \   000001E6   ........           BL       InitQueue
    521              mIsLcdInitialized = FALSE;
   \   000001EA   ....               LDR      R0,??DataTable2
   \   000001EC   0021               MOVS     R1,#+0
   \   000001EE   0170               STRB     R1,[R0, #+0]
    522              /* clear display */
    523          #if ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE))
    524              /* During test mode, the LCD operation queue is not used. */
    525              /* Because of this, LCD_ClearDisplay is not called. */
    526              for(ctr = 0; ctr < gLCDMaxRamDataPages_c; ctr++)
    527              {
    528                LCD_ClearPage(0, gLCDMaxColumns_c, ctr*8);
    529              }
    530          #else
    531              LCD_ClearDisplay();
   \   000001F0   ........           BL       LCD_ClearDisplay
    532          #endif /* ((gZtcIncluded_d ==TRUE) && (gSAPMessagesEnableLlc_d == TRUE)) */    
    533          }
   \   000001F4   09BC               POP      {R0,R3}
   \   000001F6   1847               BX       R3               ;; return
    534          
    535          /******************************************************************************
    536          * This function clears the display. In case an error occured during add to queue
    537          * operation, the clear display operation will not execute.
    538          *
    539          * Interface assumptions:
    540          *
    541          *
    542          * Return value:
    543          * None
    544          *
    545          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    546          void LCD_ClearDisplay(void)
    547          {
   \                     LCD_ClearDisplay:
   \   00000000   80B5               PUSH     {R7,LR}
    548            opLine_t operationLine;
    549            
    550            /* clear the error indicator */
    551            mErrorIndicator = gLCD_NoError_c;
   \   00000002   ....               LDR      R0,??DataTable3
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
    552            
    553            operationLine.opQueue   = gLCD_ClearDisplayOp_c;
   \   00000008   6846               MOV      R0,SP
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   0170               STRB     R1,[R0, #+0]
    554            operationLine.lineQueue = mMaxLineNumber_c;
   \   0000000E   6846               MOV      R0,SP
   \   00000010   0821               MOVS     R1,#+8
   \   00000012   4170               STRB     R1,[R0, #+1]
    555            
    556            if(TRUE == AddToQueue(operationLine))
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   ........           BL       AddToQueue
   \   0000001A   0128               CMP      R0,#+1
   \   0000001C   05D1               BNE      ??LCD_ClearDisplay_0
    557            {
    558              /* send a clear display event */
    559              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);       
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   ....               LDR      R0,??DataTable3_1
   \   00000022   0078               LDRB     R0,[R0, #+0]
   \   00000024   ........           BL       TS_SendEvent
   \   00000028   02E0               B        ??LCD_ClearDisplay_1
    560            }
    561            else
    562            {
    563              /* LCD queue is full */
    564              mErrorIndicator = gLCD_QueueFull_c;
   \                     ??LCD_ClearDisplay_0:
   \   0000002A   ....               LDR      R0,??DataTable3
   \   0000002C   0121               MOVS     R1,#+1
   \   0000002E   0170               STRB     R1,[R0, #+0]
    565            }  
    566          }
   \                     ??LCD_ClearDisplay_1:
   \   00000030   09BC               POP      {R0,R3}
   \   00000032   1847               BX       R3               ;; return
    567          
    568          /******************************************************************************
    569          * This function writes a string to the display. In case an error occured 
    570          * during add to queue operation, the write string operation will not execute.
    571          *
    572          * Interface assumptions:
    573          *
    574          *
    575          * Return value:
    576          * None
    577          *
    578          *
    579          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    580          void LCD_WriteString(uint8_t line, uint8_t *pstr)
    581          {
   \                     LCD_WriteString:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    582            uint8_t stringWidth = 0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0600               MOVS     R6,R0
    583            uint8_t len, i;
    584            uint8_t ctr;
    585            uint8_t auxLine;
    586            const uint8_t error[] = "Wrong line";
   \   00000008   02A8               ADD      R0,SP,#+8
   \   0000000A   ....               LDR      R1,??DataTable3_2
   \   0000000C   0B22               MOVS     R2,#+11
   \   0000000E   ........           BL       __aeabi_memcpy4
    587            opLine_t operationLine;
    588            
    589            /* clear the error indicator */
    590            mErrorIndicator = gLCD_NoError_c;
   \   00000012   ....               LDR      R0,??DataTable3
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0170               STRB     R1,[R0, #+0]
    591            
    592            /* in case of NULL pointers, just return */  
    593            if(pstr == NULL)
   \   00000018   0698               LDR      R0,[SP, #+24]
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   00D1               BNE      .+4
   \   0000001E   DDE0               B        ??LCD_WriteString_0
    594            {
    595              return;
    596            }  
    597            
    598            auxLine = line;
   \                     ??LCD_WriteString_1:
   \   00000020   6846               MOV      R0,SP
   \   00000022   007D               LDRB     R0,[R0, #+20]
   \   00000024   0500               MOVS     R5,R0
    599            
    600            /* in case a character height is bigger then 1, lines must have "height" offset between them */
    601            if(aLCDFont[mDisplayParams.currentFontType].fontHeight > 1)
   \   00000026   ....               LDR      R0,??DataTable3_3
   \   00000028   407B               LDRB     R0,[R0, #+13]
   \   0000002A   0C21               MOVS     R1,#+12
   \   0000002C   4843               MULS     R0,R1,R0
   \   0000002E   ....               LDR      R1,??DataTable3_4
   \   00000030   0818               ADDS     R0,R1,R0
   \   00000032   007A               LDRB     R0,[R0, #+8]
   \   00000034   0228               CMP      R0,#+2
   \   00000036   19D3               BCC      ??LCD_WriteString_2
    602            {
    603              switch(auxLine)
   \   00000038   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003A   2D0E               LSRS     R5,R5,#+24
   \   0000003C   2800               MOVS     R0,R5
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   0328               CMP      R0,#+3
   \   00000042   08D8               BHI      ??LCD_WriteString_3
    604              {
    605                case 0:
    606                case 1:
    607                case 2:
    608                case 3:        
    609                  auxLine *= aLCDFont[mDisplayParams.currentFontType].fontHeight;
   \                     ??LCD_WriteString_4:
   \   00000044   ....               LDR      R0,??DataTable3_3
   \   00000046   407B               LDRB     R0,[R0, #+13]
   \   00000048   0C21               MOVS     R1,#+12
   \   0000004A   4843               MULS     R0,R1,R0
   \   0000004C   ....               LDR      R1,??DataTable3_4
   \   0000004E   0818               ADDS     R0,R1,R0
   \   00000050   007A               LDRB     R0,[R0, #+8]
   \   00000052   4543               MULS     R5,R0,R5
   \   00000054   12E0               B        ??LCD_WriteString_5
    610                  break;      
    611                default:
    612                  auxLine = aLCDFont[mDisplayParams.currentFontType].fontHeight;
   \                     ??LCD_WriteString_3:
   \   00000056   ....               LDR      R0,??DataTable3_3
   \   00000058   407B               LDRB     R0,[R0, #+13]
   \   0000005A   0C21               MOVS     R1,#+12
   \   0000005C   4843               MULS     R0,R1,R0
   \   0000005E   ....               LDR      R1,??DataTable3_4
   \   00000060   0818               ADDS     R0,R1,R0
   \   00000062   007A               LDRB     R0,[R0, #+8]
   \   00000064   0500               MOVS     R5,R0
    613                  pstr = (uint8_t*)error; 
   \   00000066   02A8               ADD      R0,SP,#+8
   \   00000068   0690               STR      R0,[SP, #+24]
   \   0000006A   07E0               B        ??LCD_WriteString_5
    614                  break;      
    615              }        
    616            }
    617            else
    618            {
    619              if(line >= gLCDMaxRamDataPages_c)   
   \                     ??LCD_WriteString_2:
   \   0000006C   6846               MOV      R0,SP
   \   0000006E   007D               LDRB     R0,[R0, #+20]
   \   00000070   0828               CMP      R0,#+8
   \   00000072   03D3               BCC      ??LCD_WriteString_5
    620              {
    621                auxLine = 1;
   \   00000074   0120               MOVS     R0,#+1
   \   00000076   0500               MOVS     R5,R0
    622                pstr = (uint8_t*)error; 
   \   00000078   02A8               ADD      R0,SP,#+8
   \   0000007A   0690               STR      R0,[SP, #+24]
    623              }
    624            }
    625            
    626            len = GetStrlen(pstr);
   \                     ??LCD_WriteString_5:
   \   0000007C   0698               LDR      R0,[SP, #+24]
   \   0000007E   ........           BL       GetStrlen
   \   00000082   6946               MOV      R1,SP
   \   00000084   0871               STRB     R0,[R1, #+4]
    627          
    628            FLib_MemCpy(&mDisplayParams.currentString[auxLine], pstr, len);
   \   00000086   6846               MOV      R0,SP
   \   00000088   0279               LDRB     R2,[R0, #+4]
   \   0000008A   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   0000008C   120C               LSRS     R2,R2,#+16
   \   0000008E   0699               LDR      R1,[SP, #+24]
   \   00000090   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000092   2D0E               LSRS     R5,R5,#+24
   \   00000094   1020               MOVS     R0,#+16
   \   00000096   6843               MULS     R0,R5,R0
   \   00000098   ....               LDR      R3,??DataTable3_3
   \   0000009A   1818               ADDS     R0,R3,R0
   \   0000009C   0F30               ADDS     R0,R0,#+15
   \   0000009E   ........           BL       FLib_MemCpy
    629            
    630            /* Clear the rest of the line */
    631            if(len < gMAX_LCD_CHARS_c)
   \   000000A2   6846               MOV      R0,SP
   \   000000A4   0079               LDRB     R0,[R0, #+4]
   \   000000A6   1028               CMP      R0,#+16
   \   000000A8   13D2               BCS      ??LCD_WriteString_6
    632            {
    633              for(ctr = len; ctr < gMAX_LCD_CHARS_c;ctr++)
   \   000000AA   6846               MOV      R0,SP
   \   000000AC   0079               LDRB     R0,[R0, #+4]
   \   000000AE   0700               MOVS     R7,R0
   \                     ??LCD_WriteString_7:
   \   000000B0   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   000000B2   3F0E               LSRS     R7,R7,#+24
   \   000000B4   102F               CMP      R7,#+16
   \   000000B6   0CD2               BCS      ??LCD_WriteString_6
    634              {
    635                mDisplayParams.currentString[auxLine][ctr]=' ';      
   \   000000B8   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   000000BA   3F0E               LSRS     R7,R7,#+24
   \   000000BC   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000BE   2D0E               LSRS     R5,R5,#+24
   \   000000C0   1020               MOVS     R0,#+16
   \   000000C2   6843               MULS     R0,R5,R0
   \   000000C4   ....               LDR      R1,??DataTable3_3
   \   000000C6   0818               ADDS     R0,R1,R0
   \   000000C8   C019               ADDS     R0,R0,R7
   \   000000CA   2021               MOVS     R1,#+32
   \   000000CC   C173               STRB     R1,[R0, #+15]
    636              }
   \   000000CE   7F1C               ADDS     R7,R7,#+1
   \   000000D0   EEE7               B        ??LCD_WriteString_7
    637            }
    638          
    639            /* compute the width (in pixels) of the string that will be written */
    640            for(i=0; i<gMAX_LCD_CHARS_c; i++)
   \                     ??LCD_WriteString_6:
   \   000000D2   0020               MOVS     R0,#+0
   \   000000D4   0400               MOVS     R4,R0
   \                     ??LCD_WriteString_8:
   \   000000D6   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000D8   240E               LSRS     R4,R4,#+24
   \   000000DA   102C               CMP      R4,#+16
   \   000000DC   2DD2               BCS      ??LCD_WriteString_9
    641            {
    642              stringWidth += (aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[auxLine][i] - mFontOffset_c + 1] - \
    643                               aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[auxLine][i] - mFontOffset_c]);    
   \   000000DE   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000E0   240E               LSRS     R4,R4,#+24
   \   000000E2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000E4   2D0E               LSRS     R5,R5,#+24
   \   000000E6   1020               MOVS     R0,#+16
   \   000000E8   6843               MULS     R0,R5,R0
   \   000000EA   ....               LDR      R1,??DataTable3_3
   \   000000EC   0818               ADDS     R0,R1,R0
   \   000000EE   0019               ADDS     R0,R0,R4
   \   000000F0   C07B               LDRB     R0,[R0, #+15]
   \   000000F2   0221               MOVS     R1,#+2
   \   000000F4   4843               MULS     R0,R1,R0
   \   000000F6   ....               LDR      R1,??DataTable3_3
   \   000000F8   497B               LDRB     R1,[R1, #+13]
   \   000000FA   0C22               MOVS     R2,#+12
   \   000000FC   5143               MULS     R1,R2,R1
   \   000000FE   ....               LDR      R2,??DataTable3_4
   \   00000100   5158               LDR      R1,[R2, R1]
   \   00000102   0818               ADDS     R0,R1,R0
   \   00000104   3E38               SUBS     R0,R0,#+62
   \   00000106   0088               LDRH     R0,[R0, #+0]
   \   00000108   3018               ADDS     R0,R6,R0
   \   0000010A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000010C   240E               LSRS     R4,R4,#+24
   \   0000010E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000110   2D0E               LSRS     R5,R5,#+24
   \   00000112   1021               MOVS     R1,#+16
   \   00000114   6943               MULS     R1,R5,R1
   \   00000116   ....               LDR      R2,??DataTable3_3
   \   00000118   5118               ADDS     R1,R2,R1
   \   0000011A   0919               ADDS     R1,R1,R4
   \   0000011C   C97B               LDRB     R1,[R1, #+15]
   \   0000011E   0222               MOVS     R2,#+2
   \   00000120   5143               MULS     R1,R2,R1
   \   00000122   ....               LDR      R2,??DataTable3_3
   \   00000124   527B               LDRB     R2,[R2, #+13]
   \   00000126   0C23               MOVS     R3,#+12
   \   00000128   5A43               MULS     R2,R3,R2
   \   0000012A   ....               LDR      R3,??DataTable3_4
   \   0000012C   9A58               LDR      R2,[R3, R2]
   \   0000012E   5118               ADDS     R1,R2,R1
   \   00000130   4039               SUBS     R1,R1,#+64
   \   00000132   0988               LDRH     R1,[R1, #+0]
   \   00000134   461A               SUBS     R6,R0,R1
    644            }
   \   00000136   641C               ADDS     R4,R4,#+1
   \   00000138   CDE7               B        ??LCD_WriteString_8
    645            /* if the width (in pixels) of the string that was written before on the same line is bigger than 
    646             * the width of the string that is going to be written,
    647             *  erase the line before write the string  */
    648            if(stringWidth >= mDisplayParams.linesWidthWritten[auxLine])
   \                     ??LCD_WriteString_9:
   \   0000013A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000013C   2D0E               LSRS     R5,R5,#+24
   \   0000013E   ....               LDR      R0,??DataTable3_3
   \   00000140   4019               ADDS     R0,R0,R5
   \   00000142   4079               LDRB     R0,[R0, #+5]
   \   00000144   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000146   360E               LSRS     R6,R6,#+24
   \   00000148   8642               CMP      R6,R0
   \   0000014A   16D3               BCC      ??LCD_WriteString_10
    649            {
    650              /* mark auxLine as a line to be written */
    651              for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
   \   0000014C   0020               MOVS     R0,#+0
   \   0000014E   0400               MOVS     R4,R0
   \                     ??LCD_WriteString_11:
   \   00000150   ....               LDR      R0,??DataTable3_3
   \   00000152   407B               LDRB     R0,[R0, #+13]
   \   00000154   0C21               MOVS     R1,#+12
   \   00000156   4843               MULS     R0,R1,R0
   \   00000158   ....               LDR      R1,??DataTable3_4
   \   0000015A   0818               ADDS     R0,R1,R0
   \   0000015C   007A               LDRB     R0,[R0, #+8]
   \   0000015E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000160   240E               LSRS     R4,R4,#+24
   \   00000162   8442               CMP      R4,R0
   \   00000164   27D2               BCS      ??LCD_WriteString_12
    652              {
    653                mDisplayParams.linesToWrite |= (1<<(auxLine+i));     
   \   00000166   ....               LDR      R0,??DataTable3_3
   \   00000168   0079               LDRB     R0,[R0, #+4]
   \   0000016A   0121               MOVS     R1,#+1
   \   0000016C   2A19               ADDS     R2,R5,R4
   \   0000016E   9140               LSLS     R1,R1,R2
   \   00000170   0143               ORRS     R1,R1,R0
   \   00000172   ....               LDR      R0,??DataTable3_3
   \   00000174   0171               STRB     R1,[R0, #+4]
    654              }  
   \   00000176   641C               ADDS     R4,R4,#+1
   \   00000178   EAE7               B        ??LCD_WriteString_11
    655            }
    656            else
    657            {
    658              /* add clear line operation in mQueue */
    659              /* add auxLine as a line to be cleared in mQueue */ 
    660              for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
   \                     ??LCD_WriteString_10:
   \   0000017A   0020               MOVS     R0,#+0
   \   0000017C   0400               MOVS     R4,R0
   \                     ??LCD_WriteString_13:
   \   0000017E   ....               LDR      R0,??DataTable3_3
   \   00000180   407B               LDRB     R0,[R0, #+13]
   \   00000182   0C21               MOVS     R1,#+12
   \   00000184   4843               MULS     R0,R1,R0
   \   00000186   ....               LDR      R1,??DataTable3_4
   \   00000188   0818               ADDS     R0,R1,R0
   \   0000018A   007A               LDRB     R0,[R0, #+8]
   \   0000018C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000018E   240E               LSRS     R4,R4,#+24
   \   00000190   8442               CMP      R4,R0
   \   00000192   10D2               BCS      ??LCD_WriteString_12
    661              {
    662                operationLine.opQueue   = gLCD_ClearLineOp_c;
   \   00000194   6846               MOV      R0,SP
   \   00000196   0221               MOVS     R1,#+2
   \   00000198   0170               STRB     R1,[R0, #+0]
    663                operationLine.lineQueue = auxLine + i;  
   \   0000019A   2819               ADDS     R0,R5,R4
   \   0000019C   6946               MOV      R1,SP
   \   0000019E   4870               STRB     R0,[R1, #+1]
    664                if(FALSE == AddToQueue(operationLine))
   \   000001A0   0098               LDR      R0,[SP, #+0]
   \   000001A2   ........           BL       AddToQueue
   \   000001A6   0028               CMP      R0,#+0
   \   000001A8   03D1               BNE      ??LCD_WriteString_14
    665                {
    666                  /* queue is full, report an error */
    667                  mErrorIndicator = gLCD_QueueFull_c;
   \   000001AA   ....               LDR      R0,??DataTable3
   \   000001AC   0121               MOVS     R1,#+1
   \   000001AE   0170               STRB     R1,[R0, #+0]
    668                  return;
   \   000001B0   14E0               B        ??LCD_WriteString_0
    669                }
    670              }  
   \                     ??LCD_WriteString_14:
   \   000001B2   641C               ADDS     R4,R4,#+1
   \   000001B4   E3E7               B        ??LCD_WriteString_13
    671            }
    672          
    673            /* add write string operation in mQueue */
    674            /* add auxLine as a line to be written in mQueue */ 
    675            operationLine.opQueue   = gLCD_WriteOp_c;
   \                     ??LCD_WriteString_12:
   \   000001B6   6846               MOV      R0,SP
   \   000001B8   0021               MOVS     R1,#+0
   \   000001BA   0170               STRB     R1,[R0, #+0]
    676            operationLine.lineQueue = auxLine;  
   \   000001BC   6846               MOV      R0,SP
   \   000001BE   4570               STRB     R5,[R0, #+1]
    677          
    678            if(TRUE == AddToQueue(operationLine))
   \   000001C0   0098               LDR      R0,[SP, #+0]
   \   000001C2   ........           BL       AddToQueue
   \   000001C6   0128               CMP      R0,#+1
   \   000001C8   05D1               BNE      ??LCD_WriteString_15
    679            {
    680              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);  
   \   000001CA   0121               MOVS     R1,#+1
   \   000001CC   ....               LDR      R0,??DataTable3_1
   \   000001CE   0078               LDRB     R0,[R0, #+0]
   \   000001D0   ........           BL       TS_SendEvent
    681            }  
    682            else
    683            {
    684              /* queue is full, report an error */
    685              mErrorIndicator = gLCD_QueueFull_c;
    686              return;        
    687            }
    688          }
   \   000001D4   02E0               B        ??LCD_WriteString_0
   \                     ??LCD_WriteString_15:
   \   000001D6   ....               LDR      R0,??DataTable3
   \   000001D8   0121               MOVS     R1,#+1
   \   000001DA   0170               STRB     R1,[R0, #+0]
   \                     ??LCD_WriteString_0:
   \   000001DC   07B0               ADD      SP,SP,#+28
   \   000001DE   F0BC               POP      {R4-R7}
   \   000001E0   08BC               POP      {R3}
   \   000001E2   1847               BX       R3               ;; return
    689          
    690          /******************************************************************************
    691          * This function writes a bitmap to a line of the display. In case an error occured 
    692          * during add to queue operation, the write string operation will not execute.
    693          *
    694          * Interface assumptions:
    695          *
    696          *
    697          * Return value:
    698          * None
    699          *
    700          *
    701          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    702          void LCD_WriteBitmap(                      
    703            uint8_t *pstr,	  /* IN: Pointer to symbol index list to display */
    704            uint8_t len,      /* IN: Length in bytes of the symbol index list */
    705            uint8_t line,     /* IN: Line in display */
    706            uint8_t *bitmap 	/* IN: Pointer to symbol table */   
    707          )
    708          {
   \                     LCD_WriteBitmap:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   86B0               SUB      SP,SP,#+24
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
   \   00000008   1F00               MOVS     R7,R3
    709            uint8_t symbolWidth = 0;
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   0171               STRB     R1,[R0, #+4]
    710            uint8_t ctr;
    711            opLine_t operationLine;
    712            const uint8_t error[] = "Wrong line";
   \   00000010   02A8               ADD      R0,SP,#+8
   \   00000012   ....               LDR      R1,??DataTable3_5
   \   00000014   0B22               MOVS     R2,#+11
   \   00000016   ........           BL       __aeabi_memcpy4
    713            
    714            /* in case of NULL pointers, just return */  
    715            if((pstr == NULL) || (bitmap == NULL))
   \   0000001A   0698               LDR      R0,[SP, #+24]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   01D0               BEQ      ??LCD_WriteBitmap_0
   \   00000020   002F               CMP      R7,#+0
   \   00000022   00D1               BNE      ??LCD_WriteBitmap_1
    716            {
    717              return;
   \                     ??LCD_WriteBitmap_0:
   \   00000024   6EE0               B        ??LCD_WriteBitmap_2
    718            }
    719            
    720            /* in case of wrong line number, print an error message */
    721            if(line >= gLCDMaxRamDataPages_c)
   \                     ??LCD_WriteBitmap_1:
   \   00000026   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000028   2D0E               LSRS     R5,R5,#+24
   \   0000002A   082D               CMP      R5,#+8
   \   0000002C   04D3               BCC      ??LCD_WriteBitmap_3
    722            {
    723              LCD_WriteString(1, (uint8_t *)&error);
   \   0000002E   02A9               ADD      R1,SP,#+8
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   ........           BL       LCD_WriteString
    724              return;
   \   00000036   65E0               B        ??LCD_WriteBitmap_2
    725            }
    726            
    727            /* validate the number of symbols to display */
    728            /* only 16 symbols may be displayed */
    729            if(len > gMAX_LCD_CHARS_c)
   \                     ??LCD_WriteBitmap_3:
   \   00000038   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   0000003A   360E               LSRS     R6,R6,#+24
   \   0000003C   112E               CMP      R6,#+17
   \   0000003E   01D3               BCC      ??LCD_WriteBitmap_4
    730            {
    731              len = gMAX_LCD_CHARS_c;
   \   00000040   1020               MOVS     R0,#+16
   \   00000042   0600               MOVS     R6,R0
    732            }
    733           
    734            /* clear the error indicator */
    735            mErrorIndicator = gLCD_NoError_c;
   \                     ??LCD_WriteBitmap_4:
   \   00000044   ....               LDR      R0,??DataTable3
   \   00000046   0021               MOVS     R1,#+0
   \   00000048   0170               STRB     R1,[R0, #+0]
    736            /* retain the start address of the bitmap */
    737            mReceivedBitmap = bitmap;
   \   0000004A   ....               LDR      R0,??DataTable3_6
   \   0000004C   0760               STR      R7,[R0, #+0]
    738          
    739            FLib_MemCpy(&mDisplayParams.currentBitmap[line], pstr, len);
   \   0000004E   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000050   360E               LSRS     R6,R6,#+24
   \   00000052   3200               MOVS     R2,R6
   \   00000054   1204               LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
   \   00000056   120C               LSRS     R2,R2,#+16
   \   00000058   0699               LDR      R1,[SP, #+24]
   \   0000005A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000005C   2D0E               LSRS     R5,R5,#+24
   \   0000005E   1020               MOVS     R0,#+16
   \   00000060   6843               MULS     R0,R5,R0
   \   00000062   ....               LDR      R3,??DataTable3_3
   \   00000064   1818               ADDS     R0,R3,R0
   \   00000066   8F30               ADDS     R0,R0,#+143
   \   00000068   ........           BL       FLib_MemCpy
    740            
    741            /* Clear the rest of the line */
    742            if(len < gMAX_LCD_CHARS_c)
   \   0000006C   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   0000006E   360E               LSRS     R6,R6,#+24
   \   00000070   102E               CMP      R6,#+16
   \   00000072   12D2               BCS      ??LCD_WriteBitmap_5
    743            {
    744              for(ctr = len; ctr < gMAX_LCD_CHARS_c;ctr++)
   \   00000074   3400               MOVS     R4,R6
   \                     ??LCD_WriteBitmap_6:
   \   00000076   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000078   240E               LSRS     R4,R4,#+24
   \   0000007A   102C               CMP      R4,#+16
   \   0000007C   0DD2               BCS      ??LCD_WriteBitmap_5
    745              {
    746                mDisplayParams.currentBitmap[line][ctr] = 0xFF;      
   \   0000007E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000080   240E               LSRS     R4,R4,#+24
   \   00000082   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000084   2D0E               LSRS     R5,R5,#+24
   \   00000086   1020               MOVS     R0,#+16
   \   00000088   6843               MULS     R0,R5,R0
   \   0000008A   ....               LDR      R1,??DataTable3_3
   \   0000008C   0818               ADDS     R0,R1,R0
   \   0000008E   0019               ADDS     R0,R0,R4
   \   00000090   8F30               ADDS     R0,R0,#+143
   \   00000092   FF21               MOVS     R1,#+255
   \   00000094   0170               STRB     R1,[R0, #+0]
    747              }
   \   00000096   641C               ADDS     R4,R4,#+1
   \   00000098   EDE7               B        ??LCD_WriteBitmap_6
    748            }
    749          
    750            /* compute the width (in pixels) of the symbols that will be written */
    751            symbolWidth = gMAX_LCD_CHARS_c * mSymbolWidth;
   \                     ??LCD_WriteBitmap_5:
   \   0000009A   6846               MOV      R0,SP
   \   0000009C   8021               MOVS     R1,#+128
   \   0000009E   0171               STRB     R1,[R0, #+4]
    752          
    753            /* if the width (in pixels) of the symbols that were written before on the same line is bigger than 
    754             * the width of the symbols that are going to be written,
    755             *  erase the line before writing the symbols  */
    756            if(symbolWidth >= mDisplayParams.linesWidthWritten[line])
   \   000000A0   6846               MOV      R0,SP
   \   000000A2   0079               LDRB     R0,[R0, #+4]
   \   000000A4   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000A6   2D0E               LSRS     R5,R5,#+24
   \   000000A8   ....               LDR      R1,??DataTable3_3
   \   000000AA   4919               ADDS     R1,R1,R5
   \   000000AC   4979               LDRB     R1,[R1, #+5]
   \   000000AE   8842               CMP      R0,R1
   \   000000B0   07D3               BCC      ??LCD_WriteBitmap_7
    757            {
    758              /* mark line as a line to be written */
    759              mDisplayParams.linesToWrite |= (1<<line);         
   \   000000B2   ....               LDR      R0,??DataTable3_3
   \   000000B4   0079               LDRB     R0,[R0, #+4]
   \   000000B6   0121               MOVS     R1,#+1
   \   000000B8   A940               LSLS     R1,R1,R5
   \   000000BA   0143               ORRS     R1,R1,R0
   \   000000BC   ....               LDR      R0,??DataTable3_3
   \   000000BE   0171               STRB     R1,[R0, #+4]
   \   000000C0   0DE0               B        ??LCD_WriteBitmap_8
    760            }
    761            else
    762            {
    763              /* add clear line operation in mQueue */
    764              /* add line as a line to be cleared in mQueue */ 
    765              operationLine.opQueue   = gLCD_ClearLineOp_c;
   \                     ??LCD_WriteBitmap_7:
   \   000000C2   6846               MOV      R0,SP
   \   000000C4   0221               MOVS     R1,#+2
   \   000000C6   0170               STRB     R1,[R0, #+0]
    766              operationLine.lineQueue = line;  
   \   000000C8   6846               MOV      R0,SP
   \   000000CA   4570               STRB     R5,[R0, #+1]
    767              if(FALSE == AddToQueue(operationLine))
   \   000000CC   0098               LDR      R0,[SP, #+0]
   \   000000CE   ........           BL       AddToQueue
   \   000000D2   0028               CMP      R0,#+0
   \   000000D4   03D1               BNE      ??LCD_WriteBitmap_8
    768              {
    769                /* queue is full, report an error */
    770                mErrorIndicator = gLCD_QueueFull_c;
   \   000000D6   ....               LDR      R0,??DataTable3
   \   000000D8   0121               MOVS     R1,#+1
   \   000000DA   0170               STRB     R1,[R0, #+0]
    771                return;
   \   000000DC   12E0               B        ??LCD_WriteBitmap_2
    772              }
    773            }
    774          
    775            /* add write bitmap operation in mQueue */
    776            /* add line as a line to be written in mQueue */ 
    777            operationLine.opQueue   = gLCD_WriteBitmapOp_c;
   \                     ??LCD_WriteBitmap_8:
   \   000000DE   6846               MOV      R0,SP
   \   000000E0   0321               MOVS     R1,#+3
   \   000000E2   0170               STRB     R1,[R0, #+0]
    778            operationLine.lineQueue = line;  
   \   000000E4   6846               MOV      R0,SP
   \   000000E6   4570               STRB     R5,[R0, #+1]
    779          
    780            if(TRUE == AddToQueue(operationLine))
   \   000000E8   0098               LDR      R0,[SP, #+0]
   \   000000EA   ........           BL       AddToQueue
   \   000000EE   0128               CMP      R0,#+1
   \   000000F0   05D1               BNE      ??LCD_WriteBitmap_9
    781            {
    782              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);  
   \   000000F2   0121               MOVS     R1,#+1
   \   000000F4   ....               LDR      R0,??DataTable3_1
   \   000000F6   0078               LDRB     R0,[R0, #+0]
   \   000000F8   ........           BL       TS_SendEvent
    783            }  
    784            else
    785            {
    786              /* queue is full, report an error */
    787              mErrorIndicator = gLCD_QueueFull_c;
    788              return;        
    789            }
    790          }
   \   000000FC   02E0               B        ??LCD_WriteBitmap_2
   \                     ??LCD_WriteBitmap_9:
   \   000000FE   ....               LDR      R0,??DataTable3
   \   00000100   0121               MOVS     R1,#+1
   \   00000102   0170               STRB     R1,[R0, #+0]
   \                     ??LCD_WriteBitmap_2:
   \   00000104   07B0               ADD      SP,SP,#+28
   \   00000106   F0BC               POP      {R4-R7}
   \   00000108   08BC               POP      {R3}
   \   0000010A   1847               BX       R3               ;; return
    791          
    792          /******************************************************************************
    793          * This function write a string and a value in decimal or hexdecimal
    794          * to the display
    795          *
    796          * Interface assumptions:
    797          * The pstr must be zero-terminated.
    798          *
    799          * Return value:
    800          * None
    801          *
    802          *
    803          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    804          void LCD_WriteStringValue
    805            (
    806            uint8_t *pstr,     /* IN: Pointer to text string */
    807            uint16_t value,    /* IN: Value */
    808            uint8_t line, 	   /* IN: Line in display */
    809            LCD_t numberFormat /* IN: Value to show in HEX or DEC */
    810            )
    811          {
   \                     LCD_WriteStringValue:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   \   00000002   8CB0               SUB      SP,SP,#+48
   \   00000004   0E00               MOVS     R6,R1
    812          
    813            int16_t divDec=10000, divHex=16;
   \   00000006   ....               LDR      R0,??DataTable4  ;; 0x2710
   \   00000008   0700               MOVS     R7,R0
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   1021               MOVS     R1,#+16
   \   0000000E   4180               STRH     R1,[R0, #+2]
    814            uint8_t loop=5, i=0,counter=0, aH[6], aHex[6];
   \   00000010   6846               MOV      R0,SP
   \   00000012   0521               MOVS     R1,#+5
   \   00000014   0170               STRB     R1,[R0, #+0]
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   0500               MOVS     R5,R0
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   0400               MOVS     R4,R0
    815            uint8_t aDec[6], aString[17];
    816            
    817            /* clear the error indicator */
    818            mErrorIndicator = gLCD_NoError_c;
   \   0000001E   ....               LDR      R0,??DataTable4_1
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   0170               STRB     R1,[R0, #+0]
    819          
    820           if(numberFormat == gLCD_DecFormat_c) {
   \   00000024   0EA8               ADD      R0,SP,#+56
   \   00000026   0078               LDRB     R0,[R0, #+0]
   \   00000028   0128               CMP      R0,#+1
   \   0000002A   00D0               BEQ      .+4
   \   0000002C   9FE0               B        ??LCD_WriteStringValue_0
    821              if(value < 100) {
   \   0000002E   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000030   360C               LSRS     R6,R6,#+16
   \   00000032   642E               CMP      R6,#+100
   \   00000034   05D2               BCS      ??LCD_WriteStringValue_1
    822                loop = 2;
   \   00000036   6846               MOV      R0,SP
   \   00000038   0221               MOVS     R1,#+2
   \   0000003A   0170               STRB     R1,[R0, #+0]
    823                divDec = 10;
   \   0000003C   0A20               MOVS     R0,#+10
   \   0000003E   0700               MOVS     R7,R0
   \   00000040   20E0               B        ??LCD_WriteStringValue_2
    824              }
    825              else if(value >= 100 && value <1000) {
   \                     ??LCD_WriteStringValue_1:
   \   00000042   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000044   360C               LSRS     R6,R6,#+16
   \   00000046   642E               CMP      R6,#+100
   \   00000048   0BD3               BCC      ??LCD_WriteStringValue_3
   \   0000004A   FA20               MOVS     R0,#+250
   \   0000004C   8000               LSLS     R0,R0,#+2        ;; #+1000
   \   0000004E   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000050   360C               LSRS     R6,R6,#+16
   \   00000052   8642               CMP      R6,R0
   \   00000054   05D2               BCS      ??LCD_WriteStringValue_3
    826                loop = 3;
   \   00000056   6846               MOV      R0,SP
   \   00000058   0321               MOVS     R1,#+3
   \   0000005A   0170               STRB     R1,[R0, #+0]
    827                divDec = 100;
   \   0000005C   6420               MOVS     R0,#+100
   \   0000005E   0700               MOVS     R7,R0
   \   00000060   10E0               B        ??LCD_WriteStringValue_2
    828              }
    829              else if(value >= 1000 && value <9999) {
   \                     ??LCD_WriteStringValue_3:
   \   00000062   FA20               MOVS     R0,#+250
   \   00000064   8000               LSLS     R0,R0,#+2        ;; #+1000
   \   00000066   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000068   360C               LSRS     R6,R6,#+16
   \   0000006A   8642               CMP      R6,R0
   \   0000006C   0AD3               BCC      ??LCD_WriteStringValue_2
   \   0000006E   ....               LDR      R0,??DataTable5  ;; 0x270f
   \   00000070   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000072   360C               LSRS     R6,R6,#+16
   \   00000074   8642               CMP      R6,R0
   \   00000076   05D2               BCS      ??LCD_WriteStringValue_2
    830                loop = 4;
   \   00000078   6846               MOV      R0,SP
   \   0000007A   0421               MOVS     R1,#+4
   \   0000007C   0170               STRB     R1,[R0, #+0]
    831                divDec = 1000;
   \   0000007E   FA20               MOVS     R0,#+250
   \   00000080   8000               LSLS     R0,R0,#+2        ;; #+1000
   \   00000082   0700               MOVS     R7,R0
    832              }
    833          
    834              for(i=0; i<loop; i++) {
   \                     ??LCD_WriteStringValue_2:
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   0500               MOVS     R5,R0
   \                     ??LCD_WriteStringValue_4:
   \   00000088   6846               MOV      R0,SP
   \   0000008A   0078               LDRB     R0,[R0, #+0]
   \   0000008C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000008E   2D0E               LSRS     R5,R5,#+24
   \   00000090   8542               CMP      R5,R0
   \   00000092   30D2               BCS      ??LCD_WriteStringValue_5
    835                if((value/divDec)!= 0) {
   \   00000094   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000096   360C               LSRS     R6,R6,#+16
   \   00000098   3000               MOVS     R0,R6
   \   0000009A   3F04               LSLS     R7,R7,#+16       ;; SignExtS R7,R7,#+16,#+16
   \   0000009C   3F14               ASRS     R7,R7,#+16
   \   0000009E   3900               MOVS     R1,R7
   \   000000A0   ........           BL       __aeabi_idiv
   \   000000A4   0028               CMP      R0,#+0
   \   000000A6   17D0               BEQ      ??LCD_WriteStringValue_6
    836                  aDec[counter++] = (value/divDec) + 0x30;
   \   000000A8   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   000000AA   360C               LSRS     R6,R6,#+16
   \   000000AC   3000               MOVS     R0,R6
   \   000000AE   3F04               LSLS     R7,R7,#+16       ;; SignExtS R7,R7,#+16,#+16
   \   000000B0   3F14               ASRS     R7,R7,#+16
   \   000000B2   3900               MOVS     R1,R7
   \   000000B4   ........           BL       __aeabi_idiv
   \   000000B8   3030               ADDS     R0,R0,#+48
   \   000000BA   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000BC   240E               LSRS     R4,R4,#+24
   \   000000BE   01A9               ADD      R1,SP,#+4
   \   000000C0   0855               STRB     R0,[R1, R4]
   \   000000C2   641C               ADDS     R4,R4,#+1
    837                  value = value % divDec;
   \   000000C4   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   000000C6   360C               LSRS     R6,R6,#+16
   \   000000C8   3000               MOVS     R0,R6
   \   000000CA   3F04               LSLS     R7,R7,#+16       ;; SignExtS R7,R7,#+16,#+16
   \   000000CC   3F14               ASRS     R7,R7,#+16
   \   000000CE   3900               MOVS     R1,R7
   \   000000D0   ........           BL       __aeabi_idivmod
   \   000000D4   0E00               MOVS     R6,R1
   \   000000D6   05E0               B        ??LCD_WriteStringValue_7
    838                }
    839                else {
    840                  aDec[counter++] = 0x30;
   \                     ??LCD_WriteStringValue_6:
   \   000000D8   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000DA   240E               LSRS     R4,R4,#+24
   \   000000DC   01A8               ADD      R0,SP,#+4
   \   000000DE   3021               MOVS     R1,#+48
   \   000000E0   0155               STRB     R1,[R0, R4]
   \   000000E2   641C               ADDS     R4,R4,#+1
    841                }
    842                divDec = divDec/10;
   \                     ??LCD_WriteStringValue_7:
   \   000000E4   3F04               LSLS     R7,R7,#+16       ;; SignExtS R7,R7,#+16,#+16
   \   000000E6   3F14               ASRS     R7,R7,#+16
   \   000000E8   3800               MOVS     R0,R7
   \   000000EA   0A21               MOVS     R1,#+10
   \   000000EC   ........           BL       __aeabi_idiv
   \   000000F0   0700               MOVS     R7,R0
    843              }
   \   000000F2   6D1C               ADDS     R5,R5,#+1
   \   000000F4   C8E7               B        ??LCD_WriteStringValue_4
    844              aDec[counter]='\0';
   \                     ??LCD_WriteStringValue_5:
   \   000000F6   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000F8   240E               LSRS     R4,R4,#+24
   \   000000FA   01A8               ADD      R0,SP,#+4
   \   000000FC   0021               MOVS     R1,#+0
   \   000000FE   0155               STRB     R1,[R0, R4]
    845              counter=0;
   \   00000100   0020               MOVS     R0,#+0
   \   00000102   0400               MOVS     R4,R0
    846              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_8:
   \   00000104   0C98               LDR      R0,[SP, #+48]
   \   00000106   0078               LDRB     R0,[R0, #+0]
   \   00000108   0028               CMP      R0,#+0
   \   0000010A   0ED0               BEQ      ??LCD_WriteStringValue_9
   \   0000010C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000010E   240E               LSRS     R4,R4,#+24
   \   00000110   102C               CMP      R4,#+16
   \   00000112   0AD2               BCS      ??LCD_WriteStringValue_9
    847                aString[counter++]=*pstr;
   \   00000114   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000116   240E               LSRS     R4,R4,#+24
   \   00000118   07A8               ADD      R0,SP,#+28
   \   0000011A   0C99               LDR      R1,[SP, #+48]
   \   0000011C   0978               LDRB     R1,[R1, #+0]
   \   0000011E   0155               STRB     R1,[R0, R4]
   \   00000120   641C               ADDS     R4,R4,#+1
    848                pstr++;
   \   00000122   0C98               LDR      R0,[SP, #+48]
   \   00000124   401C               ADDS     R0,R0,#+1
   \   00000126   0C90               STR      R0,[SP, #+48]
   \   00000128   ECE7               B        ??LCD_WriteStringValue_8
    849              }
    850              i=0;
   \                     ??LCD_WriteStringValue_9:
   \   0000012A   0020               MOVS     R0,#+0
   \   0000012C   0500               MOVS     R5,R0
    851              while (aDec[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_10:
   \   0000012E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000130   2D0E               LSRS     R5,R5,#+24
   \   00000132   01A8               ADD      R0,SP,#+4
   \   00000134   405D               LDRB     R0,[R0, R5]
   \   00000136   0028               CMP      R0,#+0
   \   00000138   0ED0               BEQ      ??LCD_WriteStringValue_11
   \   0000013A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000013C   240E               LSRS     R4,R4,#+24
   \   0000013E   102C               CMP      R4,#+16
   \   00000140   0AD2               BCS      ??LCD_WriteStringValue_11
    852                aString[counter++]=aDec[i++];
   \   00000142   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000144   240E               LSRS     R4,R4,#+24
   \   00000146   07A8               ADD      R0,SP,#+28
   \   00000148   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000014A   2D0E               LSRS     R5,R5,#+24
   \   0000014C   01A9               ADD      R1,SP,#+4
   \   0000014E   495D               LDRB     R1,[R1, R5]
   \   00000150   0155               STRB     R1,[R0, R4]
   \   00000152   6D1C               ADDS     R5,R5,#+1
   \   00000154   641C               ADDS     R4,R4,#+1
   \   00000156   EAE7               B        ??LCD_WriteStringValue_10
    853              }
    854              aString[counter]='\0';
   \                     ??LCD_WriteStringValue_11:
   \   00000158   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000015A   240E               LSRS     R4,R4,#+24
   \   0000015C   07A8               ADD      R0,SP,#+28
   \   0000015E   0021               MOVS     R1,#+0
   \   00000160   0155               STRB     R1,[R0, R4]
    855              LCD_WriteString( line, aString );
   \   00000162   07A9               ADD      R1,SP,#+28
   \   00000164   0DA8               ADD      R0,SP,#+52
   \   00000166   0078               LDRB     R0,[R0, #+0]
   \   00000168   ........           BL       LCD_WriteString
   \   0000016C   80E0               B        ??LCD_WriteStringValue_12
    856            }
    857            else if(numberFormat == gLCD_HexFormat_c) {
   \                     ??LCD_WriteStringValue_0:
   \   0000016E   0EA8               ADD      R0,SP,#+56
   \   00000170   0078               LDRB     R0,[R0, #+0]
   \   00000172   0028               CMP      R0,#+0
   \   00000174   77D1               BNE      ??LCD_WriteStringValue_13
    858              do{
    859                aH[i]=gaHexValue[value % divHex];
   \                     ??LCD_WriteStringValue_14:
   \   00000176   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000178   360C               LSRS     R6,R6,#+16
   \   0000017A   3000               MOVS     R0,R6
   \   0000017C   6A46               MOV      R2,SP
   \   0000017E   0221               MOVS     R1,#+2
   \   00000180   515E               LDRSH    R1,[R2, R1]
   \   00000182   ........           BL       __aeabi_idivmod
   \   00000186   ....               LDR      R0,??DataTable9
   \   00000188   405C               LDRB     R0,[R0, R1]
   \   0000018A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000018C   2D0E               LSRS     R5,R5,#+24
   \   0000018E   05A9               ADD      R1,SP,#+20
   \   00000190   4855               STRB     R0,[R1, R5]
    860                value=value / divHex;
   \   00000192   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   00000194   360C               LSRS     R6,R6,#+16
   \   00000196   3000               MOVS     R0,R6
   \   00000198   6A46               MOV      R2,SP
   \   0000019A   0221               MOVS     R1,#+2
   \   0000019C   515E               LDRSH    R1,[R2, R1]
   \   0000019E   ........           BL       __aeabi_idiv
   \   000001A2   0600               MOVS     R6,R0
    861                i++;
   \   000001A4   6D1C               ADDS     R5,R5,#+1
    862              }
    863              while(value > 15);
   \   000001A6   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   000001A8   360C               LSRS     R6,R6,#+16
   \   000001AA   102E               CMP      R6,#+16
   \   000001AC   E3D2               BCS      ??LCD_WriteStringValue_14
    864              aH[i]=gaHexValue[value];
   \   000001AE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001B0   2D0E               LSRS     R5,R5,#+24
   \   000001B2   05A8               ADD      R0,SP,#+20
   \   000001B4   3604               LSLS     R6,R6,#+16       ;; ZeroExtS R6,R6,#+16,#+16
   \   000001B6   360C               LSRS     R6,R6,#+16
   \   000001B8   ....               LDR      R1,??DataTable9
   \   000001BA   895D               LDRB     R1,[R1, R6]
   \   000001BC   4155               STRB     R1,[R0, R5]
    865              counter=0;
   \   000001BE   0020               MOVS     R0,#+0
   \   000001C0   0400               MOVS     R4,R0
    866              while(i > 0){
   \                     ??LCD_WriteStringValue_15:
   \   000001C2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001C4   2D0E               LSRS     R5,R5,#+24
   \   000001C6   012D               CMP      R5,#+1
   \   000001C8   0AD3               BCC      ??LCD_WriteStringValue_16
    867                aHex[counter++]=aH[i--];
   \   000001CA   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000001CC   240E               LSRS     R4,R4,#+24
   \   000001CE   03A8               ADD      R0,SP,#+12
   \   000001D0   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001D2   2D0E               LSRS     R5,R5,#+24
   \   000001D4   05A9               ADD      R1,SP,#+20
   \   000001D6   495D               LDRB     R1,[R1, R5]
   \   000001D8   0155               STRB     R1,[R0, R4]
   \   000001DA   6D1E               SUBS     R5,R5,#+1
   \   000001DC   641C               ADDS     R4,R4,#+1
   \   000001DE   F0E7               B        ??LCD_WriteStringValue_15
    868              }
    869          
    870              aHex[counter++]=aH[0];
   \                     ??LCD_WriteStringValue_16:
   \   000001E0   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000001E2   240E               LSRS     R4,R4,#+24
   \   000001E4   03A8               ADD      R0,SP,#+12
   \   000001E6   6946               MOV      R1,SP
   \   000001E8   097D               LDRB     R1,[R1, #+20]
   \   000001EA   0155               STRB     R1,[R0, R4]
   \   000001EC   641C               ADDS     R4,R4,#+1
    871              aHex[counter]='\0';
   \   000001EE   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000001F0   240E               LSRS     R4,R4,#+24
   \   000001F2   03A8               ADD      R0,SP,#+12
   \   000001F4   0021               MOVS     R1,#+0
   \   000001F6   0155               STRB     R1,[R0, R4]
    872          
    873              counter=0;
   \   000001F8   0020               MOVS     R0,#+0
   \   000001FA   0400               MOVS     R4,R0
    874              while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_17:
   \   000001FC   0C98               LDR      R0,[SP, #+48]
   \   000001FE   0078               LDRB     R0,[R0, #+0]
   \   00000200   0028               CMP      R0,#+0
   \   00000202   0ED0               BEQ      ??LCD_WriteStringValue_18
   \   00000204   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000206   240E               LSRS     R4,R4,#+24
   \   00000208   102C               CMP      R4,#+16
   \   0000020A   0AD2               BCS      ??LCD_WriteStringValue_18
    875                aString[counter++]=*pstr;
   \   0000020C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000020E   240E               LSRS     R4,R4,#+24
   \   00000210   07A8               ADD      R0,SP,#+28
   \   00000212   0C99               LDR      R1,[SP, #+48]
   \   00000214   0978               LDRB     R1,[R1, #+0]
   \   00000216   0155               STRB     R1,[R0, R4]
   \   00000218   641C               ADDS     R4,R4,#+1
    876                pstr++;
   \   0000021A   0C98               LDR      R0,[SP, #+48]
   \   0000021C   401C               ADDS     R0,R0,#+1
   \   0000021E   0C90               STR      R0,[SP, #+48]
   \   00000220   ECE7               B        ??LCD_WriteStringValue_17
    877              }
    878              i=0;
   \                     ??LCD_WriteStringValue_18:
   \   00000222   0020               MOVS     R0,#+0
   \   00000224   0500               MOVS     R5,R0
    879              while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c ) {
   \                     ??LCD_WriteStringValue_19:
   \   00000226   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000228   2D0E               LSRS     R5,R5,#+24
   \   0000022A   03A8               ADD      R0,SP,#+12
   \   0000022C   405D               LDRB     R0,[R0, R5]
   \   0000022E   0028               CMP      R0,#+0
   \   00000230   0ED0               BEQ      ??LCD_WriteStringValue_20
   \   00000232   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000234   240E               LSRS     R4,R4,#+24
   \   00000236   102C               CMP      R4,#+16
   \   00000238   0AD2               BCS      ??LCD_WriteStringValue_20
    880                aString[counter++]=aHex[i++];
   \   0000023A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000023C   240E               LSRS     R4,R4,#+24
   \   0000023E   07A8               ADD      R0,SP,#+28
   \   00000240   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000242   2D0E               LSRS     R5,R5,#+24
   \   00000244   03A9               ADD      R1,SP,#+12
   \   00000246   495D               LDRB     R1,[R1, R5]
   \   00000248   0155               STRB     R1,[R0, R4]
   \   0000024A   6D1C               ADDS     R5,R5,#+1
   \   0000024C   641C               ADDS     R4,R4,#+1
   \   0000024E   EAE7               B        ??LCD_WriteStringValue_19
    881              }
    882              aString[counter]='\0';
   \                     ??LCD_WriteStringValue_20:
   \   00000250   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000252   240E               LSRS     R4,R4,#+24
   \   00000254   07A8               ADD      R0,SP,#+28
   \   00000256   0021               MOVS     R1,#+0
   \   00000258   0155               STRB     R1,[R0, R4]
    883              LCD_WriteString( line, aString );
   \   0000025A   07A9               ADD      R1,SP,#+28
   \   0000025C   0DA8               ADD      R0,SP,#+52
   \   0000025E   0078               LDRB     R0,[R0, #+0]
   \   00000260   ........           BL       LCD_WriteString
   \   00000264   04E0               B        ??LCD_WriteStringValue_12
    884            }
    885            else {
    886              LCD_WriteString( line, "Format unknow" );
   \                     ??LCD_WriteStringValue_13:
   \   00000266   ....               LDR      R1,??DataTable11
   \   00000268   0DA8               ADD      R0,SP,#+52
   \   0000026A   0078               LDRB     R0,[R0, #+0]
   \   0000026C   ........           BL       LCD_WriteString
    887            }
    888          }
   \                     ??LCD_WriteStringValue_12:
   \   00000270   0FB0               ADD      SP,SP,#+60
   \   00000272   F0BC               POP      {R4-R7}
   \   00000274   08BC               POP      {R3}
   \   00000276   1847               BX       R3               ;; return
    889          
    890          /******************************************************************************
    891          * This functions allows to write raw bytes to the LCD, the maximum number of bytes
    892          *	capable per line is 8, this functions transfors every hex simbol in a byte to a char.
    893          *
    894          * Interface assumptions:
    895          *	IN: The pointer to the label to print with the bytes.
    896          *	IN: The bytes to print.
    897          *	IN: The line in the LCD where the bytes with the label.
    898          *	IN: The number of bytes to print in the LCD.
    899          *
    900          * Return value:
    901          * None
    902          *
    903          *
    904          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    905          void LCD_WriteBytes
    906          (
    907          	uint8_t   *pstr,   /* IN: The pointer to the label to print with the bytes. */
    908          	uint8_t   *value,  /* IN: The bytes to print in hex. */
    909          	uint8_t   line,    /* IN: The line in the LCD where the bytes with the label. */
    910          	uint8_t   length   /* IN: The number of bytes to print in the LCD. */
    911          )
    912          {
   \                     LCD_WriteBytes:
   \   00000000   FFB5               PUSH     {R0-R7,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
    913          
    914          	uint8_t i=0,counter=0, cIndex,auxIndex;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0700               MOVS     R7,R0
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0400               MOVS     R4,R0
    915          	uint8_t aString[17];
    916          
    917          	uint8_t  hexIndex;
    918          	uint8_t aHex[gMAX_LCD_CHARS_c]={'S','i','z','e',' ','N','o','t',' ','V','a','l','i','d','*','*'};
   \   0000000C   01A8               ADD      R0,SP,#+4
   \   0000000E   ....               LDR      R1,??DataTable11_1
   \   00000010   1022               MOVS     R2,#+16
   \   00000012   ........           BL       __aeabi_memcpy4
    919          
    920            /* clear the error indicator */
    921            mErrorIndicator = gLCD_NoError_c;
   \   00000016   ....               LDR      R0,??DataTable11_2
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   0170               STRB     R1,[R0, #+0]
    922            
    923          	counter=0;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   0400               MOVS     R4,R0
    924          	while (*pstr != '\0' && counter <gMAX_LCD_CHARS_c )
   \                     ??LCD_WriteBytes_0:
   \   00000020   0B98               LDR      R0,[SP, #+44]
   \   00000022   0078               LDRB     R0,[R0, #+0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0ED0               BEQ      ??LCD_WriteBytes_1
   \   00000028   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000002A   240E               LSRS     R4,R4,#+24
   \   0000002C   102C               CMP      R4,#+16
   \   0000002E   0AD2               BCS      ??LCD_WriteBytes_1
    925          	{
    926          		aString[counter++]=*pstr;
   \   00000030   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000032   240E               LSRS     R4,R4,#+24
   \   00000034   05A8               ADD      R0,SP,#+20
   \   00000036   0B99               LDR      R1,[SP, #+44]
   \   00000038   0978               LDRB     R1,[R1, #+0]
   \   0000003A   0155               STRB     R1,[R0, R4]
   \   0000003C   641C               ADDS     R4,R4,#+1
    927          		pstr++;
   \   0000003E   0B98               LDR      R0,[SP, #+44]
   \   00000040   401C               ADDS     R0,R0,#+1
   \   00000042   0B90               STR      R0,[SP, #+44]
   \   00000044   ECE7               B        ??LCD_WriteBytes_0
    928          	}
    929          	if ((((length*2)+counter) <= gMAX_LCD_CHARS_c) && ((length*2) > 0))
   \                     ??LCD_WriteBytes_1:
   \   00000046   0EA8               ADD      R0,SP,#+56
   \   00000048   0078               LDRB     R0,[R0, #+0]
   \   0000004A   0221               MOVS     R1,#+2
   \   0000004C   4843               MULS     R0,R1,R0
   \   0000004E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000050   240E               LSRS     R4,R4,#+24
   \   00000052   0019               ADDS     R0,R0,R4
   \   00000054   1128               CMP      R0,#+17
   \   00000056   41DA               BGE      ??LCD_WriteBytes_2
   \   00000058   0EA8               ADD      R0,SP,#+56
   \   0000005A   0078               LDRB     R0,[R0, #+0]
   \   0000005C   0221               MOVS     R1,#+2
   \   0000005E   4843               MULS     R0,R1,R0
   \   00000060   0128               CMP      R0,#+1
   \   00000062   3BDB               BLT      ??LCD_WriteBytes_2
    930          	{
    931          		for (cIndex =0,auxIndex = 0; cIndex < length; cIndex++,auxIndex+=2)
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   0600               MOVS     R6,R0
   \   00000068   6846               MOV      R0,SP
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   0170               STRB     R1,[R0, #+0]
   \                     ??LCD_WriteBytes_3:
   \   0000006E   0EA8               ADD      R0,SP,#+56
   \   00000070   0078               LDRB     R0,[R0, #+0]
   \   00000072   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000074   360E               LSRS     R6,R6,#+24
   \   00000076   8642               CMP      R6,R0
   \   00000078   28D2               BCS      ??LCD_WriteBytes_4
    932          		{
    933          			hexIndex = value[cIndex]&0xf0;
   \   0000007A   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   0000007C   360E               LSRS     R6,R6,#+24
   \   0000007E   0C98               LDR      R0,[SP, #+48]
   \   00000080   805D               LDRB     R0,[R0, R6]
   \   00000082   F021               MOVS     R1,#+240
   \   00000084   0140               ANDS     R1,R1,R0
   \   00000086   0D00               MOVS     R5,R1
    934          			hexIndex = hexIndex>>4;
   \   00000088   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000008A   2D0E               LSRS     R5,R5,#+24
   \   0000008C   2D09               LSRS     R5,R5,#+4
    935          			aHex[auxIndex] = gaHexValue[hexIndex];
   \   0000008E   6846               MOV      R0,SP
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   01A9               ADD      R1,SP,#+4
   \   00000094   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000096   2D0E               LSRS     R5,R5,#+24
   \   00000098   ....               LDR      R2,??DataTable9
   \   0000009A   525D               LDRB     R2,[R2, R5]
   \   0000009C   0A54               STRB     R2,[R1, R0]
    936          			hexIndex = value[cIndex] & 0x0f;
   \   0000009E   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   000000A0   360E               LSRS     R6,R6,#+24
   \   000000A2   0C98               LDR      R0,[SP, #+48]
   \   000000A4   805D               LDRB     R0,[R0, R6]
   \   000000A6   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   000000A8   000F               LSRS     R0,R0,#+28
   \   000000AA   0500               MOVS     R5,R0
    937          			aHex[auxIndex + 1] = gaHexValue[hexIndex];
   \   000000AC   6846               MOV      R0,SP
   \   000000AE   0078               LDRB     R0,[R0, #+0]
   \   000000B0   01A9               ADD      R1,SP,#+4
   \   000000B2   0818               ADDS     R0,R1,R0
   \   000000B4   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000B6   2D0E               LSRS     R5,R5,#+24
   \   000000B8   ....               LDR      R1,??DataTable9
   \   000000BA   495D               LDRB     R1,[R1, R5]
   \   000000BC   4170               STRB     R1,[R0, #+1]
    938          		}
   \   000000BE   761C               ADDS     R6,R6,#+1
   \   000000C0   6846               MOV      R0,SP
   \   000000C2   6946               MOV      R1,SP
   \   000000C4   0978               LDRB     R1,[R1, #+0]
   \   000000C6   891C               ADDS     R1,R1,#+2
   \   000000C8   0170               STRB     R1,[R0, #+0]
   \   000000CA   D0E7               B        ??LCD_WriteBytes_3
    939          		aHex[(length * 2)]='\0';
   \                     ??LCD_WriteBytes_4:
   \   000000CC   0EA8               ADD      R0,SP,#+56
   \   000000CE   0078               LDRB     R0,[R0, #+0]
   \   000000D0   0221               MOVS     R1,#+2
   \   000000D2   4843               MULS     R0,R1,R0
   \   000000D4   01A9               ADD      R1,SP,#+4
   \   000000D6   0022               MOVS     R2,#+0
   \   000000D8   0A54               STRB     R2,[R1, R0]
   \   000000DA   01E0               B        ??LCD_WriteBytes_5
    940          	}
    941          	else
    942          		counter = 0;
   \                     ??LCD_WriteBytes_2:
   \   000000DC   0020               MOVS     R0,#+0
   \   000000DE   0400               MOVS     R4,R0
    943          
    944          	i=0;
   \                     ??LCD_WriteBytes_5:
   \   000000E0   0020               MOVS     R0,#+0
   \   000000E2   0700               MOVS     R7,R0
    945          	while (aHex[i] != '\0' && counter <gMAX_LCD_CHARS_c )
   \                     ??LCD_WriteBytes_6:
   \   000000E4   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   000000E6   3F0E               LSRS     R7,R7,#+24
   \   000000E8   01A8               ADD      R0,SP,#+4
   \   000000EA   C05D               LDRB     R0,[R0, R7]
   \   000000EC   0028               CMP      R0,#+0
   \   000000EE   0ED0               BEQ      ??LCD_WriteBytes_7
   \   000000F0   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000F2   240E               LSRS     R4,R4,#+24
   \   000000F4   102C               CMP      R4,#+16
   \   000000F6   0AD2               BCS      ??LCD_WriteBytes_7
    946          		aString[counter++]=aHex[i++];
   \   000000F8   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000FA   240E               LSRS     R4,R4,#+24
   \   000000FC   05A8               ADD      R0,SP,#+20
   \   000000FE   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   00000100   3F0E               LSRS     R7,R7,#+24
   \   00000102   01A9               ADD      R1,SP,#+4
   \   00000104   C95D               LDRB     R1,[R1, R7]
   \   00000106   0155               STRB     R1,[R0, R4]
   \   00000108   7F1C               ADDS     R7,R7,#+1
   \   0000010A   641C               ADDS     R4,R4,#+1
   \   0000010C   EAE7               B        ??LCD_WriteBytes_6
    947          
    948          	aString[counter]='\0';
   \                     ??LCD_WriteBytes_7:
   \   0000010E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000110   240E               LSRS     R4,R4,#+24
   \   00000112   05A8               ADD      R0,SP,#+20
   \   00000114   0021               MOVS     R1,#+0
   \   00000116   0155               STRB     R1,[R0, R4]
    949          	LCD_WriteString( line, aString );
   \   00000118   05A9               ADD      R1,SP,#+20
   \   0000011A   0DA8               ADD      R0,SP,#+52
   \   0000011C   0078               LDRB     R0,[R0, #+0]
   \   0000011E   ........           BL       LCD_WriteString
    950          }
   \   00000122   0FB0               ADD      SP,SP,#+60
   \   00000124   F0BC               POP      {R4-R7}
   \   00000126   08BC               POP      {R3}
   \   00000128   1847               BX       R3               ;; return
    951          
    952          /******************************************************************************
    953          * This function sends a command to the display controller
    954          *
    955          * Interface assumptions:
    956          *
    957          *
    958          * Return value:
    959          * None
    960          *
    961          *
    962          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    963          void LCD_WriteCommand(uint8_t command)
    964          {
   \                     LCD_WriteCommand:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    965            /* clear the error indicator */
    966            mErrorIndicator = gLCD_NoError_c;
   \   00000004   ....               LDR      R0,??DataTable11_2
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0170               STRB     R1,[R0, #+0]
    967            
    968            Gpio_SetPinData(LCD_A0, LCD_A0_COMMAND);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   1520               MOVS     R0,#+21
   \   0000000E   ........           BL       Gpio_SetPinData
    969            SetOutput();
   \   00000012   ........           BL       SetOutput
    970            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \   00000016   0121               MOVS     R1,#+1
   \   00000018   1420               MOVS     R0,#+20
   \   0000001A   ........           BL       Gpio_SetPinData
    971            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
   \   0000001E   0121               MOVS     R1,#+1
   \   00000020   0920               MOVS     R0,#+9
   \   00000022   ........           BL       Gpio_SetPinData
    972            SendData(command);
   \   00000026   2000               MOVS     R0,R4
   \   00000028   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002A   000E               LSRS     R0,R0,#+24
   \   0000002C   ........           BL       SendData
    973            DelayUs(1);
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   ........           BL       DelayUs
    974            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   0920               MOVS     R0,#+9
   \   0000003A   ........           BL       Gpio_SetPinData
    975            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   1420               MOVS     R0,#+20
   \   00000042   ........           BL       Gpio_SetPinData
    976            SetHiZ();
   \   00000046   ........           BL       SetHiZ
    977            DelayUs(1);
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   ........           BL       DelayUs
    978          }
   \   00000050   10BC               POP      {R4}
   \   00000052   08BC               POP      {R3}
   \   00000054   1847               BX       R3               ;; return
    979          
    980          /******************************************************************************
    981          * This function sends a data to the display controller
    982          *
    983          * Interface assumptions:
    984          *
    985          *
    986          * Return value:
    987          * None
    988          *
    989          *
    990          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    991          void LCD_WriteData(uint8_t data)
    992          {
   \                     LCD_WriteData:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    993            /* clear the error indicator */
    994            mErrorIndicator = gLCD_NoError_c;
   \   00000004   ....               LDR      R0,??DataTable11_2
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   0170               STRB     R1,[R0, #+0]
    995          
    996            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   1520               MOVS     R0,#+21
   \   0000000E   ........           BL       Gpio_SetPinData
    997            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   1420               MOVS     R0,#+20
   \   00000016   ........           BL       Gpio_SetPinData
    998            SetOutput();
   \   0000001A   ........           BL       SetOutput
    999            SendData(data);
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000022   000E               LSRS     R0,R0,#+24
   \   00000024   ........           BL       SendData
   1000            Gpio_SetPinData(LCD_WR, LCD_WR_ACTIVE);
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   0920               MOVS     R0,#+9
   \   0000002C   ........           BL       Gpio_SetPinData
   1001            DelayUs(1);
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   ........           BL       DelayUs
   1002            Gpio_SetPinData(LCD_WR, LCD_WR_INACTIVE);
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   0920               MOVS     R0,#+9
   \   0000003A   ........           BL       Gpio_SetPinData
   1003            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   1420               MOVS     R0,#+20
   \   00000042   ........           BL       Gpio_SetPinData
   1004            SetHiZ();
   \   00000046   ........           BL       SetHiZ
   1005            DelayUs(1);  
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   ........           BL       DelayUs
   1006           
   1007          }
   \   00000050   10BC               POP      {R4}
   \   00000052   08BC               POP      {R3}
   \   00000054   1847               BX       R3               ;; return
   1008          
   1009          /******************************************************************************
   1010          * This function sets the font received as parameter as default font
   1011          *
   1012          * Interface assumptions:
   1013          *
   1014          *
   1015          * Return value:
   1016          *      TRUE:  when the font is correctly set
   1017          *      FALSE: when an unsupported font is received as parameter
   1018          * char
   1019          *
   1020          *
   1021          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1022          bool_t LCD_SetFont(lcdFontType_t font)
   1023          {
   \                     LCD_SetFont:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
   1024            /* clear the error indicator */
   1025            mErrorIndicator = gLCD_NoError_c;
   \   00000004   ....               LDR      R0,??DataTable11_2
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   0270               STRB     R2,[R0, #+0]
   1026          
   1027            if(gLCDNumFonts_c > font)
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   0229               CMP      R1,#+2
   \   00000010   03D2               BCS      ??LCD_SetFont_0
   1028            {
   1029              mDisplayParams.currentFontType = font;
   \   00000012   ....               LDR      R0,??DataTable13
   \   00000014   4173               STRB     R1,[R0, #+13]
   1030              return TRUE;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   00E0               B        ??LCD_SetFont_1
   1031            }
   1032            else
   1033            {
   1034              return FALSE;
   \                     ??LCD_SetFont_0:
   \   0000001A   0020               MOVS     R0,#+0
   \                     ??LCD_SetFont_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
   1035            }
   1036          }
   1037          
   1038          /******************************************************************************
   1039          * This function checks if an error occured during an interface function call.
   1040          * User must always call this function to verify if an interface function executed 
   1041          * successufully.
   1042          *
   1043          * Interface assumptions:
   1044          *
   1045          *
   1046          * Return value:  lcdError_t
   1047          *      gLCD_NoError_c:   no error
   1048          *      gLCD_QueueFull_c: queue is full
   1049          *
   1050          *
   1051          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1052          lcdError_t LCD_CheckError(void)
   1053          {
   1054            return mErrorIndicator;
   \                     LCD_CheckError:
   \   00000000   ....               LDR      R0,??DataTable11_2
   \   00000002   0078               LDRB     R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
   1055          }
   1056          
   1057          /************************************************************************************
   1058          *************************************************************************************
   1059          * Private functions
   1060          *************************************************************************************
   1061          ************************************************************************************/
   1062          
   1063          /******************************************************************************
   1064          * LCD task
   1065          *
   1066          * Interface assumptions:
   1067          *
   1068          *
   1069          * Return value:
   1070          * None
   1071          *
   1072          *
   1073          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1074          void LCD_Task(event_t events)
   1075          {
   \                     LCD_Task:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
   1076            static opLine_t mOperationLine;
   1077            (void)events;
   1078          
   1079            /* pop a new operation from the queue, only if the precedent operation was finished */
   1080            if(mOperationCompleted)
   \   00000006   ....               LDR      R0,??DataTable13_1
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   08D0               BEQ      ??LCD_Task_0
   1081            {
   1082              mOperationLine = RemoveFromQueue();     
   \   0000000E   ........           BL       RemoveFromQueue
   \   00000012   0090               STR      R0,[SP, #+0]
   \   00000014   ....               LDR      R0,??DataTable13_2
   \   00000016   6946               MOV      R1,SP
   \   00000018   0A78               LDRB     R2,[R1, #0]
   \   0000001A   0270               STRB     R2,[R0, #0]
   \   0000001C   4A78               LDRB     R2,[R1, #+1]
   \   0000001E   4270               STRB     R2,[R0, #+1]
   \                     ??LCD_Task_0:
   \   00000020   ....               LDR      R0,??DataTable13_2
   \   00000022   0068               LDR      R0,[R0, #+0]
   \   00000024   0090               STR      R0,[SP, #+0]
   1083            }
   1084          
   1085            ProcessOperation(mOperationLine);  
   \   00000026   0098               LDR      R0,[SP, #+0]
   \   00000028   ........           BL       ProcessOperation
   1086          
   1087            if(!IsQueueEmpty())
   \   0000002C   ........           BL       IsQueueEmpty
   \   00000030   0028               CMP      R0,#+0
   \   00000032   04D1               BNE      ??LCD_Task_1
   1088            {
   1089              /* prepare for next operation */
   1090              TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);     
   \   00000034   0121               MOVS     R1,#+1
   \   00000036   ....               LDR      R0,??DataTable13_3
   \   00000038   0078               LDRB     R0,[R0, #+0]
   \   0000003A   ........           BL       TS_SendEvent
   1091            }
   1092            
   1093          } 
   \                     ??LCD_Task_1:
   \   0000003E   13BC               POP      {R0,R1,R4}
   \   00000040   08BC               POP      {R3}
   \   00000042   1847               BX       R3               ;; return

   \                                 In section .bss, align 4
   \                     ??mOperationLine:
   \   00000000                      DS8 4
   1094          
   1095          /******************************************************************************
   1096          * This function initializes the LCD Task
   1097          *
   1098          * Interface assumptions:
   1099          *
   1100          *
   1101          * Return value:
   1102          * None
   1103          *
   1104          *
   1105          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1106          void LCD_TaskInit(void)
   1107          {
   \                     LCD_TaskInit:
   \   00000000   80B5               PUSH     {R7,LR}
   1108            gLCDTaskID = TS_CreateTask(gTsLCDTaskPriority_c, LCD_Task);
   \   00000002   ....               LDR      R1,??DataTable13_4
   \   00000004   0320               MOVS     R0,#+3
   \   00000006   ........           BL       TS_CreateTask
   \   0000000A   ....               LDR      R1,??DataTable13_3
   \   0000000C   0870               STRB     R0,[R1, #+0]
   1109          }
   \   0000000E   09BC               POP      {R0,R3}
   \   00000010   1847               BX       R3               ;; return
   1110          
   1111          /******************************************************************************
   1112          * This function enables/disables the backlight
   1113          *
   1114          * Interface assumptions:
   1115          *   0 - disable backlight
   1116          *   >0 - enables backlight
   1117          *
   1118          *
   1119          * Return value:
   1120          * None
   1121          *
   1122          *
   1123          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1124          void LCD_SetBacklight(uint8_t brightnessValue)
   1125          {
   \                     LCD_SetBacklight:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
   1126          #ifdef gLcdBackLightEnabled_d
   1127          /* this was removed due to electrical influence on RF TX */
   1128              GpioPinState_t backLightState;
   1129              backLightState = (0 != brightnessValue) ? gGpioPinStateHigh_c : gGpioPinStateLow_c;
   \   00000004   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000006   2D0E               LSRS     R5,R5,#+24
   \   00000008   002D               CMP      R5,#+0
   \   0000000A   01D0               BEQ      ??LCD_SetBacklight_0
   \   0000000C   0124               MOVS     R4,#+1
   \   0000000E   00E0               B        ??LCD_SetBacklight_1
   \                     ??LCD_SetBacklight_0:
   \   00000010   0024               MOVS     R4,#+0
   1130              Gpio_SetPinData(LCD_BL_PWM,  backLightState);
   \                     ??LCD_SetBacklight_1:
   \   00000012   2100               MOVS     R1,R4
   \   00000014   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000016   090E               LSRS     R1,R1,#+24
   \   00000018   0A20               MOVS     R0,#+10
   \   0000001A   ........           BL       Gpio_SetPinData
   1131          #else
   1132              (void)brightnessValue;
   1133          #endif /* gLcdBackLightEnabled_d */
   1134          }
   \   0000001E   31BC               POP      {R0,R4,R5}
   \   00000020   08BC               POP      {R3}
   \   00000022   1847               BX       R3               ;; return
   1135          
   1136          /******************************************************************************
   1137          * This function sets/ clears the pixel from (XStartCoord, YStartCoord)
   1138          *
   1139          * Interface assumptions:
   1140          *
   1141          *
   1142          * Return value:
   1143          * None
   1144          *
   1145          *
   1146          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1147          void LCD_WritePixel(uint8_t xStartCoord, uint8_t yStartCoord, bool_t mode)
   1148          {
   \                     LCD_WritePixel:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   1149            uint8_t page;
   1150            uint8_t read;
   1151          
   1152            if (xStartCoord>=gLCDMaxColumns_c || yStartCoord>=gLCDMaxLines_c)
   \   00000006   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000008   240E               LSRS     R4,R4,#+24
   \   0000000A   802C               CMP      R4,#+128
   \   0000000C   03D2               BCS      ??LCD_WritePixel_0
   \   0000000E   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000010   360E               LSRS     R6,R6,#+24
   \   00000012   402E               CMP      R6,#+64
   \   00000014   00D3               BCC      ??LCD_WritePixel_1
   1153            {
   1154              return; /* if pixel out of screen exit */
   \                     ??LCD_WritePixel_0:
   \   00000016   53E0               B        ??LCD_WritePixel_2
   1155            }
   1156          
   1157            page = yStartCoord >> 3;
   \                     ??LCD_WritePixel_1:
   \   00000018   3000               MOVS     R0,R6
   \   0000001A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001C   000E               LSRS     R0,R0,#+24
   \   0000001E   C008               LSRS     R0,R0,#+3
   \   00000020   0500               MOVS     R5,R0
   1158            yStartCoord %= 8;
   \   00000022   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000024   360E               LSRS     R6,R6,#+24
   \   00000026   3000               MOVS     R0,R6
   \   00000028   0821               MOVS     R1,#+8
   \   0000002A   ........           BL       __aeabi_idivmod
   \   0000002E   0E00               MOVS     R6,R1
   1159          
   1160            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \   00000030   4020               MOVS     R0,#+64
   \   00000032   ........           BL       LCD_WriteCommand
   1161            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \   00000036   2800               MOVS     R0,R5
   \   00000038   5038               SUBS     R0,R0,#+80
   \   0000003A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000003C   000E               LSRS     R0,R0,#+24
   \   0000003E   ........           BL       LCD_WriteCommand
   1162            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \   00000042   2100               MOVS     R1,R4
   \   00000044   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000046   090E               LSRS     R1,R1,#+24
   \   00000048   0909               LSRS     R1,R1,#+4
   \   0000004A   1020               MOVS     R0,#+16
   \   0000004C   0843               ORRS     R0,R0,R1
   \   0000004E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000050   000E               LSRS     R0,R0,#+24
   \   00000052   ........           BL       LCD_WriteCommand
   1163            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));       
   \   00000056   2007               LSLS     R0,R4,#+28       ;; ZeroExtS R0,R4,#+28,#+28
   \   00000058   000F               LSRS     R0,R0,#+28
   \   0000005A   ........           BL       LCD_WriteCommand
   1164          
   1165            read = ReadData(); // Dummy read
   \   0000005E   ........           BL       ReadData
   \   00000062   0700               MOVS     R7,R0
   1166            read = ReadData();
   \   00000064   ........           BL       ReadData
   \   00000068   0700               MOVS     R7,R0
   1167          
   1168            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \   0000006A   4020               MOVS     R0,#+64
   \   0000006C   ........           BL       LCD_WriteCommand
   1169            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \   00000070   2800               MOVS     R0,R5
   \   00000072   5038               SUBS     R0,R0,#+80
   \   00000074   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000076   000E               LSRS     R0,R0,#+24
   \   00000078   ........           BL       LCD_WriteCommand
   1170            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \   0000007C   2100               MOVS     R1,R4
   \   0000007E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000080   090E               LSRS     R1,R1,#+24
   \   00000082   0909               LSRS     R1,R1,#+4
   \   00000084   1020               MOVS     R0,#+16
   \   00000086   0843               ORRS     R0,R0,R1
   \   00000088   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000008A   000E               LSRS     R0,R0,#+24
   \   0000008C   ........           BL       LCD_WriteCommand
   1171            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));
   \   00000090   2007               LSLS     R0,R4,#+28       ;; ZeroExtS R0,R4,#+28,#+28
   \   00000092   000F               LSRS     R0,R0,#+28
   \   00000094   ........           BL       LCD_WriteCommand
   1172          
   1173            if( TRUE == mode )
   \   00000098   6846               MOV      R0,SP
   \   0000009A   0078               LDRB     R0,[R0, #+0]
   \   0000009C   0128               CMP      R0,#+1
   \   0000009E   07D1               BNE      ??LCD_WritePixel_3
   1174            {
   1175              LCD_WriteData((read | (1 << yStartCoord)));
   \   000000A0   0120               MOVS     R0,#+1
   \   000000A2   B040               LSLS     R0,R0,R6
   \   000000A4   3843               ORRS     R0,R0,R7
   \   000000A6   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000A8   000E               LSRS     R0,R0,#+24
   \   000000AA   ........           BL       LCD_WriteData
   \   000000AE   07E0               B        ??LCD_WritePixel_4
   1176            }
   1177            else
   1178            {  
   1179              LCD_WriteData((read & ~(1 << yStartCoord)));  
   \                     ??LCD_WritePixel_3:
   \   000000B0   0121               MOVS     R1,#+1
   \   000000B2   B140               LSLS     R1,R1,R6
   \   000000B4   C843               MVNS     R0,R1
   \   000000B6   3840               ANDS     R0,R0,R7
   \   000000B8   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000BA   000E               LSRS     R0,R0,#+24
   \   000000BC   ........           BL       LCD_WriteData
   1180            }
   1181          }
   \                     ??LCD_WritePixel_4:
   \                     ??LCD_WritePixel_2:
   \   000000C0   F1BC               POP      {R0,R4-R7}
   \   000000C2   08BC               POP      {R3}
   \   000000C4   1847               BX       R3               ;; return
   1182          
   1183          /******************************************************************************
   1184          * This function displays a character starting with xCoord and yCoord
   1185          *
   1186          * Interface assumptions:
   1187          *  yCoord is a multiple of 8
   1188          *
   1189          *
   1190          * Return value:
   1191          * None
   1192          *
   1193          *
   1194          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1195          void LCD_WriteCharacter(uint8_t symbol, uint8_t xCoord, uint8_t yCoord)
   1196          {
   \                     LCD_WriteCharacter:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1600               MOVS     R6,R2
   1197            uint16_t arrayLocation=0; 
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0700               MOVS     R7,R0
   1198            uint8_t i, maxLength;
   1199           
   1200            /* if pixel out of screen, exit */
   1201            if((xCoord >= gLCDMaxColumns_c) && (yCoord >= gLCDMaxLines_c))
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   007A               LDRB     R0,[R0, #+8]
   \   0000000E   8028               CMP      R0,#+128
   \   00000010   03D3               BCC      ??LCD_WriteCharacter_0
   \   00000012   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000014   360E               LSRS     R6,R6,#+24
   \   00000016   402E               CMP      R6,#+64
   \   00000018   76D2               BCS      ??LCD_WriteCharacter_1
   1202            {
   1203              return;
   1204            }
   1205              
   1206            arrayLocation = symbol - mFontOffset_c;
   \                     ??LCD_WriteCharacter_0:
   \   0000001A   6846               MOV      R0,SP
   \   0000001C   0079               LDRB     R0,[R0, #+4]
   \   0000001E   2038               SUBS     R0,R0,#+32
   \   00000020   0700               MOVS     R7,R0
   1207            maxLength = aLCDFont[mDisplayParams.currentFontType].fontHeight;
   \   00000022   ....               LDR      R0,??DataTable13
   \   00000024   407B               LDRB     R0,[R0, #+13]
   \   00000026   0C21               MOVS     R1,#+12
   \   00000028   4843               MULS     R0,R1,R0
   \   0000002A   ....               LDR      R1,??DataTable14
   \   0000002C   0818               ADDS     R0,R1,R0
   \   0000002E   007A               LDRB     R0,[R0, #+8]
   \   00000030   0500               MOVS     R5,R0
   1208            /* each character has: 
   1209            *  (aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation+1] - 
   1210            *   aLCDFont[mDisplayParams.currentFontType].pFontIndex[arrayLocation]) pixels as width 
   1211            *  (aLCDFont[mDisplayParams.currentFontType].fontHeight * 8) pixels as height 
   1212            */
   1213            while(maxLength > 0)
   \                     ??LCD_WriteCharacter_2:
   \   00000032   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000034   2D0E               LSRS     R5,R5,#+24
   \   00000036   012D               CMP      R5,#+1
   \   00000038   66D3               BCC      ??LCD_WriteCharacter_3
   1214            {
   1215              maxLength--;      
   \   0000003A   6D1E               SUBS     R5,R5,#+1
   1216              InitDisplayWrite(xCoord,yCoord);        
   \   0000003C   3100               MOVS     R1,R6
   \   0000003E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000040   090E               LSRS     R1,R1,#+24
   \   00000042   6846               MOV      R0,SP
   \   00000044   007A               LDRB     R0,[R0, #+8]
   \   00000046   ........           BL       InitDisplayWrite
   1217              /* mark line as written */
   1218              mDisplayParams.writtenLines |= (1<<(yCoord>>3));   
   \   0000004A   ....               LDR      R0,??DataTable13
   \   0000004C   C078               LDRB     R0,[R0, #+3]
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   3200               MOVS     R2,R6
   \   00000052   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000054   120E               LSRS     R2,R2,#+24
   \   00000056   D208               LSRS     R2,R2,#+3
   \   00000058   9140               LSLS     R1,R1,R2
   \   0000005A   0143               ORRS     R1,R1,R0
   \   0000005C   ....               LDR      R0,??DataTable13
   \   0000005E   C170               STRB     R1,[R0, #+3]
   1219              for(i = 0;
   \   00000060   0020               MOVS     R0,#+0
   \   00000062   0400               MOVS     R4,R0
   1220                  i < ((aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation+1] - 
   1221                        aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]) *
   1222                        aLCDFont[mDisplayParams.currentFontType].fontHeight);
   \                     ??LCD_WriteCharacter_4:
   \   00000064   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000066   240E               LSRS     R4,R4,#+24
   \   00000068   3F04               LSLS     R7,R7,#+16       ;; ZeroExtS R7,R7,#+16,#+16
   \   0000006A   3F0C               LSRS     R7,R7,#+16
   \   0000006C   0220               MOVS     R0,#+2
   \   0000006E   7843               MULS     R0,R7,R0
   \   00000070   ....               LDR      R1,??DataTable13
   \   00000072   497B               LDRB     R1,[R1, #+13]
   \   00000074   0C22               MOVS     R2,#+12
   \   00000076   5143               MULS     R1,R2,R1
   \   00000078   ....               LDR      R2,??DataTable14
   \   0000007A   5158               LDR      R1,[R2, R1]
   \   0000007C   0818               ADDS     R0,R1,R0
   \   0000007E   4088               LDRH     R0,[R0, #+2]
   \   00000080   3F04               LSLS     R7,R7,#+16       ;; ZeroExtS R7,R7,#+16,#+16
   \   00000082   3F0C               LSRS     R7,R7,#+16
   \   00000084   0221               MOVS     R1,#+2
   \   00000086   7943               MULS     R1,R7,R1
   \   00000088   ....               LDR      R2,??DataTable13
   \   0000008A   527B               LDRB     R2,[R2, #+13]
   \   0000008C   0C23               MOVS     R3,#+12
   \   0000008E   5A43               MULS     R2,R3,R2
   \   00000090   ....               LDR      R3,??DataTable14
   \   00000092   9A58               LDR      R2,[R3, R2]
   \   00000094   515A               LDRH     R1,[R2, R1]
   \   00000096   401A               SUBS     R0,R0,R1
   \   00000098   ....               LDR      R1,??DataTable13
   \   0000009A   497B               LDRB     R1,[R1, #+13]
   \   0000009C   0C22               MOVS     R2,#+12
   \   0000009E   5143               MULS     R1,R2,R1
   \   000000A0   ....               LDR      R2,??DataTable14
   \   000000A2   5118               ADDS     R1,R2,R1
   \   000000A4   097A               LDRB     R1,[R1, #+8]
   \   000000A6   4843               MULS     R0,R1,R0
   \   000000A8   8442               CMP      R4,R0
   \   000000AA   2BDA               BGE      ??LCD_WriteCharacter_5
   1223                  i += aLCDFont[mDisplayParams.currentFontType].fontHeight)        
   1224              {
   1225                /* in case the character is representd on multiple lines,
   1226                 * (aLCDFont[mDisplayParams.currentFontType].fontHeight > 1),
   1227                 * display first the upper part of the character and after the lower part 
   1228                 */
   1229                LCD_WriteData(aLCDFont[mDisplayParams.currentFontType].pFontCharTable[aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[arrayLocation]*aLCDFont[mDisplayParams.currentFontType].fontHeight + i + maxLength]);
   \   000000AC   3F04               LSLS     R7,R7,#+16       ;; ZeroExtS R7,R7,#+16,#+16
   \   000000AE   3F0C               LSRS     R7,R7,#+16
   \   000000B0   0220               MOVS     R0,#+2
   \   000000B2   7843               MULS     R0,R7,R0
   \   000000B4   ....               LDR      R1,??DataTable13
   \   000000B6   497B               LDRB     R1,[R1, #+13]
   \   000000B8   0C22               MOVS     R2,#+12
   \   000000BA   5143               MULS     R1,R2,R1
   \   000000BC   ....               LDR      R2,??DataTable14
   \   000000BE   5158               LDR      R1,[R2, R1]
   \   000000C0   085A               LDRH     R0,[R1, R0]
   \   000000C2   ....               LDR      R1,??DataTable13
   \   000000C4   497B               LDRB     R1,[R1, #+13]
   \   000000C6   0C22               MOVS     R2,#+12
   \   000000C8   5143               MULS     R1,R2,R1
   \   000000CA   ....               LDR      R2,??DataTable14
   \   000000CC   5118               ADDS     R1,R2,R1
   \   000000CE   097A               LDRB     R1,[R1, #+8]
   \   000000D0   4843               MULS     R0,R1,R0
   \   000000D2   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000000D4   240E               LSRS     R4,R4,#+24
   \   000000D6   0019               ADDS     R0,R0,R4
   \   000000D8   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000DA   2D0E               LSRS     R5,R5,#+24
   \   000000DC   4019               ADDS     R0,R0,R5
   \   000000DE   ....               LDR      R1,??DataTable13
   \   000000E0   497B               LDRB     R1,[R1, #+13]
   \   000000E2   0C22               MOVS     R2,#+12
   \   000000E4   5143               MULS     R1,R2,R1
   \   000000E6   ....               LDR      R2,??DataTable14
   \   000000E8   5118               ADDS     R1,R2,R1
   \   000000EA   4968               LDR      R1,[R1, #+4]
   \   000000EC   085C               LDRB     R0,[R1, R0]
   \   000000EE   ........           BL       LCD_WriteData
   1230              }
   \   000000F2   ....               LDR      R0,??DataTable13
   \   000000F4   407B               LDRB     R0,[R0, #+13]
   \   000000F6   0C21               MOVS     R1,#+12
   \   000000F8   4843               MULS     R0,R1,R0
   \   000000FA   ....               LDR      R1,??DataTable14
   \   000000FC   0818               ADDS     R0,R1,R0
   \   000000FE   007A               LDRB     R0,[R0, #+8]
   \   00000100   2418               ADDS     R4,R4,R0
   \   00000102   AFE7               B        ??LCD_WriteCharacter_4
   1231              yCoord += 8;
   \                     ??LCD_WriteCharacter_5:
   \   00000104   0836               ADDS     R6,R6,#+8
   \   00000106   94E7               B        ??LCD_WriteCharacter_2
   1232            }    
   1233          }
   \                     ??LCD_WriteCharacter_3:
   \                     ??LCD_WriteCharacter_1:
   \   00000108   F7BC               POP      {R0-R2,R4-R7}
   \   0000010A   08BC               POP      {R3}
   \   0000010C   1847               BX       R3               ;; return
   1234          
   1235          /******************************************************************************
   1236          * This function displays a symbol starting with xCoord and yCoord
   1237          *
   1238          * Interface assumptions:
   1239          *  yCoord is a multiple of 8
   1240          *
   1241          *
   1242          * Return value:
   1243          * None
   1244          *
   1245          *
   1246          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1247          void LCD_WriteSymbol(uint8_t index, uint8_t xCoord, uint8_t yCoord, uint8_t* bitmap)
   1248          { 
   \                     LCD_WriteSymbol:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0F00               MOVS     R7,R1
   \   00000004   1600               MOVS     R6,R2
   \   00000006   1C00               MOVS     R4,R3
   1249            uint8_t i;
   1250           
   1251            /* if pixel out of screen, exit */
   1252            if((xCoord >= gLCDMaxColumns_c) && (yCoord >= gLCDMaxLines_c))
   \   00000008   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000000A   3F0E               LSRS     R7,R7,#+24
   \   0000000C   802F               CMP      R7,#+128
   \   0000000E   03D3               BCC      ??LCD_WriteSymbol_0
   \   00000010   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000012   360E               LSRS     R6,R6,#+24
   \   00000014   402E               CMP      R6,#+64
   \   00000016   26D2               BCS      ??LCD_WriteSymbol_1
   1253            {
   1254              return;
   1255            }
   1256            /* if gsBitmap is NULL, exit */
   1257            if(bitmap == NULL)
   \                     ??LCD_WriteSymbol_0:
   \   00000018   002C               CMP      R4,#+0
   \   0000001A   24D0               BEQ      ??LCD_WriteSymbol_1
   1258            {
   1259              return;
   1260            }  
   1261          
   1262            /* each symbol has: 
   1263            *  8 pixels as width 
   1264            *  8 pixels as height 
   1265            */    
   1266            InitDisplayWrite(xCoord,yCoord);        
   \                     ??LCD_WriteSymbol_2:
   \   0000001C   3100               MOVS     R1,R6
   \   0000001E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000020   090E               LSRS     R1,R1,#+24
   \   00000022   3800               MOVS     R0,R7
   \   00000024   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000026   000E               LSRS     R0,R0,#+24
   \   00000028   ........           BL       InitDisplayWrite
   1267            /* mark line as written */
   1268            mDisplayParams.writtenLines |= (1<<(yCoord>>3));   
   \   0000002C   ....               LDR      R0,??DataTable14_1
   \   0000002E   C078               LDRB     R0,[R0, #+3]
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   3200               MOVS     R2,R6
   \   00000034   1206               LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
   \   00000036   120E               LSRS     R2,R2,#+24
   \   00000038   D208               LSRS     R2,R2,#+3
   \   0000003A   9140               LSLS     R1,R1,R2
   \   0000003C   0143               ORRS     R1,R1,R0
   \   0000003E   ....               LDR      R0,??DataTable14_1
   \   00000040   C170               STRB     R1,[R0, #+3]
   1269            for(i = 0; i < mSymbolWidth; i++)        
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   0500               MOVS     R5,R0
   \                     ??LCD_WriteSymbol_3:
   \   00000046   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000048   2D0E               LSRS     R5,R5,#+24
   \   0000004A   082D               CMP      R5,#+8
   \   0000004C   0BD2               BCS      ??LCD_WriteSymbol_4
   1270            {
   1271              /* write the symbol */
   1272              LCD_WriteData(bitmap[index * mSymbolWidth + i]);
   \   0000004E   6846               MOV      R0,SP
   \   00000050   0078               LDRB     R0,[R0, #+0]
   \   00000052   0821               MOVS     R1,#+8
   \   00000054   4843               MULS     R0,R1,R0
   \   00000056   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000058   2D0E               LSRS     R5,R5,#+24
   \   0000005A   4019               ADDS     R0,R0,R5
   \   0000005C   205C               LDRB     R0,[R4, R0]
   \   0000005E   ........           BL       LCD_WriteData
   1273            }
   \   00000062   6D1C               ADDS     R5,R5,#+1
   \   00000064   EFE7               B        ??LCD_WriteSymbol_3
   1274          }
   \                     ??LCD_WriteSymbol_4:
   \                     ??LCD_WriteSymbol_1:
   \   00000066   F1BC               POP      {R0,R4-R7}
   \   00000068   08BC               POP      {R3}
   \   0000006A   1847               BX       R3               ;; return
   1275          
   1276          /****************************************************************************************
   1277          * This function clears the pixels between startXCoord and endXCoord within a single page
   1278          * (page located at yCoord)
   1279          *
   1280          * Interface assumptions:
   1281          *
   1282          *
   1283          * Return value:
   1284          * None
   1285          *
   1286          *
   1287          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1288          void LCD_ClearPage(uint8_t startXCoord, uint8_t endXCoord, uint8_t yCoord)
   1289          {
   \                     LCD_ClearPage:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1700               MOVS     R7,R2
   1290            uint8_t i;
   1291            
   1292            InitDisplayWrite(startXCoord, yCoord);
   \   00000008   3900               MOVS     R1,R7
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   3000               MOVS     R0,R6
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   ........           BL       InitDisplayWrite
   1293            for(i = startXCoord; i < endXCoord; i++)
   \   00000018   3500               MOVS     R5,R6
   \                     ??LCD_ClearPage_0:
   \   0000001A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001C   2D0E               LSRS     R5,R5,#+24
   \   0000001E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000020   240E               LSRS     R4,R4,#+24
   \   00000022   A542               CMP      R5,R4
   \   00000024   04D2               BCS      ??LCD_ClearPage_1
   1294            {
   1295              LCD_WriteData(OFF);    
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   ........           BL       LCD_WriteData
   1296            }    
   \   0000002C   6D1C               ADDS     R5,R5,#+1
   \   0000002E   F4E7               B        ??LCD_ClearPage_0
   1297          }
   \                     ??LCD_ClearPage_1:
   \   00000030   F1BC               POP      {R0,R4-R7}
   \   00000032   08BC               POP      {R3}
   \   00000034   1847               BX       R3               ;; return
   1298          
   1299          /****************************************************************************************
   1300          * This function clears an entire LCD line
   1301          *
   1302          * Interface assumptions:
   1303          *     char line = 0..7
   1304          *
   1305          *
   1306          * Return value:
   1307          *     TRUE if the line was cleared
   1308          *     FALSE if the line is not cleared yet
   1309          *     0xFF  if the line parameter is not valid
   1310          * None
   1311          *
   1312          *
   1313          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1314          uint8_t LCD_ClearLine(uint8_t line)
   1315          {
   \                     LCD_ClearLine:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1316            static pageParams_t pageToDelete;
   1317            static bool_t isPageDeleted = TRUE;
   1318            
   1319            if(line < gLCDMaxRamDataPages_c)
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   082C               CMP      R4,#+8
   \   0000000A   47D2               BCS      ??LCD_ClearLine_0
   1320            {
   1321              /* save the page coordinates */
   1322              if(isPageDeleted)
   \   0000000C   ....               LDR      R0,??DataTable14_2
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   0028               CMP      R0,#+0
   \   00000012   15D0               BEQ      ??LCD_ClearLine_1
   1323              {
   1324                pageToDelete.xStartCoord = mLineParams[line].xCoord;
   \   00000014   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000016   240E               LSRS     R4,R4,#+24
   \   00000018   0320               MOVS     R0,#+3
   \   0000001A   6043               MULS     R0,R4,R0
   \   0000001C   ....               LDR      R1,??DataTable14_3
   \   0000001E   085C               LDRB     R0,[R1, R0]
   \   00000020   ....               LDR      R1,??DataTable14_4
   \   00000022   0870               STRB     R0,[R1, #+0]
   1325                pageToDelete.xEndCoord   = gLCDMaxColumns_c;
   \   00000024   ....               LDR      R0,??DataTable14_4
   \   00000026   8021               MOVS     R1,#+128
   \   00000028   4170               STRB     R1,[R0, #+1]
   1326                pageToDelete.yCoord      = mLineParams[line].yCoord;
   \   0000002A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000002C   240E               LSRS     R4,R4,#+24
   \   0000002E   0320               MOVS     R0,#+3
   \   00000030   6043               MULS     R0,R4,R0
   \   00000032   ....               LDR      R1,??DataTable14_3
   \   00000034   0818               ADDS     R0,R1,R0
   \   00000036   4078               LDRB     R0,[R0, #+1]
   \   00000038   ....               LDR      R1,??DataTable14_4
   \   0000003A   8870               STRB     R0,[R1, #+2]
   1327                pageToDelete.line        = line; 
   \   0000003C   ....               LDR      R0,??DataTable14_4
   \   0000003E   C470               STRB     R4,[R0, #+3]
   1328              }
   1329              
   1330              /* delete only mMaxDeleteColumns_c columns once because of time constraints */
   1331              if(((pageToDelete.xEndCoord - pageToDelete.xStartCoord) >= mMaxDeleteColumns_c))
   \                     ??LCD_ClearLine_1:
   \   00000040   ....               LDR      R0,??DataTable14_4
   \   00000042   4078               LDRB     R0,[R0, #+1]
   \   00000044   ....               LDR      R1,??DataTable14_4
   \   00000046   0978               LDRB     R1,[R1, #+0]
   \   00000048   401A               SUBS     R0,R0,R1
   \   0000004A   2028               CMP      R0,#+32
   \   0000004C   19DB               BLT      ??LCD_ClearLine_2
   1332              {
   1333                /* the page will be deleted with (gLCDMaxColumns_c/mMaxDeleteColumns_c) consecutive operations */
   1334                isPageDeleted            = FALSE;
   \   0000004E   ....               LDR      R0,??DataTable14_2
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   0170               STRB     R1,[R0, #+0]
   1335                TS_SendEvent(gLCDTaskID, gLCDOpEvt_c); 
   \   00000054   0121               MOVS     R1,#+1
   \   00000056   ....               LDR      R0,??DataTable14_5
   \   00000058   0078               LDRB     R0,[R0, #+0]
   \   0000005A   ........           BL       TS_SendEvent
   1336                LCD_ClearPage(pageToDelete.xStartCoord, 
   1337                              pageToDelete.xStartCoord + mMaxDeleteColumns_c, 
   1338                              pageToDelete.yCoord); 
   \   0000005E   ....               LDR      R0,??DataTable14_4
   \   00000060   8278               LDRB     R2,[R0, #+2]
   \   00000062   ....               LDR      R0,??DataTable14_4
   \   00000064   0178               LDRB     R1,[R0, #+0]
   \   00000066   2031               ADDS     R1,R1,#+32
   \   00000068   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000006A   090E               LSRS     R1,R1,#+24
   \   0000006C   ....               LDR      R0,??DataTable14_4
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   ........           BL       LCD_ClearPage
   1339                /* compute the new xStartCoord for the current page */
   1340                pageToDelete.xStartCoord = pageToDelete.xStartCoord + mMaxDeleteColumns_c;        
   \   00000074   ....               LDR      R0,??DataTable14_4
   \   00000076   0078               LDRB     R0,[R0, #+0]
   \   00000078   2030               ADDS     R0,R0,#+32
   \   0000007A   ....               LDR      R1,??DataTable14_4
   \   0000007C   0870               STRB     R0,[R1, #+0]
   1341                return FALSE;  
   \   0000007E   0020               MOVS     R0,#+0
   \   00000080   0DE0               B        ??LCD_ClearLine_3
   1342              }
   1343              else
   1344              {    
   1345                LCD_ClearPage(pageToDelete.xStartCoord, 
   1346                              pageToDelete.xEndCoord, 
   1347                              pageToDelete.yCoord);
   \                     ??LCD_ClearLine_2:
   \   00000082   ....               LDR      R0,??DataTable14_4
   \   00000084   8278               LDRB     R2,[R0, #+2]
   \   00000086   ....               LDR      R0,??DataTable14_4
   \   00000088   4178               LDRB     R1,[R0, #+1]
   \   0000008A   ....               LDR      R0,??DataTable14_4
   \   0000008C   0078               LDRB     R0,[R0, #+0]
   \   0000008E   ........           BL       LCD_ClearPage
   1348                isPageDeleted            = TRUE;
   \   00000092   ....               LDR      R0,??DataTable14_2
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   0170               STRB     R1,[R0, #+0]
   1349                return TRUE;  
   \   00000098   0120               MOVS     R0,#+1
   \   0000009A   00E0               B        ??LCD_ClearLine_3
   1350              } 
   1351            }
   1352            else
   1353            {
   1354              return 0xFF;
   \                     ??LCD_ClearLine_0:
   \   0000009C   FF20               MOVS     R0,#+255
   \                     ??LCD_ClearLine_3:
   \   0000009E   10BC               POP      {R4}
   \   000000A0   08BC               POP      {R3}
   \   000000A2   1847               BX       R3               ;; return
   1355            }
   1356          }

   \                                 In section .bss, align 4
   \                     ??pageToDelete:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
   \                     ??isPageDeleted:
   \   00000000   01                 DC8 1
   1357          
   1358          /******************************************************************************
   1359          * This function process an LCD operation (clear, write string).
   1360          *
   1361          * Interface assumptions:
   1362          *
   1363          *
   1364          * Return value:
   1365          * None
   1366          *
   1367          *
   1368          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1369          static void ProcessOperation(opLine_t operationAndLine)
   1370          {
   \                     ProcessOperation:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1371            static uint8_t linesToClear = 0x00;
   1372            uint8_t line, i, deleteWriteLines = 0xFF;
   \   00000004   6846               MOV      R0,SP
   \   00000006   FF21               MOVS     R1,#+255
   \   00000008   0170               STRB     R1,[R0, #+0]
   1373            switch(operationAndLine.opQueue)
   \   0000000A   6846               MOV      R0,SP
   \   0000000C   007A               LDRB     R0,[R0, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   08D0               BEQ      ??ProcessOperation_0
   \   00000012   0228               CMP      R0,#+2
   \   00000014   00D1               BNE      .+4
   \   00000016   14E1               B        ??ProcessOperation_1
   \   00000018   00D2               BCS      .+4
   \   0000001A   B2E0               B        ??ProcessOperation_2
   \   0000001C   0328               CMP      R0,#+3
   \   0000001E   00D1               BNE      .+4
   \   00000020   2AE1               B        ??ProcessOperation_3
   \   00000022   BAE1               B        ??ProcessOperation_4
   1374            {  
   1375              case gLCD_WriteOp_c:  
   1376                if(mOperationCompleted)
   \                     ??ProcessOperation_0:
   \   00000024   C948               LDR      R0,??ProcessOperation_5
   \   00000026   0078               LDRB     R0,[R0, #+0]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   1BD0               BEQ      ??ProcessOperation_6
   1377                {
   1378                  line = operationAndLine.lineQueue;
   \   0000002C   02A8               ADD      R0,SP,#+8
   \   0000002E   4078               LDRB     R0,[R0, #+1]
   \   00000030   0500               MOVS     R5,R0
   1379                  /* initialize the start coordinates for the string to be written */ 
   1380                  mDisplayParams.currentLine = line;
   \   00000032   C748               LDR      R0,??ProcessOperation_5+0x4
   \   00000034   8570               STRB     R5,[R0, #+2]
   1381                  mDisplayParams.currentXCoord = mLineParams[line].xCoord;;  
   \   00000036   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000038   2D0E               LSRS     R5,R5,#+24
   \   0000003A   0320               MOVS     R0,#+3
   \   0000003C   6843               MULS     R0,R5,R0
   \   0000003E   D849               LDR      R1,??ProcessOperation_7
   \   00000040   085C               LDRB     R0,[R1, R0]
   \   00000042   C349               LDR      R1,??ProcessOperation_5+0x4
   \   00000044   0870               STRB     R0,[R1, #+0]
   1382                  mDisplayParams.currentYCoord = mLineParams[line].yCoord; 
   \   00000046   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000048   2D0E               LSRS     R5,R5,#+24
   \   0000004A   0320               MOVS     R0,#+3
   \   0000004C   6843               MULS     R0,R5,R0
   \   0000004E   D449               LDR      R1,??ProcessOperation_7
   \   00000050   0818               ADDS     R0,R1,R0
   \   00000052   4078               LDRB     R0,[R0, #+1]
   \   00000054   BE49               LDR      R1,??ProcessOperation_5+0x4
   \   00000056   4870               STRB     R0,[R1, #+1]
   1383                  mDisplayParams.currentStringIndex = 0;
   \   00000058   BD48               LDR      R0,??ProcessOperation_5+0x4
   \   0000005A   0021               MOVS     R1,#+0
   \   0000005C   8173               STRB     R1,[R0, #+14]
   1384                  mOperationCompleted               = FALSE;  
   \   0000005E   BB48               LDR      R0,??ProcessOperation_5
   \   00000060   0021               MOVS     R1,#+0
   \   00000062   0170               STRB     R1,[R0, #+0]
   1385                }      
   1386                /* display only mNumberOfCharToWrite_c characters once because of time constraints */
   1387                for(i = 0; ((i < mNumberOfCharToWrite_c)&&(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)); i++)
   \                     ??ProcessOperation_6:
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   0400               MOVS     R4,R0
   \                     ??ProcessOperation_8:
   \   00000068   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000006A   240E               LSRS     R4,R4,#+24
   \   0000006C   032C               CMP      R4,#+3
   \   0000006E   4AD2               BCS      ??ProcessOperation_9
   \   00000070   B748               LDR      R0,??ProcessOperation_5+0x4
   \   00000072   807B               LDRB     R0,[R0, #+14]
   \   00000074   1028               CMP      R0,#+16
   \   00000076   46D2               BCS      ??ProcessOperation_9
   1388                {
   1389                  /* display the character at the currentStringIndex in the currentString */
   1390                  LCD_WriteCharacter(mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex], 
   1391                                     mDisplayParams.currentXCoord, 
   1392                                     mDisplayParams.currentYCoord);             
   \   00000078   B548               LDR      R0,??ProcessOperation_5+0x4
   \   0000007A   4278               LDRB     R2,[R0, #+1]
   \   0000007C   B448               LDR      R0,??ProcessOperation_5+0x4
   \   0000007E   0178               LDRB     R1,[R0, #+0]
   \   00000080   B348               LDR      R0,??ProcessOperation_5+0x4
   \   00000082   807B               LDRB     R0,[R0, #+14]
   \   00000084   B24B               LDR      R3,??ProcessOperation_5+0x4
   \   00000086   9B78               LDRB     R3,[R3, #+2]
   \   00000088   1026               MOVS     R6,#+16
   \   0000008A   7343               MULS     R3,R6,R3
   \   0000008C   B04E               LDR      R6,??ProcessOperation_5+0x4
   \   0000008E   F318               ADDS     R3,R6,R3
   \   00000090   1818               ADDS     R0,R3,R0
   \   00000092   C07B               LDRB     R0,[R0, #+15]
   \   00000094   ........           BL       LCD_WriteCharacter
   1393                  /* compute X coordinate for the next character */
   1394                  mDisplayParams.currentXCoord += (aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] - mFontOffset_c + 1] - 
   1395                                                   aLCDFont[mDisplayParams.currentFontType].pFontIndexTable[mDisplayParams.currentString[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] - mFontOffset_c]);
   \   00000098   AD48               LDR      R0,??ProcessOperation_5+0x4
   \   0000009A   0078               LDRB     R0,[R0, #+0]
   \   0000009C   AC49               LDR      R1,??ProcessOperation_5+0x4
   \   0000009E   897B               LDRB     R1,[R1, #+14]
   \   000000A0   AB4A               LDR      R2,??ProcessOperation_5+0x4
   \   000000A2   9278               LDRB     R2,[R2, #+2]
   \   000000A4   1023               MOVS     R3,#+16
   \   000000A6   5A43               MULS     R2,R3,R2
   \   000000A8   A94B               LDR      R3,??ProcessOperation_5+0x4
   \   000000AA   9A18               ADDS     R2,R3,R2
   \   000000AC   5118               ADDS     R1,R2,R1
   \   000000AE   C97B               LDRB     R1,[R1, #+15]
   \   000000B0   0222               MOVS     R2,#+2
   \   000000B2   5143               MULS     R1,R2,R1
   \   000000B4   A64A               LDR      R2,??ProcessOperation_5+0x4
   \   000000B6   527B               LDRB     R2,[R2, #+13]
   \   000000B8   0C23               MOVS     R3,#+12
   \   000000BA   5A43               MULS     R2,R3,R2
   \   000000BC   ....               LDR      R3,??DataTable15
   \   000000BE   9A58               LDR      R2,[R3, R2]
   \   000000C0   5118               ADDS     R1,R2,R1
   \   000000C2   3E39               SUBS     R1,R1,#+62
   \   000000C4   0988               LDRH     R1,[R1, #+0]
   \   000000C6   4018               ADDS     R0,R0,R1
   \   000000C8   A149               LDR      R1,??ProcessOperation_5+0x4
   \   000000CA   897B               LDRB     R1,[R1, #+14]
   \   000000CC   A04A               LDR      R2,??ProcessOperation_5+0x4
   \   000000CE   9278               LDRB     R2,[R2, #+2]
   \   000000D0   1023               MOVS     R3,#+16
   \   000000D2   5A43               MULS     R2,R3,R2
   \   000000D4   9E4B               LDR      R3,??ProcessOperation_5+0x4
   \   000000D6   9A18               ADDS     R2,R3,R2
   \   000000D8   5118               ADDS     R1,R2,R1
   \   000000DA   C97B               LDRB     R1,[R1, #+15]
   \   000000DC   0222               MOVS     R2,#+2
   \   000000DE   5143               MULS     R1,R2,R1
   \   000000E0   9B4A               LDR      R2,??ProcessOperation_5+0x4
   \   000000E2   527B               LDRB     R2,[R2, #+13]
   \   000000E4   0C23               MOVS     R3,#+12
   \   000000E6   5A43               MULS     R2,R3,R2
   \   000000E8   ....               LDR      R3,??DataTable15
   \   000000EA   9A58               LDR      R2,[R3, R2]
   \   000000EC   5118               ADDS     R1,R2,R1
   \   000000EE   4039               SUBS     R1,R1,#+64
   \   000000F0   0988               LDRH     R1,[R1, #+0]
   \   000000F2   401A               SUBS     R0,R0,R1
   \   000000F4   9649               LDR      R1,??ProcessOperation_5+0x4
   \   000000F6   0870               STRB     R0,[R1, #+0]
   1396                  mDisplayParams.currentStringIndex++;  
   \   000000F8   9548               LDR      R0,??ProcessOperation_5+0x4
   \   000000FA   807B               LDRB     R0,[R0, #+14]
   \   000000FC   401C               ADDS     R0,R0,#+1
   \   000000FE   9449               LDR      R1,??ProcessOperation_5+0x4
   \   00000100   8873               STRB     R0,[R1, #+14]
   1397                }
   \   00000102   641C               ADDS     R4,R4,#+1
   \   00000104   B0E7               B        ??ProcessOperation_8
   1398                  
   1399                /* have we displayed the last character from the buffer? */
   1400                if(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)
   \                     ??ProcessOperation_9:
   \   00000106   9248               LDR      R0,??ProcessOperation_5+0x4
   \   00000108   807B               LDRB     R0,[R0, #+14]
   \   0000010A   1028               CMP      R0,#+16
   \   0000010C   05D2               BCS      ??ProcessOperation_10
   1401                {
   1402                  TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);
   \   0000010E   0121               MOVS     R1,#+1
   \   00000110   ....               LDR      R0,??DataTable15_1
   \   00000112   0078               LDRB     R0,[R0, #+0]
   \   00000114   ........           BL       TS_SendEvent
   \   00000118   3FE1               B        ??ProcessOperation_11
   1403                }
   1404                else
   1405                { /* reset display parameters */      
   1406                  mDisplayParams.linesWidthWritten[mDisplayParams.currentLine] = mDisplayParams.currentXCoord;
   \                     ??ProcessOperation_10:
   \   0000011A   8D48               LDR      R0,??ProcessOperation_5+0x4
   \   0000011C   8078               LDRB     R0,[R0, #+2]
   \   0000011E   8C49               LDR      R1,??ProcessOperation_5+0x4
   \   00000120   0818               ADDS     R0,R1,R0
   \   00000122   8B49               LDR      R1,??ProcessOperation_5+0x4
   \   00000124   0978               LDRB     R1,[R1, #+0]
   \   00000126   4171               STRB     R1,[R0, #+5]
   1407                  mDisplayParams.currentStringIndex = 0;       
   \   00000128   8948               LDR      R0,??ProcessOperation_5+0x4
   \   0000012A   0021               MOVS     R1,#+0
   \   0000012C   8173               STRB     R1,[R0, #+14]
   1408                  for(i = 0; i < aLCDFont[mDisplayParams.currentFontType].fontHeight; i++)
   \   0000012E   0020               MOVS     R0,#+0
   \   00000130   0400               MOVS     R4,R0
   \                     ??ProcessOperation_12:
   \   00000132   8748               LDR      R0,??ProcessOperation_5+0x4
   \   00000134   407B               LDRB     R0,[R0, #+13]
   \   00000136   0C21               MOVS     R1,#+12
   \   00000138   4843               MULS     R0,R1,R0
   \   0000013A   ....               LDR      R1,??DataTable15
   \   0000013C   0818               ADDS     R0,R1,R0
   \   0000013E   007A               LDRB     R0,[R0, #+8]
   \   00000140   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000142   240E               LSRS     R4,R4,#+24
   \   00000144   8442               CMP      R4,R0
   \   00000146   15D2               BCS      ??ProcessOperation_13
   1409                  { 
   1410                    /* clear the bitmask bit from linesToWrite because line was written  */
   1411                    mDisplayParams.linesToWrite &=(~(1<<(mDisplayParams.currentLine+i)));
   \   00000148   8148               LDR      R0,??ProcessOperation_5+0x4
   \   0000014A   0079               LDRB     R0,[R0, #+4]
   \   0000014C   0121               MOVS     R1,#+1
   \   0000014E   804A               LDR      R2,??ProcessOperation_5+0x4
   \   00000150   9278               LDRB     R2,[R2, #+2]
   \   00000152   1219               ADDS     R2,R2,R4
   \   00000154   9140               LSLS     R1,R1,R2
   \   00000156   8843               BICS     R0,R0,R1
   \   00000158   7D49               LDR      R1,??ProcessOperation_5+0x4
   \   0000015A   0871               STRB     R0,[R1, #+4]
   1412                    /* mark line as written */
   1413                    mDisplayParams.writtenLines |= (1<<(mDisplayParams.currentLine+i)); 
   \   0000015C   7C48               LDR      R0,??ProcessOperation_5+0x4
   \   0000015E   C078               LDRB     R0,[R0, #+3]
   \   00000160   0121               MOVS     R1,#+1
   \   00000162   7B4A               LDR      R2,??ProcessOperation_5+0x4
   \   00000164   9278               LDRB     R2,[R2, #+2]
   \   00000166   1219               ADDS     R2,R2,R4
   \   00000168   9140               LSLS     R1,R1,R2
   \   0000016A   0143               ORRS     R1,R1,R0
   \   0000016C   7848               LDR      R0,??ProcessOperation_5+0x4
   \   0000016E   C170               STRB     R1,[R0, #+3]
   1414                  }        
   \   00000170   641C               ADDS     R4,R4,#+1
   \   00000172   DEE7               B        ??ProcessOperation_12
   1415                  mDisplayParams.currentLine        = mMaxLineNumber_c;
   \                     ??ProcessOperation_13:
   \   00000174   7648               LDR      R0,??ProcessOperation_5+0x4
   \   00000176   0821               MOVS     R1,#+8
   \   00000178   8170               STRB     R1,[R0, #+2]
   1416                  mOperationCompleted               = TRUE;        
   \   0000017A   7448               LDR      R0,??ProcessOperation_5
   \   0000017C   0121               MOVS     R1,#+1
   \   0000017E   0170               STRB     R1,[R0, #+0]
   \   00000180   0BE1               B        ??ProcessOperation_11
   1417                }          
   1418                break;
   1419                
   1420              case gLCD_ClearDisplayOp_c:
   1421                if(mOperationCompleted)
   \                     ??ProcessOperation_2:
   \   00000182   7248               LDR      R0,??ProcessOperation_5
   \   00000184   0078               LDRB     R0,[R0, #+0]
   \   00000186   0028               CMP      R0,#+0
   \   00000188   1CD0               BEQ      ??ProcessOperation_14
   1422                {
   1423                  /* determine the lines that were written and need to be cleared */   
   1424                  linesToClear = mDisplayParams.writtenLines;  
   \   0000018A   7148               LDR      R0,??ProcessOperation_5+0x4
   \   0000018C   C078               LDRB     R0,[R0, #+3]
   \   0000018E   ....               LDR      R1,??DataTable15_2
   \   00000190   0870               STRB     R0,[R1, #+0]
   1425                  if(mIsLcdInitialized == TRUE)
   \   00000192   ....               LDR      R0,??DataTable15_3
   \   00000194   0078               LDRB     R0,[R0, #+0]
   \   00000196   0128               CMP      R0,#+1
   \   00000198   11D1               BNE      ??ProcessOperation_15
   1426                  {
   1427                    /* determine if there are lines that need to be erased and after need to be written */
   1428                    deleteWriteLines = linesToClear & mDisplayParams.linesToWrite;
   \   0000019A   6846               MOV      R0,SP
   \   0000019C   ....               LDR      R1,??DataTable15_2
   \   0000019E   0978               LDRB     R1,[R1, #+0]
   \   000001A0   6B4A               LDR      R2,??ProcessOperation_5+0x4
   \   000001A2   1279               LDRB     R2,[R2, #+4]
   \   000001A4   0A40               ANDS     R2,R2,R1
   \   000001A6   0270               STRB     R2,[R0, #+0]
   1429                    if(deleteWriteLines)
   \   000001A8   6846               MOV      R0,SP
   \   000001AA   0078               LDRB     R0,[R0, #+0]
   \   000001AC   0028               CMP      R0,#+0
   \   000001AE   06D0               BEQ      ??ProcessOperation_15
   1430                    { /* if there are */
   1431                      /* mark that lines as deleted and jump over them */
   1432                      linesToClear &= ~(deleteWriteLines);  
   \   000001B0   ....               LDR      R0,??DataTable15_2
   \   000001B2   0078               LDRB     R0,[R0, #+0]
   \   000001B4   6946               MOV      R1,SP
   \   000001B6   0978               LDRB     R1,[R1, #+0]
   \   000001B8   8843               BICS     R0,R0,R1
   \   000001BA   ....               LDR      R1,??DataTable15_2
   \   000001BC   0870               STRB     R0,[R1, #+0]
   1433                    }
   1434                  }
   1435                  mOperationCompleted               = FALSE;
   \                     ??ProcessOperation_15:
   \   000001BE   6348               LDR      R0,??ProcessOperation_5
   \   000001C0   0021               MOVS     R1,#+0
   \   000001C2   0170               STRB     R1,[R0, #+0]
   1436                }
   1437                
   1438                line = 0;
   \                     ??ProcessOperation_14:
   \   000001C4   0020               MOVS     R0,#+0
   \   000001C6   0500               MOVS     R5,R0
   1439                /* find the first written line */
   1440                while((!((linesToClear>>line)&0x01))&&(line<mMaxLineNumber_c))
   \                     ??ProcessOperation_16:
   \   000001C8   ....               LDR      R0,??DataTable15_2
   \   000001CA   0078               LDRB     R0,[R0, #+0]
   \   000001CC   2841               ASRS     R0,R0,R5
   \   000001CE   C007               LSLS     R0,R0,#+31
   \   000001D0   05D4               BMI      ??ProcessOperation_17
   \   000001D2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001D4   2D0E               LSRS     R5,R5,#+24
   \   000001D6   082D               CMP      R5,#+8
   \   000001D8   01D2               BCS      ??ProcessOperation_17
   1441                {
   1442                  line++;
   \   000001DA   6D1C               ADDS     R5,R5,#+1
   \   000001DC   F4E7               B        ??ProcessOperation_16
   1443                }
   1444                if(line!= mMaxLineNumber_c)
   \                     ??ProcessOperation_17:
   \   000001DE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000001E0   2D0E               LSRS     R5,R5,#+24
   \   000001E2   082D               CMP      R5,#+8
   \   000001E4   26D0               BEQ      ??ProcessOperation_18
   1445                {
   1446                  /* in case at least a line is written */
   1447                  if(TRUE == LCD_ClearLine(line))
   \   000001E6   2800               MOVS     R0,R5
   \   000001E8   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000001EA   000E               LSRS     R0,R0,#+24
   \   000001EC   ........           BL       LCD_ClearLine
   \   000001F0   0128               CMP      R0,#+1
   \   000001F2   00D0               BEQ      .+4
   \   000001F4   D1E0               B        ??ProcessOperation_11
   1448                  {
   1449                    /* mark line as cleared */
   1450                    mDisplayParams.writtenLines &= ~(1 << line);
   \   000001F6   5648               LDR      R0,??ProcessOperation_5+0x4
   \   000001F8   C078               LDRB     R0,[R0, #+3]
   \   000001FA   0121               MOVS     R1,#+1
   \   000001FC   A940               LSLS     R1,R1,R5
   \   000001FE   8843               BICS     R0,R0,R1
   \   00000200   5349               LDR      R1,??ProcessOperation_5+0x4
   \   00000202   C870               STRB     R0,[R1, #+3]
   1451                    linesToClear &= ~(1 << line);
   \   00000204   ....               LDR      R0,??DataTable15_2
   \   00000206   0078               LDRB     R0,[R0, #+0]
   \   00000208   0121               MOVS     R1,#+1
   \   0000020A   A940               LSLS     R1,R1,R5
   \   0000020C   8843               BICS     R0,R0,R1
   \   0000020E   ....               LDR      R1,??DataTable15_2
   \   00000210   0870               STRB     R0,[R1, #+0]
   1452                    /* check if there are other lines written */
   1453                    if(linesToClear)
   \   00000212   ....               LDR      R0,??DataTable15_2
   \   00000214   0078               LDRB     R0,[R0, #+0]
   \   00000216   0028               CMP      R0,#+0
   \   00000218   05D0               BEQ      ??ProcessOperation_19
   1454                    {
   1455                      /* prepare clearing the other line(s) */
   1456                      TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);          
   \   0000021A   0121               MOVS     R1,#+1
   \   0000021C   ....               LDR      R0,??DataTable15_1
   \   0000021E   0078               LDRB     R0,[R0, #+0]
   \   00000220   ........           BL       TS_SendEvent
   \   00000224   B9E0               B        ??ProcessOperation_11
   1457                    }
   1458                    else
   1459                    {
   1460                      mOperationCompleted = TRUE;
   \                     ??ProcessOperation_19:
   \   00000226   4948               LDR      R0,??ProcessOperation_5
   \   00000228   0121               MOVS     R1,#+1
   \   0000022A   0170               STRB     R1,[R0, #+0]
   1461                      mIsLcdInitialized   = TRUE;
   \   0000022C   ....               LDR      R0,??DataTable15_3
   \   0000022E   0121               MOVS     R1,#+1
   \   00000230   0170               STRB     R1,[R0, #+0]
   \   00000232   B2E0               B        ??ProcessOperation_11
   1462                    }          
   1463                  }
   1464                }
   1465                else
   1466                {
   1467                  mOperationCompleted = TRUE;   
   \                     ??ProcessOperation_18:
   \   00000234   4548               LDR      R0,??ProcessOperation_5
   \   00000236   0121               MOVS     R1,#+1
   \   00000238   0170               STRB     R1,[R0, #+0]
   1468                  mIsLcdInitialized   = TRUE;
   \   0000023A   ....               LDR      R0,??DataTable15_3
   \   0000023C   0121               MOVS     R1,#+1
   \   0000023E   0170               STRB     R1,[R0, #+0]
   \   00000240   ABE0               B        ??ProcessOperation_11
   1469                }
   1470                break; 
   1471                
   1472              case gLCD_ClearLineOp_c:      
   1473                if(mOperationCompleted)
   \                     ??ProcessOperation_1:
   \   00000242   4248               LDR      R0,??ProcessOperation_5
   \   00000244   0078               LDRB     R0,[R0, #+0]
   \   00000246   0028               CMP      R0,#+0
   \   00000248   02D0               BEQ      ??ProcessOperation_20
   1474                {
   1475                  /* start the operation */
   1476                  mOperationCompleted               = FALSE;
   \   0000024A   4048               LDR      R0,??ProcessOperation_5
   \   0000024C   0021               MOVS     R1,#+0
   \   0000024E   0170               STRB     R1,[R0, #+0]
   1477                }
   1478                /* check if the operation is finished */
   1479                if(TRUE == LCD_ClearLine(operationAndLine.lineQueue))
   \                     ??ProcessOperation_20:
   \   00000250   02A8               ADD      R0,SP,#+8
   \   00000252   4078               LDRB     R0,[R0, #+1]
   \   00000254   ........           BL       LCD_ClearLine
   \   00000258   0128               CMP      R0,#+1
   \   0000025A   00D0               BEQ      .+4
   \   0000025C   9DE0               B        ??ProcessOperation_11
   1480                {
   1481                  /* mark line as cleared */
   1482                  mDisplayParams.writtenLines &= ~(1 << operationAndLine.lineQueue);
   \   0000025E   3C48               LDR      R0,??ProcessOperation_5+0x4
   \   00000260   C078               LDRB     R0,[R0, #+3]
   \   00000262   0121               MOVS     R1,#+1
   \   00000264   02AA               ADD      R2,SP,#+8
   \   00000266   5278               LDRB     R2,[R2, #+1]
   \   00000268   9140               LSLS     R1,R1,R2
   \   0000026A   8843               BICS     R0,R0,R1
   \   0000026C   3849               LDR      R1,??ProcessOperation_5+0x4
   \   0000026E   C870               STRB     R0,[R1, #+3]
   1483                  /* stop the operation */ 
   1484                  mOperationCompleted = TRUE;          
   \   00000270   3648               LDR      R0,??ProcessOperation_5
   \   00000272   0121               MOVS     R1,#+1
   \   00000274   0170               STRB     R1,[R0, #+0]
   \   00000276   90E0               B        ??ProcessOperation_11
   1485                }
   1486                break;
   1487                
   1488              case gLCD_WriteBitmapOp_c:  
   1489                if(mOperationCompleted)
   \                     ??ProcessOperation_3:
   \   00000278   3448               LDR      R0,??ProcessOperation_5
   \   0000027A   0078               LDRB     R0,[R0, #+0]
   \   0000027C   0028               CMP      R0,#+0
   \   0000027E   1BD0               BEQ      ??ProcessOperation_21
   1490                {
   1491                  line = operationAndLine.lineQueue;
   \   00000280   02A8               ADD      R0,SP,#+8
   \   00000282   4078               LDRB     R0,[R0, #+1]
   \   00000284   0500               MOVS     R5,R0
   1492                  /* initialize the start coordinates for the string to be written */ 
   1493                  mDisplayParams.currentLine = line;
   \   00000286   3248               LDR      R0,??ProcessOperation_5+0x4
   \   00000288   8570               STRB     R5,[R0, #+2]
   1494                  mDisplayParams.currentXCoord = mLineParams[line].xCoord;;  
   \   0000028A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000028C   2D0E               LSRS     R5,R5,#+24
   \   0000028E   0320               MOVS     R0,#+3
   \   00000290   6843               MULS     R0,R5,R0
   \   00000292   4349               LDR      R1,??ProcessOperation_7
   \   00000294   085C               LDRB     R0,[R1, R0]
   \   00000296   2E49               LDR      R1,??ProcessOperation_5+0x4
   \   00000298   0870               STRB     R0,[R1, #+0]
   1495                  mDisplayParams.currentYCoord = mLineParams[line].yCoord; 
   \   0000029A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000029C   2D0E               LSRS     R5,R5,#+24
   \   0000029E   0320               MOVS     R0,#+3
   \   000002A0   6843               MULS     R0,R5,R0
   \   000002A2   3F49               LDR      R1,??ProcessOperation_7
   \   000002A4   0818               ADDS     R0,R1,R0
   \   000002A6   4078               LDRB     R0,[R0, #+1]
   \   000002A8   2949               LDR      R1,??ProcessOperation_5+0x4
   \   000002AA   4870               STRB     R0,[R1, #+1]
   1496                  mDisplayParams.currentStringIndex = 0;
   \   000002AC   2848               LDR      R0,??ProcessOperation_5+0x4
   \   000002AE   0021               MOVS     R1,#+0
   \   000002B0   8173               STRB     R1,[R0, #+14]
   1497                  mOperationCompleted               = FALSE;  
   \   000002B2   2648               LDR      R0,??ProcessOperation_5
   \   000002B4   0021               MOVS     R1,#+0
   \   000002B6   0170               STRB     R1,[R0, #+0]
   1498                }      
   1499                /* display only mNumberOfCharToWrite_c characters once because of time constraints */
   1500                for(i = 0; ((i < mNumberOfCharToWrite_c)&&(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)); i++)
   \                     ??ProcessOperation_21:
   \   000002B8   0020               MOVS     R0,#+0
   \   000002BA   0400               MOVS     R4,R0
   \                     ??ProcessOperation_22:
   \   000002BC   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   000002BE   240E               LSRS     R4,R4,#+24
   \   000002C0   032C               CMP      R4,#+3
   \   000002C2   38D2               BCS      ??ProcessOperation_23
   \   000002C4   2248               LDR      R0,??ProcessOperation_5+0x4
   \   000002C6   807B               LDRB     R0,[R0, #+14]
   \   000002C8   1028               CMP      R0,#+16
   \   000002CA   34D2               BCS      ??ProcessOperation_23
   1501                {
   1502                  /* display the character at the currentStringIndex in the currentBitmap */
   1503                  /* in case space must be inserted, use mBitmapSpace as bitmap and 0 as index */
   1504                  if(mDisplayParams.currentBitmap[mDisplayParams.currentLine][mDisplayParams.currentStringIndex] != 0xFF)
   \   000002CC   2048               LDR      R0,??ProcessOperation_5+0x4
   \   000002CE   807B               LDRB     R0,[R0, #+14]
   \   000002D0   1F49               LDR      R1,??ProcessOperation_5+0x4
   \   000002D2   8978               LDRB     R1,[R1, #+2]
   \   000002D4   1022               MOVS     R2,#+16
   \   000002D6   5143               MULS     R1,R2,R1
   \   000002D8   1D4A               LDR      R2,??ProcessOperation_5+0x4
   \   000002DA   5118               ADDS     R1,R2,R1
   \   000002DC   0818               ADDS     R0,R1,R0
   \   000002DE   8F30               ADDS     R0,R0,#+143
   \   000002E0   0078               LDRB     R0,[R0, #+0]
   \   000002E2   FF28               CMP      R0,#+255
   \   000002E4   13D0               BEQ      ??ProcessOperation_24
   1505                  {
   1506                    LCD_WriteSymbol(mDisplayParams.currentBitmap[mDisplayParams.currentLine][mDisplayParams.currentStringIndex], 
   1507                                    mDisplayParams.currentXCoord, 
   1508                                    mDisplayParams.currentYCoord,
   1509                                    mReceivedBitmap); 
   \   000002E6   ....               LDR      R0,??DataTable18
   \   000002E8   0368               LDR      R3,[R0, #+0]
   \   000002EA   1948               LDR      R0,??ProcessOperation_5+0x4
   \   000002EC   4278               LDRB     R2,[R0, #+1]
   \   000002EE   1848               LDR      R0,??ProcessOperation_5+0x4
   \   000002F0   0178               LDRB     R1,[R0, #+0]
   \   000002F2   1748               LDR      R0,??ProcessOperation_5+0x4
   \   000002F4   807B               LDRB     R0,[R0, #+14]
   \   000002F6   164E               LDR      R6,??ProcessOperation_5+0x4
   \   000002F8   B678               LDRB     R6,[R6, #+2]
   \   000002FA   1027               MOVS     R7,#+16
   \   000002FC   7E43               MULS     R6,R7,R6
   \   000002FE   144F               LDR      R7,??ProcessOperation_5+0x4
   \   00000300   BE19               ADDS     R6,R7,R6
   \   00000302   3018               ADDS     R0,R6,R0
   \   00000304   8F30               ADDS     R0,R0,#+143
   \   00000306   0078               LDRB     R0,[R0, #+0]
   \   00000308   ........           BL       LCD_WriteSymbol
   \   0000030C   07E0               B        ??ProcessOperation_25
   1510                  }
   1511                  else
   1512                  {
   1513                    LCD_WriteSymbol(0x00, 
   1514                                    mDisplayParams.currentXCoord, 
   1515                                    mDisplayParams.currentYCoord,
   1516                                    mBitmapSpace); 
   \                     ??ProcessOperation_24:
   \   0000030E   ....               LDR      R3,??DataTable19
   \   00000310   0F48               LDR      R0,??ProcessOperation_5+0x4
   \   00000312   4278               LDRB     R2,[R0, #+1]
   \   00000314   0E48               LDR      R0,??ProcessOperation_5+0x4
   \   00000316   0178               LDRB     R1,[R0, #+0]
   \   00000318   0020               MOVS     R0,#+0
   \   0000031A   ........           BL       LCD_WriteSymbol
   1517                  }          
   1518                  /* compute X coordinate for the next character */
   1519                  mDisplayParams.currentXCoord += (mSymbolWidth);
   \                     ??ProcessOperation_25:
   \   0000031E   0C48               LDR      R0,??ProcessOperation_5+0x4
   \   00000320   0078               LDRB     R0,[R0, #+0]
   \   00000322   0830               ADDS     R0,R0,#+8
   \   00000324   0A49               LDR      R1,??ProcessOperation_5+0x4
   \   00000326   0870               STRB     R0,[R1, #+0]
   1520                  mDisplayParams.currentStringIndex++;  
   \   00000328   0948               LDR      R0,??ProcessOperation_5+0x4
   \   0000032A   807B               LDRB     R0,[R0, #+14]
   \   0000032C   401C               ADDS     R0,R0,#+1
   \   0000032E   0849               LDR      R1,??ProcessOperation_5+0x4
   \   00000330   8873               STRB     R0,[R1, #+14]
   1521                }
   \   00000332   641C               ADDS     R4,R4,#+1
   \   00000334   C2E7               B        ??ProcessOperation_22
   1522                  
   1523                /* have we displayed the last character from the buffer? */
   1524                if(mDisplayParams.currentStringIndex < gMAX_LCD_CHARS_c)
   \                     ??ProcessOperation_23:
   \   00000336   0648               LDR      R0,??ProcessOperation_5+0x4
   \   00000338   807B               LDRB     R0,[R0, #+14]
   \   0000033A   1028               CMP      R0,#+16
   \   0000033C   0AD2               BCS      ??ProcessOperation_26
   1525                {
   1526                  TS_SendEvent(gLCDTaskID, gLCDOpEvt_c);
   \   0000033E   0121               MOVS     R1,#+1
   \   00000340   ....               LDR      R0,??DataTable15_1
   \   00000342   0078               LDRB     R0,[R0, #+0]
   \   00000344   ........           BL       TS_SendEvent
   \   00000348   27E0               B        ??ProcessOperation_11
   \   0000034A   C046               Nop      
   \                     ??ProcessOperation_5:
   \   0000034C   ........           DC32     mOperationCompleted
   \   00000350   ........           DC32     mDisplayParams
   1527                }
   1528                else
   1529                { /* reset display parameters */      
   1530                  mDisplayParams.linesWidthWritten[mDisplayParams.currentLine] = mDisplayParams.currentXCoord;
   \                     ??ProcessOperation_26:
   \   00000354   ....               LDR      R0,??DataTable20
   \   00000356   8078               LDRB     R0,[R0, #+2]
   \   00000358   ....               LDR      R1,??DataTable20
   \   0000035A   0818               ADDS     R0,R1,R0
   \   0000035C   ....               LDR      R1,??DataTable20
   \   0000035E   0978               LDRB     R1,[R1, #+0]
   \   00000360   4171               STRB     R1,[R0, #+5]
   1531                  mDisplayParams.currentStringIndex = 0;       
   \   00000362   ....               LDR      R0,??DataTable20
   \   00000364   0021               MOVS     R1,#+0
   \   00000366   8173               STRB     R1,[R0, #+14]
   1532                  /* clear the bitmask bit from linesToWrite because line was written  */
   1533                  mDisplayParams.linesToWrite &=(~(1<<mDisplayParams.currentLine));
   \   00000368   ....               LDR      R0,??DataTable20
   \   0000036A   0079               LDRB     R0,[R0, #+4]
   \   0000036C   0121               MOVS     R1,#+1
   \   0000036E   ....               LDR      R2,??DataTable20
   \   00000370   9278               LDRB     R2,[R2, #+2]
   \   00000372   9140               LSLS     R1,R1,R2
   \   00000374   8843               BICS     R0,R0,R1
   \   00000376   ....               LDR      R1,??DataTable20
   \   00000378   0871               STRB     R0,[R1, #+4]
   1534                  /* mark line as written */
   1535                  mDisplayParams.writtenLines |= (1<<mDisplayParams.currentLine);        
   \   0000037A   ....               LDR      R0,??DataTable20
   \   0000037C   C078               LDRB     R0,[R0, #+3]
   \   0000037E   0121               MOVS     R1,#+1
   \   00000380   ....               LDR      R2,??DataTable20
   \   00000382   9278               LDRB     R2,[R2, #+2]
   \   00000384   9140               LSLS     R1,R1,R2
   \   00000386   0143               ORRS     R1,R1,R0
   \   00000388   ....               LDR      R0,??DataTable20
   \   0000038A   C170               STRB     R1,[R0, #+3]
   1536                  mDisplayParams.currentLine        = mMaxLineNumber_c;
   \   0000038C   ....               LDR      R0,??DataTable20
   \   0000038E   0821               MOVS     R1,#+8
   \   00000390   8170               STRB     R1,[R0, #+2]
   1537                  mOperationCompleted               = TRUE;        
   \   00000392   ....               LDR      R0,??DataTable20_1
   \   00000394   0121               MOVS     R1,#+1
   \   00000396   0170               STRB     R1,[R0, #+0]
   \   00000398   FFE7               B        ??ProcessOperation_11
   1538                }          
   1539                break;
   1540          
   1541              default: 
   1542                break;    
   1543            }    
   1544          }
   \                     ??ProcessOperation_4:
   \                     ??ProcessOperation_11:
   \   0000039A   F7BC               POP      {R0-R2,R4-R7}
   \   0000039C   08BC               POP      {R3}
   \   0000039E   1847               BX       R3               ;; return
   \                     ??ProcessOperation_7:
   \   000003A0   ........           DC32     mLineParams

   \                                 In section .bss, align 1
   \                     ??linesToClear:
   \   00000000                      DS8 1
   1545          
   1546          /******************************************************************************
   1547          * This function sets a certain value to the LCD DATA pins
   1548          *
   1549          * Interface assumptions:
   1550          *
   1551          *
   1552          * Return value:
   1553          * None
   1554          *
   1555          *
   1556          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1557          static void SendData(uint8_t data)
   1558          {
   \                     SendData:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1559          #if gLCDGpioPinMode_c
   1560              /* bit |7|6|5|4|3|2|1|0| */
   1561              (void)Gpio_SetPinData(LCD_D0, (data & 0x01)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1562              (void)Gpio_SetPinData(LCD_D1, (data & 0x02)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1563              (void)Gpio_SetPinData(LCD_D2, (data & 0x04)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1564              (void)Gpio_SetPinData(LCD_D3, (data & 0x08)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1565              (void)Gpio_SetPinData(LCD_D4, (data & 0x10)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1566              (void)Gpio_SetPinData(LCD_D5, (data & 0x20)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1567              (void)Gpio_SetPinData(LCD_D6, (data & 0x40)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1568              (void)Gpio_SetPinData(LCD_D7, (data & 0x80)? gGpioPinStateHigh_c : gGpioPinStateLow_c);
   1569          #else /* gLCDGpioPinMode_c */    
   1570              Gpio_SetPortData(LCD_DATA_LO_PORT, LCD_DATA_LO_WRITE(data), LCD_DATA_LO_MASK); 
   \   00000004   F022               MOVS     R2,#+240
   \   00000006   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000008   240E               LSRS     R4,R4,#+24
   \   0000000A   2101               LSLS     R1,R4,#+4
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ........           BL       Gpio_SetPortData
   1571              Gpio_SetPortData(LCD_DATA_HI_PORT, LCD_DATA_HI_WRITE(data), LCD_DATA_HI_MASK);
   \   00000012   0F22               MOVS     R2,#+15
   \   00000014   2100               MOVS     R1,R4
   \   00000016   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000018   090E               LSRS     R1,R1,#+24
   \   0000001A   0909               LSRS     R1,R1,#+4
   \   0000001C   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000001E   090E               LSRS     R1,R1,#+24
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   ........           BL       Gpio_SetPortData
   1572              
   1573          #endif /* gLCDGpioPinMode_c */     
   1574          }
   \   00000026   10BC               POP      {R4}
   \   00000028   08BC               POP      {R3}
   \   0000002A   1847               BX       R3               ;; return
   1575          
   1576          /******************************************************************************
   1577          * This function sets the LCD DATA pins as inputs
   1578          *
   1579          * Interface assumptions:
   1580          *
   1581          *
   1582          * Return value:
   1583          * None
   1584          *
   1585          *
   1586          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1587          static void SetHiZ(void)
   1588          {
   \                     SetHiZ:
   \   00000000   80B5               PUSH     {R7,LR}
   1589              /* change data pins direction back to input */
   1590          #if gLCDGpioPinMode_c
   1591              (void)Gpio_SetPinDir(LCD_D0,      gGpioDirIn_c);
   1592              (void)Gpio_SetPinDir(LCD_D1,      gGpioDirIn_c);
   1593              (void)Gpio_SetPinDir(LCD_D2,      gGpioDirIn_c);
   1594              (void)Gpio_SetPinDir(LCD_D3,      gGpioDirIn_c);
   1595              (void)Gpio_SetPinDir(LCD_D4,      gGpioDirIn_c);
   1596              (void)Gpio_SetPinDir(LCD_D5,      gGpioDirIn_c);
   1597              (void)Gpio_SetPinDir(LCD_D6,      gGpioDirIn_c);
   1598              (void)Gpio_SetPinDir(LCD_D7,      gGpioDirIn_c);
   1599          #else /* gLCDGpioPinMode_c */ 
   1600              Gpio_SetPortDir(LCD_DATA_LO_PORT, ~LCD_DATA_LO_MASK, LCD_DATA_LO_MASK); 
   \   00000002   F022               MOVS     R2,#+240
   \   00000004   F021               MOVS     R1,#+240
   \   00000006   C943               MVNS     R1,R1            ;; #-241
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   ........           BL       Gpio_SetPortDir
   1601              Gpio_SetPortDir(LCD_DATA_HI_PORT, ~LCD_DATA_HI_MASK, LCD_DATA_HI_MASK); 
   \   0000000E   0F22               MOVS     R2,#+15
   \   00000010   0F21               MOVS     R1,#+15
   \   00000012   C943               MVNS     R1,R1            ;; #-16
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   ........           BL       Gpio_SetPortDir
   1602              
   1603          #endif /* gLCDGpioPinMode_c */
   1604          
   1605          }
   \   0000001A   09BC               POP      {R0,R3}
   \   0000001C   1847               BX       R3               ;; return
   1606          
   1607          /******************************************************************************
   1608          * This function sets the LCD DATA pins as outputs
   1609          *
   1610          * Interface assumptions:
   1611          *
   1612          *
   1613          * Return value:
   1614          * None
   1615          *
   1616          *
   1617          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1618          static void SetOutput(void)
   1619          {
   \                     SetOutput:
   \   00000000   80B5               PUSH     {R7,LR}
   1620            /* change data pins direction to output */
   1621          #if gLCDGpioPinMode_c
   1622            (void)Gpio_SetPinDir(LCD_D0,      gGpioDirOut_c);
   1623            (void)Gpio_SetPinDir(LCD_D1,      gGpioDirOut_c);
   1624            (void)Gpio_SetPinDir(LCD_D2,      gGpioDirOut_c);
   1625            (void)Gpio_SetPinDir(LCD_D3,      gGpioDirOut_c);
   1626            (void)Gpio_SetPinDir(LCD_D4,      gGpioDirOut_c);
   1627            (void)Gpio_SetPinDir(LCD_D5,      gGpioDirOut_c);
   1628            (void)Gpio_SetPinDir(LCD_D6,      gGpioDirOut_c);
   1629            (void)Gpio_SetPinDir(LCD_D7,      gGpioDirOut_c);
   1630          #else /* gLCDGpioPinMode_c */
   1631             
   1632              Gpio_SetPortDir(LCD_DATA_LO_PORT, LCD_DATA_LO_MASK, LCD_DATA_LO_MASK);      
   \   00000002   F022               MOVS     R2,#+240
   \   00000004   F021               MOVS     R1,#+240
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   ........           BL       Gpio_SetPortDir
   1633              Gpio_SetPortDir(LCD_DATA_HI_PORT, LCD_DATA_HI_MASK, LCD_DATA_HI_MASK);         
   \   0000000C   0F22               MOVS     R2,#+15
   \   0000000E   0F21               MOVS     R1,#+15
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   ........           BL       Gpio_SetPortDir
   1634              
   1635          #endif /* gLCDGpioPinMode_c */
   1636          
   1637          }
   \   00000016   09BC               POP      {R0,R3}
   \   00000018   1847               BX       R3               ;; return
   1638          
   1639          /******************************************************************************
   1640          * This function initilizes the display for a data write (line, page, column)
   1641          *
   1642          * Interface assumptions:
   1643          *
   1644          *
   1645          * Return value:
   1646          * None
   1647          *
   1648          *
   1649          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1650          static void InitDisplayWrite(uint8_t xStartCoord, uint8_t yStartCoord)
   1651          {
   \                     InitDisplayWrite:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
   1652          
   1653            uint8_t page;  
   1654            
   1655            page = yStartCoord >> 3;
   \   00000006   2000               MOVS     R0,R4
   \   00000008   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000A   000E               LSRS     R0,R0,#+24
   \   0000000C   C008               LSRS     R0,R0,#+3
   \   0000000E   0600               MOVS     R6,R0
   1656          
   1657            LCD_WriteCommand(gLCDDisplayStartLineDefaultCommand_c);
   \   00000010   4020               MOVS     R0,#+64
   \   00000012   ........           BL       LCD_WriteCommand
   1658            LCD_WriteCommand(gLCDPageAddressDefaultCommand_c + page);
   \   00000016   3000               MOVS     R0,R6
   \   00000018   5038               SUBS     R0,R0,#+80
   \   0000001A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001C   000E               LSRS     R0,R0,#+24
   \   0000001E   ........           BL       LCD_WriteCommand
   1659            LCD_WriteCommand(gLCDNibble0ColumnAddressDefaultCommand_c | ((xStartCoord & 0xF0)>>4));
   \   00000022   2900               MOVS     R1,R5
   \   00000024   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000026   090E               LSRS     R1,R1,#+24
   \   00000028   0909               LSRS     R1,R1,#+4
   \   0000002A   1020               MOVS     R0,#+16
   \   0000002C   0843               ORRS     R0,R0,R1
   \   0000002E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000030   000E               LSRS     R0,R0,#+24
   \   00000032   ........           BL       LCD_WriteCommand
   1660            LCD_WriteCommand(gLCDNibble1ColumnAddressDefaultCommand_c | (xStartCoord & 0x0F));         
   \   00000036   2807               LSLS     R0,R5,#+28       ;; ZeroExtS R0,R5,#+28,#+28
   \   00000038   000F               LSRS     R0,R0,#+28
   \   0000003A   ........           BL       LCD_WriteCommand
   1661          }
   \   0000003E   70BC               POP      {R4-R6}
   \   00000040   08BC               POP      {R3}
   \   00000042   1847               BX       R3               ;; return
   1662          
   1663          /******************************************************************************
   1664          * This function reads the current location from display data RAM
   1665          *
   1666          * Interface assumptions:
   1667          *
   1668          *
   1669          * Return value:
   1670          * None
   1671          *
   1672          *
   1673          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1674          static uint8_t ReadData(void)
   1675          {
   \                     ReadData:
   \   00000000   10B5               PUSH     {R4,LR}
   1676            uint8_t ReturnValue;
   1677            Gpio_SetPinData(LCD_A0, LCD_A0_DATA);
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   1520               MOVS     R0,#+21
   \   00000006   ........           BL       Gpio_SetPinData
   1678            Gpio_SetPinData(LCD_CS, LCD_CS_ACTIVE);
   \   0000000A   0121               MOVS     R1,#+1
   \   0000000C   1420               MOVS     R0,#+20
   \   0000000E   ........           BL       Gpio_SetPinData
   1679            DelayUs(1);
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   ........           BL       DelayUs
   1680            Gpio_SetPinData(LCD_RD, LCD_RD_ACTIVE);
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   0820               MOVS     R0,#+8
   \   0000001C   ........           BL       Gpio_SetPinData
   1681            DelayUs(1);
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   ........           BL       DelayUs
   1682            ReturnValue = GetData();
   \   00000026   ........           BL       GetData
   \   0000002A   0400               MOVS     R4,R0
   1683            Gpio_SetPinData(LCD_RD, LCD_RD_INACTIVE);
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   0820               MOVS     R0,#+8
   \   00000030   ........           BL       Gpio_SetPinData
   1684            Gpio_SetPinData(LCD_CS, LCD_CS_INACTIVE);
   \   00000034   0021               MOVS     R1,#+0
   \   00000036   1420               MOVS     R0,#+20
   \   00000038   ........           BL       Gpio_SetPinData
   1685            DelayUs(1);
   \   0000003C   0120               MOVS     R0,#+1
   \   0000003E   ........           BL       DelayUs
   1686            return ReturnValue;
   \   00000042   2000               MOVS     R0,R4
   \   00000044   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000046   000E               LSRS     R0,R0,#+24
   \   00000048   10BC               POP      {R4}
   \   0000004A   08BC               POP      {R3}
   \   0000004C   1847               BX       R3               ;; return
   1687          }
   1688          
   1689          /******************************************************************************
   1690          * This function sets the data from the current RAM display location
   1691          * to LCD DATA pins
   1692          *
   1693          * Interface assumptions:
   1694          *
   1695          *
   1696          * Return value:
   1697          * unsigned 8 bit
   1698          *
   1699          *
   1700          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1701          static uint8_t GetData(void)
   1702          {
   \                     GetData:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1703              uint8_t        ReturnValue = 0;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
   1704          #if gLCDGpioPinMode_c
   1705              GpioPinState_t Bitdata;
   1706              /* bit |7|6|5|4|3|2|1|0| */
   1707              Gpio_GetPinData(LCD_D7, &Bitdata);
   1708              ReturnValue = (Bitdata)? (1<<7) : 0;
   1709              Gpio_GetPinData(LCD_D6, &Bitdata);
   1710              ReturnValue |= (Bitdata)? (1<<6) : 0;
   1711              Gpio_GetPinData(LCD_D5, &Bitdata);
   1712              ReturnValue |= (Bitdata)? (1<<5) : 0;
   1713              Gpio_GetPinData(LCD_D4, &Bitdata);
   1714              ReturnValue |= (Bitdata)? (1<<4) : 0;
   1715              Gpio_GetPinData(LCD_D3, &Bitdata);
   1716              ReturnValue |= (Bitdata)? (1<<3) : 0;
   1717              Gpio_GetPinData(LCD_D2, &Bitdata);
   1718              ReturnValue |= (Bitdata)? (1<<2) : 0;
   1719              Gpio_GetPinData(LCD_D1, &Bitdata);
   1720              ReturnValue |= (Bitdata)? (1<<1) : 0;
   1721              Gpio_GetPinData(LCD_D0, &Bitdata);
   1722              ReturnValue |= (Bitdata)? (1<<0) : 0;
   1723              
   1724          #else /* gLCDGpioPinMode_c */
   1725              uint32_t temp;
   1726              Gpio_GetPortData(LCD_DATA_LO_PORT, &temp);
   \   00000008   6946               MOV      R1,SP
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   ........           BL       Gpio_GetPortData
   1727              ReturnValue = LCD_DATA_LO_READ(LCD_DATA_LO_MASK & temp);
   \   00000010   0098               LDR      R0,[SP, #+0]
   \   00000012   0009               LSRS     R0,R0,#+4
   \   00000014   0007               LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000016   000F               LSRS     R0,R0,#+28
   \   00000018   0400               MOVS     R4,R0
   1728              Gpio_GetPortData(LCD_DATA_HI_PORT, &temp);
   \   0000001A   6946               MOV      R1,SP
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   ........           BL       Gpio_GetPortData
   1729              ReturnValue |= LCD_DATA_HI_READ(LCD_DATA_HI_MASK & temp);
   \   00000022   2100               MOVS     R1,R4
   \   00000024   0098               LDR      R0,[SP, #+0]
   \   00000026   0401               LSLS     R4,R0,#+4
   \   00000028   0C43               ORRS     R4,R4,R1
   1730          
   1731          #endif /* gLCDGpioPinMode_c */
   1732              
   1733              return ReturnValue;
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002E   000E               LSRS     R0,R0,#+24
   \   00000030   16BC               POP      {R1,R2,R4}
   \   00000032   08BC               POP      {R3}
   \   00000034   1847               BX       R3               ;; return
   1734          }
   1735          
   1736          /******************************************************************************
   1737          * This function gets the length of a string and return the length
   1738          *
   1739          * Interface assumptions:
   1740          *
   1741          *
   1742          * Return value:
   1743          * char
   1744          *
   1745          *
   1746          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1747          static uint8_t GetStrlen
   1748            (
   1749            const uint8_t *pString /* IN: Pointer to text string */
   1750            )
   1751          {
   \                     GetStrlen:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0100               MOVS     R1,R0
   1752            int8_t count=0, length=0;
   \   00000004   0023               MOVS     R3,#+0
   \   00000006   1A00               MOVS     R2,R3
   \   00000008   0023               MOVS     R3,#+0
   \   0000000A   1800               MOVS     R0,R3
   1753          
   1754            while (*pString != '\0' && count <gMAX_LCD_CHARS_c ) {
   \                     ??GetStrlen_0:
   \   0000000C   0B78               LDRB     R3,[R1, #+0]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   07D0               BEQ      ??GetStrlen_1
   \   00000012   1206               LSLS     R2,R2,#+24       ;; SignExtS R2,R2,#+24,#+24
   \   00000014   1216               ASRS     R2,R2,#+24
   \   00000016   102A               CMP      R2,#+16
   \   00000018   03DA               BGE      ??GetStrlen_1
   1755              count++;
   \   0000001A   521C               ADDS     R2,R2,#+1
   1756              length++;
   \   0000001C   401C               ADDS     R0,R0,#+1
   1757              pString++;
   \   0000001E   491C               ADDS     R1,R1,#+1
   \   00000020   F4E7               B        ??GetStrlen_0
   1758            }
   1759          
   1760            /* Check boundries */
   1761            if ( length > gMAX_LCD_CHARS_c ) {
   \                     ??GetStrlen_1:
   \   00000022   0006               LSLS     R0,R0,#+24       ;; SignExtS R0,R0,#+24,#+24
   \   00000024   0016               ASRS     R0,R0,#+24
   \   00000026   1128               CMP      R0,#+17
   \   00000028   01DB               BLT      ??GetStrlen_2
   1762              length = gMAX_LCD_CHARS_c;
   \   0000002A   1023               MOVS     R3,#+16
   \   0000002C   1800               MOVS     R0,R3
   1763            }
   1764          
   1765            return length;
   \                     ??GetStrlen_2:
   \   0000002E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000030   000E               LSRS     R0,R0,#+24
   \   00000032   08BC               POP      {R3}
   \   00000034   1847               BX       R3               ;; return
   1766          }
   1767          
   1768          /******************************************************************************
   1769          * This function initializes the operation queue
   1770          *
   1771          * Interface assumptions:
   1772          *
   1773          *
   1774          * Return value: NONE
   1775          *
   1776          *
   1777          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1778          static void InitQueue(void)
   1779          {
   \                     InitQueue:
   \   00000000   00B5               PUSH     {LR}
   1780            uint8_t i;
   1781            
   1782            mQueue.head = 0;
   \   00000002   ....               LDR      R1,??DataTable20_2
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0A70               STRB     R2,[R1, #+0]
   1783            mQueue.tail = 0;
   \   00000008   ....               LDR      R1,??DataTable20_2
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   4A70               STRB     R2,[R1, #+1]
   1784            for(i=0; i<mMaxQueueEntries_c; i++)
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   0800               MOVS     R0,R1
   \                     ??InitQueue_0:
   \   00000012   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000014   000E               LSRS     R0,R0,#+24
   \   00000016   2D28               CMP      R0,#+45
   \   00000018   11D2               BCS      ??InitQueue_1
   1785            {
   1786              mQueue.opLine[i].opQueue   = (operation_t)mEmptyQueue_c;    
   \   0000001A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001C   000E               LSRS     R0,R0,#+24
   \   0000001E   0221               MOVS     R1,#+2
   \   00000020   4143               MULS     R1,R0,R1
   \   00000022   ....               LDR      R2,??DataTable20_2
   \   00000024   5118               ADDS     R1,R2,R1
   \   00000026   FF22               MOVS     R2,#+255
   \   00000028   8A70               STRB     R2,[R1, #+2]
   1787              mQueue.opLine[i].lineQueue = mEmptyQueue_c;   
   \   0000002A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   \   0000002E   0221               MOVS     R1,#+2
   \   00000030   4143               MULS     R1,R0,R1
   \   00000032   ....               LDR      R2,??DataTable20_2
   \   00000034   5118               ADDS     R1,R2,R1
   \   00000036   FF22               MOVS     R2,#+255
   \   00000038   CA70               STRB     R2,[R1, #+3]
   1788            }
   \   0000003A   401C               ADDS     R0,R0,#+1
   \   0000003C   E9E7               B        ??InitQueue_0
   1789          }
   \                     ??InitQueue_1:
   \   0000003E   08BC               POP      {R3}
   \   00000040   1847               BX       R3               ;; return
   1790          
   1791          /******************************************************************************
   1792          * This function adds an element to the queue
   1793          *
   1794          * Interface assumptions:
   1795          *
   1796          *
   1797          * Return value:
   1798          *  TRUE  - if the operation was successuful
   1799          *  FALSE - if the queue is full and the element could not be added   
   1800          *
   1801          *
   1802          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1803          static bool_t AddToQueue(opLine_t operationLine)
   1804          {
   \                     AddToQueue:
   \   00000000   01B5               PUSH     {R0,LR}
   1805            if(!IsQueueFull())
   \   00000002   ........           BL       IsQueueFull
   \   00000006   0028               CMP      R0,#+0
   \   00000008   1FD1               BNE      ??AddToQueue_0
   1806            { 
   1807              mQueue.opLine[mQueue.tail].opQueue   = operationLine.opQueue;   
   \   0000000A   ....               LDR      R0,??DataTable20_2
   \   0000000C   4078               LDRB     R0,[R0, #+1]
   \   0000000E   0221               MOVS     R1,#+2
   \   00000010   4843               MULS     R0,R1,R0
   \   00000012   ....               LDR      R1,??DataTable20_2
   \   00000014   0818               ADDS     R0,R1,R0
   \   00000016   6946               MOV      R1,SP
   \   00000018   0978               LDRB     R1,[R1, #+0]
   \   0000001A   8170               STRB     R1,[R0, #+2]
   1808              mQueue.opLine[mQueue.tail].lineQueue = operationLine.lineQueue;   
   \   0000001C   ....               LDR      R0,??DataTable20_2
   \   0000001E   4078               LDRB     R0,[R0, #+1]
   \   00000020   0221               MOVS     R1,#+2
   \   00000022   4843               MULS     R0,R1,R0
   \   00000024   ....               LDR      R1,??DataTable20_2
   \   00000026   0818               ADDS     R0,R1,R0
   \   00000028   6946               MOV      R1,SP
   \   0000002A   4978               LDRB     R1,[R1, #+1]
   \   0000002C   C170               STRB     R1,[R0, #+3]
   1809              if(++mQueue.tail == mMaxQueueEntries_c)
   \   0000002E   ....               LDR      R0,??DataTable20_2
   \   00000030   4078               LDRB     R0,[R0, #+1]
   \   00000032   401C               ADDS     R0,R0,#+1
   \   00000034   ....               LDR      R1,??DataTable20_2
   \   00000036   4870               STRB     R0,[R1, #+1]
   \   00000038   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000003A   000E               LSRS     R0,R0,#+24
   \   0000003C   2D28               CMP      R0,#+45
   \   0000003E   02D1               BNE      ??AddToQueue_1
   1810              {
   1811                mQueue.tail = 0;      
   \   00000040   ....               LDR      R0,??DataTable20_2
   \   00000042   0021               MOVS     R1,#+0
   \   00000044   4170               STRB     R1,[R0, #+1]
   1812              }
   1813              return TRUE;
   \                     ??AddToQueue_1:
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   00E0               B        ??AddToQueue_2
   1814            }
   1815            else
   1816            {
   1817              return FALSE;    
   \                     ??AddToQueue_0:
   \   0000004A   0020               MOVS     R0,#+0
   \                     ??AddToQueue_2:
   \   0000004C   0ABC               POP      {R1,R3}
   \   0000004E   1847               BX       R3               ;; return
   1818            }  
   1819          }  
   1820          
   1821          /******************************************************************************
   1822          * This function removes an element from the queue
   1823          *
   1824          * Interface assumptions:
   1825          *
   1826          *
   1827          * Return value:
   1828          *  value from the queue  - if the operation was successuful
   1829          *  mEmptyQueue_c, mEmptyQueue_c - if the queue is empty and the element could not be removed   
   1830          *
   1831          *
   1832          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1833          static opLine_t RemoveFromQueue(void)
   1834          {
   \                     RemoveFromQueue:
   \   00000000   80B5               PUSH     {R7,LR}
   1835            opLine_t returnValue = {(operation_t)mEmptyQueue_c, mEmptyQueue_c};
   \   00000002   ....               LDR      R0,??DataTable20_3
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0090               STR      R0,[SP, #+0]
   1836            if(!IsQueueEmpty())
   \   00000008   ........           BL       IsQueueEmpty
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   2DD1               BNE      ??RemoveFromQueue_0
   1837            {
   1838              returnValue.opQueue   = mQueue.opLine[mQueue.head].opQueue;
   \   00000010   6846               MOV      R0,SP
   \   00000012   ....               LDR      R1,??DataTable20_2
   \   00000014   0978               LDRB     R1,[R1, #+0]
   \   00000016   0222               MOVS     R2,#+2
   \   00000018   5143               MULS     R1,R2,R1
   \   0000001A   ....               LDR      R2,??DataTable20_2
   \   0000001C   5118               ADDS     R1,R2,R1
   \   0000001E   8978               LDRB     R1,[R1, #+2]
   \   00000020   0170               STRB     R1,[R0, #+0]
   1839              returnValue.lineQueue = mQueue.opLine[mQueue.head].lineQueue;
   \   00000022   ....               LDR      R0,??DataTable20_2
   \   00000024   0078               LDRB     R0,[R0, #+0]
   \   00000026   0221               MOVS     R1,#+2
   \   00000028   4843               MULS     R0,R1,R0
   \   0000002A   ....               LDR      R1,??DataTable20_2
   \   0000002C   0818               ADDS     R0,R1,R0
   \   0000002E   C078               LDRB     R0,[R0, #+3]
   \   00000030   6946               MOV      R1,SP
   \   00000032   4870               STRB     R0,[R1, #+1]
   1840              mQueue.opLine[mQueue.head].opQueue   = (operation_t)mEmptyQueue_c;
   \   00000034   ....               LDR      R0,??DataTable20_2
   \   00000036   0078               LDRB     R0,[R0, #+0]
   \   00000038   0221               MOVS     R1,#+2
   \   0000003A   4843               MULS     R0,R1,R0
   \   0000003C   ....               LDR      R1,??DataTable20_2
   \   0000003E   0818               ADDS     R0,R1,R0
   \   00000040   FF21               MOVS     R1,#+255
   \   00000042   8170               STRB     R1,[R0, #+2]
   1841              mQueue.opLine[mQueue.head].lineQueue = mEmptyQueue_c;
   \   00000044   ....               LDR      R0,??DataTable20_2
   \   00000046   0078               LDRB     R0,[R0, #+0]
   \   00000048   0221               MOVS     R1,#+2
   \   0000004A   4843               MULS     R0,R1,R0
   \   0000004C   ....               LDR      R1,??DataTable20_2
   \   0000004E   0818               ADDS     R0,R1,R0
   \   00000050   FF21               MOVS     R1,#+255
   \   00000052   C170               STRB     R1,[R0, #+3]
   1842              if(++mQueue.head == mMaxQueueEntries_c)
   \   00000054   ....               LDR      R0,??DataTable20_2
   \   00000056   0078               LDRB     R0,[R0, #+0]
   \   00000058   401C               ADDS     R0,R0,#+1
   \   0000005A   ....               LDR      R1,??DataTable20_2
   \   0000005C   0870               STRB     R0,[R1, #+0]
   \   0000005E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000060   000E               LSRS     R0,R0,#+24
   \   00000062   2D28               CMP      R0,#+45
   \   00000064   02D1               BNE      ??RemoveFromQueue_0
   1843              {
   1844                mQueue.head = 0;      
   \   00000066   ....               LDR      R0,??DataTable20_2
   \   00000068   0021               MOVS     R1,#+0
   \   0000006A   0170               STRB     R1,[R0, #+0]
   1845              }    
   1846            }
   1847            return  returnValue;
   \                     ??RemoveFromQueue_0:
   \   0000006C   0098               LDR      R0,[SP, #+0]
   \   0000006E   0ABC               POP      {R1,R3}
   \   00000070   1847               BX       R3               ;; return
   1848          }  
   1849          
   1850          /******************************************************************************
   1851          * This function checks if the mQueue queue is empty
   1852          *
   1853          * Interface assumptions:
   1854          *
   1855          *
   1856          * Return value:
   1857          *  TRUE  - if the queue is empty
   1858          *  FALSE - otherwise   
   1859          *
   1860          *
   1861          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1862          static bool_t IsQueueEmpty(void)
   1863          {
   \                     IsQueueEmpty:
   \   00000000   00B5               PUSH     {LR}
   1864            if((mQueue.head == mQueue.tail)&&
   1865               (mQueue.opLine[mQueue.head].opQueue   == mEmptyQueue_c)&&
   1866               (mQueue.opLine[mQueue.head].lineQueue == mEmptyQueue_c))
   \   00000002   ....               LDR      R0,??DataTable20_2
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   ....               LDR      R1,??DataTable20_2
   \   00000008   4978               LDRB     R1,[R1, #+1]
   \   0000000A   8842               CMP      R0,R1
   \   0000000C   13D1               BNE      ??IsQueueEmpty_0
   \   0000000E   ....               LDR      R0,??DataTable20_2
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   0221               MOVS     R1,#+2
   \   00000014   4843               MULS     R0,R1,R0
   \   00000016   ....               LDR      R1,??DataTable20_2
   \   00000018   0818               ADDS     R0,R1,R0
   \   0000001A   8078               LDRB     R0,[R0, #+2]
   \   0000001C   FF28               CMP      R0,#+255
   \   0000001E   0AD1               BNE      ??IsQueueEmpty_0
   \   00000020   ....               LDR      R0,??DataTable20_2
   \   00000022   0078               LDRB     R0,[R0, #+0]
   \   00000024   0221               MOVS     R1,#+2
   \   00000026   4843               MULS     R0,R1,R0
   \   00000028   ....               LDR      R1,??DataTable20_2
   \   0000002A   0818               ADDS     R0,R1,R0
   \   0000002C   C078               LDRB     R0,[R0, #+3]
   \   0000002E   FF28               CMP      R0,#+255
   \   00000030   01D1               BNE      ??IsQueueEmpty_0
   1867            {
   1868              return TRUE;      
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   00E0               B        ??IsQueueEmpty_1
   1869            }
   1870            else
   1871            {
   1872              return FALSE;
   \                     ??IsQueueEmpty_0:
   \   00000036   0020               MOVS     R0,#+0
   \                     ??IsQueueEmpty_1:
   \   00000038   08BC               POP      {R3}
   \   0000003A   1847               BX       R3               ;; return
   1873            }  
   1874          }  
   1875          
   1876          /******************************************************************************
   1877          * This function checks if the mQueue queue is full
   1878          *
   1879          * Interface assumptions:
   1880          *
   1881          *
   1882          * Return value:
   1883          *  TRUE  - if the queue is full
   1884          *  FALSE - otherwise   
   1885          *
   1886          *
   1887          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1888          static bool_t IsQueueFull(void)
   1889          {
   \                     IsQueueFull:
   \   00000000   00B5               PUSH     {LR}
   1890            if((mQueue.head == mQueue.tail)&&
   1891               (mQueue.opLine[mQueue.head].opQueue   != mEmptyQueue_c)&&
   1892               (mQueue.opLine[mQueue.head].lineQueue != mEmptyQueue_c))
   \   00000002   ....               LDR      R0,??DataTable20_2
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   ....               LDR      R1,??DataTable20_2
   \   00000008   4978               LDRB     R1,[R1, #+1]
   \   0000000A   8842               CMP      R0,R1
   \   0000000C   13D1               BNE      ??IsQueueFull_0
   \   0000000E   ....               LDR      R0,??DataTable20_2
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   0221               MOVS     R1,#+2
   \   00000014   4843               MULS     R0,R1,R0
   \   00000016   ....               LDR      R1,??DataTable20_2
   \   00000018   0818               ADDS     R0,R1,R0
   \   0000001A   8078               LDRB     R0,[R0, #+2]
   \   0000001C   FF28               CMP      R0,#+255
   \   0000001E   0AD0               BEQ      ??IsQueueFull_0
   \   00000020   ....               LDR      R0,??DataTable20_2
   \   00000022   0078               LDRB     R0,[R0, #+0]
   \   00000024   0221               MOVS     R1,#+2
   \   00000026   4843               MULS     R0,R1,R0
   \   00000028   ....               LDR      R1,??DataTable20_2
   \   0000002A   0818               ADDS     R0,R1,R0
   \   0000002C   C078               LDRB     R0,[R0, #+3]
   \   0000002E   FF28               CMP      R0,#+255
   \   00000030   01D0               BEQ      ??IsQueueFull_0
   1893            {
   1894              return TRUE;   
   \   00000032   0120               MOVS     R0,#+1
   \   00000034   00E0               B        ??IsQueueFull_1
   1895            }
   1896            else
   1897            {
   1898              return FALSE;
   \                     ??IsQueueFull_0:
   \   00000036   0020               MOVS     R0,#+0
   \                     ??IsQueueFull_1:
   \   00000038   08BC               POP      {R3}
   \   0000003A   1847               BX       R3               ;; return
   1899            }  
   1900          }  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     mIsLcdInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     gLCDTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     `?<Constant "Wrong line">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     aLCDFont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     `?<Constant "Wrong line">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   ........           DC32     mReceivedBitmap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   10270000           DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0F270000           DC32     0x270f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     gaHexValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     `?<Constant "Format unknow">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     `?<Constant {83, 105, 122, 101, 32, 78, 111, 11`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   ........           DC32     mErrorIndicator

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   ........           DC32     mOperationCompleted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   ........           DC32     ??mOperationLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   ........           DC32     gLCDTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   ........           DC32     LCD_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   ........           DC32     aLCDFont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   ........           DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   ........           DC32     ??isPageDeleted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   ........           DC32     mLineParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   ........           DC32     ??pageToDelete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   ........           DC32     gLCDTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     aLCDFont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   ........           DC32     gLCDTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   ........           DC32     ??linesToClear

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   ........           DC32     mIsLcdInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   ........           DC32     mReceivedBitmap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   ........           DC32     mBitmapSpace

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     mDisplayParams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   ........           DC32     mOperationCompleted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   ........           DC32     mQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   ........           DC32     `?<Constant {255, 255}>`

   \                                 In section .rodata, align 4
   \                     `?<Constant "Wrong line">`:
   \   00000000   57726F6E6720       DC8 "Wrong line"
   \              6C696E6500  
   \   0000000B   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Wrong line">_1`:
   \   00000000   57726F6E6720       DC8 "Wrong line"
   \              6C696E6500  
   \   0000000B   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Format unknow">`:
   \   00000000   466F726D6174       DC8 "Format unknow"
   \              20756E6B6E6F
   \              7700        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {83, 105, 122, 101, 32, 78, 111, 11`:
   \   00000000   53697A65204E       DC8 83, 105, 122, 101, 32, 78, 111, 116, 32, 86, 97, 108, 105, 100, 42
   \              6F742056616C
   \              69642A      
   \   0000000F   2A                 DC8 42

   \                                 In section .rodata, align 4
   \                     `?<Constant {255, 255}>`:
   \   00000000   FFFF0000           DC8 255, 255, 0, 0
   1901          
   1902          #endif /* (gLCDSupported_d == 1) */

   Maximum stack usage in bytes:

     Function             .cstack
     --------             -------
     AddToQueue                8
     GetData                  16
     GetStrlen                 4
     InitDisplayWrite         16
     InitQueue                 4
     IsQueueEmpty              4
     IsQueueFull               4
     LCD_CheckError            0
     LCD_ClearDisplay          8
     LCD_ClearLine             8
     LCD_ClearPage            24
     LCD_Init                  8
     LCD_SetBacklight         16
     LCD_SetFont               4
     LCD_Task                 16
     LCD_TaskInit              8
     LCD_WriteBitmap          48
     LCD_WriteBytes           80
     LCD_WriteCharacter       32
     LCD_WriteCommand          8
     LCD_WriteData             8
     LCD_WritePixel           24
     LCD_WriteString          48
     LCD_WriteStringValue     80
     LCD_WriteSymbol          24
     ProcessOperation         32
     ReadData                  8
     RemoveFromQueue           8
     SendData                  8
     SetHiZ                    8
     SetOutput                 8


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     mDisplayParams                                  272
     mLineParams                                      24
     mOperationCompleted                               1
     mQueue                                           92
     mIsLcdInitialized                                 1
     mErrorIndicator                                   1
     mReceivedBitmap                                   4
     mBitmapSpace                                      8
     gLCDTaskID                                        1
     gaHexValue                                       20
     aLCDFont                                         24
     LCD_Init                                        504
     LCD_ClearDisplay                                 52
     LCD_WriteString                                 484
     LCD_WriteBitmap                                 268
     LCD_WriteStringValue                            632
     LCD_WriteBytes                                  298
     LCD_WriteCommand                                 86
     LCD_WriteData                                    86
     LCD_SetFont                                      32
     LCD_CheckError                                    6
     LCD_Task                                         68
     mOperationLine                                    4
     LCD_TaskInit                                     18
     LCD_SetBacklight                                 36
     LCD_WritePixel                                  198
     LCD_WriteCharacter                              270
     LCD_WriteSymbol                                 108
     LCD_ClearPage                                    54
     LCD_ClearLine                                   164
     pageToDelete                                      4
     isPageDeleted                                     1
     ProcessOperation                                932
     linesToClear                                      1
     SendData                                         44
     SetHiZ                                           30
     SetOutput                                        26
     InitDisplayWrite                                 68
     ReadData                                         78
     GetData                                          54
     GetStrlen                                        54
     InitQueue                                        66
     AddToQueue                                       80
     RemoveFromQueue                                 114
     IsQueueEmpty                                     60
     IsQueueFull                                      60
     ??DataTable2                                      4
     ??DataTable3                                      4
     ??DataTable3_1                                    4
     ??DataTable3_2                                    4
     ??DataTable3_3                                    4
     ??DataTable3_4                                    4
     ??DataTable3_5                                    4
     ??DataTable3_6                                    4
     ??DataTable4                                      4
     ??DataTable4_1                                    4
     ??DataTable5                                      4
     ??DataTable9                                      4
     ??DataTable11                                     4
     ??DataTable11_1                                   4
     ??DataTable11_2                                   4
     ??DataTable13                                     4
     ??DataTable13_1                                   4
     ??DataTable13_2                                   4
     ??DataTable13_3                                   4
     ??DataTable13_4                                   4
     ??DataTable14                                     4
     ??DataTable14_1                                   4
     ??DataTable14_2                                   4
     ??DataTable14_3                                   4
     ??DataTable14_4                                   4
     ??DataTable14_5                                   4
     ??DataTable15                                     4
     ??DataTable15_1                                   4
     ??DataTable15_2                                   4
     ??DataTable15_3                                   4
     ??DataTable18                                     4
     ??DataTable19                                     4
     ??DataTable20                                     4
     ??DataTable20_1                                   4
     ??DataTable20_2                                   4
     ??DataTable20_3                                   4
     ?<Constant "Wrong line">                         12
     ?<Constant "Wrong line">_1                       12
     ?<Constant "Format unknow">                      16
     ?<Constant {83, 105, 122, 101, 32, 78, 111, 11   16
     ?<Constant {255, 255}>                            4

 
   116 bytes in section .bss
   298 bytes in section .data
   104 bytes in section .rodata
 5 174 bytes in section .text
 
 5 174 bytes of CODE  memory
   104 bytes of CONST memory
   414 bytes of DATA  memory

Errors: none
Warnings: none
