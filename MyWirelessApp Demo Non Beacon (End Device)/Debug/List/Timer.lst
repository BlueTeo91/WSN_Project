###############################################################################
#                                                                             #
#                                                       12/Oct/2015  10:21:28 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\PLM\Source\TMR\Timer.c           #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\TMR\Timer.c" -D       #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xSRB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Debug\List\" -lC "C:\Documents   #
#                    and Settings\Administrator\Desktop\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\MyWirelessApp Demo Non Beacon    #
#                    (End Device)\Debug\List\" -lB "C:\Documents and          #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\List\" --diag_suppress                     #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\MyWirelessApp Demo Non    #
#                    Beacon (End Device)\MyWirelessApp Demo Non Beacon (End   #
#                    Device)\Debug\Obj\" --no_cse --no_unroll --no_inline     #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\MacPhy\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Init\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Interface\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Configure\" -I       #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\UartUtil\" -I        #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\Application\Source\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Interface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\TS\Source\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Interface\" -I           #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\SSM\ZTC\Source\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Interface\" -I               #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\LibInterface\" -I            #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Display\" -I          #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\Keyboard\" -I         #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\NVM\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\TMR\" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\MyWirel #
#                    essApp Demo Non Beacon (End Device)\MyWirelessApp Demo   #
#                    Non Beacon (End Device)\PLM\Source\UART\" -I             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 5.4     #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\List\Timer.lst             #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\MyWirele #
#                    ssApp Demo Non Beacon (End Device)\MyWirelessApp Demo    #
#                    Non Beacon (End Device)\Debug\Obj\Timer.o                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\MyWirelessApp Demo Non Beacon (End Device)\MyWirelessApp Demo Non Beacon (End Device)\PLM\Source\TMR\Timer.c
      1          /*****************************************************************************
      2          * Timer implementation.
      3          *
      4          * Copyright (c) 2007, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          #include "EmbeddedTypes.h"
     13          #include "TS_Interface.h"
     14          #include "TMR_Interface.h"
     15          #include "Timer.h"
     16          #include "TMR.h"
     17          #include "Platform.h"
     18          #include "Interrupt.h"
     19          
     20          /*****************************************************************************
     21          ******************************************************************************
     22          * Private macros
     23          ******************************************************************************
     24          *****************************************************************************/
     25          
     26          /* Number of elements in an array. */
     27          #define NumberOfElements(array)   ((sizeof(array) / (sizeof(array[0]))))
     28          
     29          /* Timer status. If none of these flags are on, the timer is not allocated.
     30          * For allocated timers, exactly one of these flags will be set.
     31          * mTmrStatusActive_c   Timer has been started and has not yet expired.
     32          * mTmrStatusReady_c    TMR_StartTimer() has been called for this timer, but
     33          *                      the timer task has not yet actually started it. The
     34          *                      timer is considered to be active.
     35          * mTmrStatusInactive_c Timer is allocated, but is not active.
     36          */
     37          #define mTmrStatusFree_c        0
     38          #define mTmrStatusActive_c      0x20
     39          #define mTmrStatusReady_c       0x40
     40          #define mTmrStatusInactive_c    0x80
     41          
     42          #define mTimerStatusMask_c      (  mTmrStatusActive_c \
     43                                             | mTmrStatusReady_c \
     44                                             | mTmrStatusInactive_c)
     45          
     46          /* If all bits in the status byte are zero, the timer is free. */
     47          #define TMR_IsTimerAllocated(timerID)   (maTmrTimerStatusTable[(timerID)])
     48          #define TMR_MarkTimerFree(timerID)       maTmrTimerStatusTable[(timerID)] = 0
     49          #define IsLowPowerTimer(type)           ((type) & gTmrLowPowerTimer_c)
     50          
     51          #define mTimerType_c            ( gTmrSingleShotTimer_c \
     52                                           | gTmrSetSecondTimer_c \
     53                                           | gTmrSetMinuteTimer_c \
     54                                           | gTmrIntervalTimer_c \
     55                                           | gTmrLowPowerTimer_c )
     56          
     57          
     58          /* TMR_Task() event flag. Only one event is needed. */
     59          #define mTMR_Event_c    ( 1 << 0 )
     60          
     61          /*****************************************************************************
     62          ******************************************************************************
     63          * Private type definitions
     64          ******************************************************************************
     65          *****************************************************************************/
     66          
     67          /* One entry in the main timer table.
     68          * intervalInTicks      The timer's original duration, in ticks. Used to reset
     69          *                            intervnal timers.
     70          *
     71          *remainingTicks      Number of ticks until the timer expire.
     72          *
     73          
     74          */
     75          typedef struct tmrTimerTableEntry_tag {
     76            tmrTimerTicks32_t intervalInTicks;
     77            tmrTimerTicks32_t remainingTicks;
     78            pfTmrCallBack_t pfCallBack;
     79          } tmrTimerTableEntry_t;
     80          
     81          /* The status and type are bitfields, to save RAM. This costs some code */
     82          /* space, though. */
     83          typedef uint8_t tmrTimerStatus_t;
     84          
     85          typedef uint8_t tmrStatus_t;
     86          
     87          /*****************************************************************************
     88          ******************************************************************************
     89          * Private prototypes
     90          ******************************************************************************
     91          *****************************************************************************/
     92          static tmrStatus_t TMR_GetTimerStatus(tmrTimerID_t timerID);
     93          static void TMR_SetTimerStatus(tmrTimerID_t timerID, tmrStatus_t status);
     94          static tmrTimerType_t TMR_GetTimerType(tmrTimerID_t timerID);
     95          static void TMR_SetTimerType(tmrTimerID_t timerID, tmrTimerType_t type);
     96          static bool_t TMR_SetReg(TmrNumber_t tmrNumber);
     97          /* Convert milliseconds to ticks*/
     98          static tmrTimerTicks32_t TmrTicksFromMilliseconds(tmrTimeInMilliseconds_t milliseconds);
     99          
    100          /* Call Backs for timer module to handle interrupts*/
    101          void TmrCompEvCallBack(TmrNumber_t tmrNumber);
    102          
    103          /*****************************************************************************
    104          ******************************************************************************
    105          * Private memory declarations
    106          ******************************************************************************
    107          *****************************************************************************/

   \                                 In section .bss, align 2
    108          static tmrTimerTicks16_t previousTimeInTicks;
   \                     previousTimeInTicks:
   \   00000000                      DS8 2
    109          /* Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks 
    110          will never roll over previousTimeInTicks in the TMR_Task();
    111          A task have to be executed at most in 4ms */

   \                                 In section .bss, align 2
    112          static uint16_t mMaxToCountDown_c; 
   \                     mMaxToCountDown_c:
   \   00000000                      DS8 2
    113          /* The TMR_Task()event will not be issued faster than 4ms*/

   \                                 In section .bss, align 4
    114          static uint32_t mTicksFor4ms;
   \                     mTicksFor4ms:
   \   00000000                      DS8 4
    115          /* The source clock in Khz*/

   \                                 In section .data, align 4
    116          static uint32_t mClkSourceKhz = gTmrDefaultClkSourceKhz_c;
   \                     mClkSourceKhz:
   \   00000000   C05D0000           DC32 24000
    117          /* Main timer table. All allocated timers are stored here. A timer's ID */
    118          /* is it's index in this table. */

   \                                 In section .bss, align 4
    119          static tmrTimerTableEntry_t maTmrTimerTable[gTmrTotalTimers_c];
   \                     maTmrTimerTable:
   \   00000000                      DS8 408
    120          
    121          /* Making the single-byte-per-timer status table a separate array saves */
    122          /* a bit of code space. If an entry is == 0, the timer is not allocated. */

   \                                 In section .bss, align 4
    123          static tmrStatus_t maTmrTimerStatusTable[gTmrTotalTimers_c];
   \                     maTmrTimerStatusTable:
   \   00000000                      DS8 36
    124          
    125          /* Number of Active timers (without low power capability)
    126             the MCU can not enter low power if numberOfActiveTimers!=0 */

   \                                 In section .bss, align 1
    127          static uint8_t numberOfActiveTimers = 0;
   \                     numberOfActiveTimers:
   \   00000000                      DS8 1
    128          /* Number of low power active timer 
    129             The MCU can enter in low power if more low power timers are active */

   \                                 In section .bss, align 1
    130          static uint8_t numberOfLowPowerActiveTimers = 0;
   \                     numberOfLowPowerActiveTimers:
   \   00000000                      DS8 1
    131          
    132          #define IncrementActiveTimerNumber(type)  (((type) & gTmrLowPowerTimer_c) \
    133                                                    ?(++numberOfLowPowerActiveTimers) \
    134                                                    :(++numberOfActiveTimers) )                                   
    135          #define DecrementActiveTimerNumber(type)  (((type) & gTmrLowPowerTimer_c) \
    136                                                    ?(--numberOfLowPowerActiveTimers) \
    137                                                    :(--numberOfActiveTimers) ) 
    138          
    139          /* No other code should ever post an event to the timer task. */

   \                                 In section .bss, align 1
    140          static tsTaskID_t mTimerTaskID;
   \                     mTimerTaskID:
   \   00000000                      DS8 1
    141          
    142          /*****************************************************************************
    143          ******************************************************************************
    144          * Public functions
    145          ******************************************************************************
    146          *****************************************************************************/
    147          
    148          /* Initialize the timer module. */

   \                                 In section .text, align 2, keep-with-next
    149          void TMR_Init(void)
    150          {
   \                     TMR_Init:
   \   00000000   10B5               PUSH     {R4,LR}
    151            
    152            TmrInit();
   \   00000002   ........           BL       TmrInit
    153            TmrEnable(gTmrNumber_d);  /*enable timer*/
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   ........           BL       TmrEnable
    154            TMR_SetReg(gTmrNumber_d);
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   ........           BL       TMR_SetReg
    155            /*Create the timer task */
    156            mTimerTaskID = TS_CreateTask(gTsTimerTaskPriority_c, TMR_Task);
   \   00000012   ....               LDR      R1,??DataTable8
   \   00000014   FE20               MOVS     R0,#+254
   \   00000016   ........           BL       TS_CreateTask
   \   0000001A   ....               LDR      R1,??DataTable8_1
   \   0000001C   0870               STRB     R0,[R1, #+0]
    157            /* Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks 
    158            will never roll over previousTimeInTicks in the TMR_Task() */
    159            mMaxToCountDown_c = 0xFFFF - TmrTicksFromMilliseconds(8); 
   \   0000001E   ....               LDR      R4,??DataTable8_2  ;; 0xffff
   \   00000020   0820               MOVS     R0,#+8
   \   00000022   ........           BL       TmrTicksFromMilliseconds
   \   00000026   201A               SUBS     R0,R4,R0
   \   00000028   ....               LDR      R1,??DataTable8_3
   \   0000002A   0880               STRH     R0,[R1, #+0]
    160            /* The TMR_Task()event will not be issued faster than 4ms*/
    161            mTicksFor4ms = TmrTicksFromMilliseconds(4);
   \   0000002C   0420               MOVS     R0,#+4
   \   0000002E   ........           BL       TmrTicksFromMilliseconds
   \   00000032   ....               LDR      R1,??DataTable8_4
   \   00000034   0860               STR      R0,[R1, #+0]
    162            
    163          }
   \   00000036   10BC               POP      {R4}
   \   00000038   08BC               POP      {R3}
   \   0000003A   1847               BX       R3               ;; return
    164          
    165          /****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          void TMR_NotifyClkChanged(uint32_t clkKhz)
    167          {
   \                     TMR_NotifyClkChanged:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    168            mClkSourceKhz = clkKhz;
   \   00000004   ....               LDR      R0,??DataTable8_5
   \   00000006   0460               STR      R4,[R0, #+0]
    169            /* Clock was changed, so calculate again  mMaxToCountDown_c.
    170            Count to maximum (0xffff - 2*4ms(in ticks)), to be sure that the currentTimeInTicks 
    171            will never roll over previousTimeInTicks in the TMR_Task() */
    172            mMaxToCountDown_c = 0xFFFF - TmrTicksFromMilliseconds(8); 
   \   00000008   ....               LDR      R5,??DataTable8_2  ;; 0xffff
   \   0000000A   0820               MOVS     R0,#+8
   \   0000000C   ........           BL       TmrTicksFromMilliseconds
   \   00000010   281A               SUBS     R0,R5,R0
   \   00000012   ....               LDR      R1,??DataTable8_3
   \   00000014   0880               STRH     R0,[R1, #+0]
    173            /* The TMR_Task()event will not be issued faster than 4ms*/
    174            mTicksFor4ms = TmrTicksFromMilliseconds(4);  
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   ........           BL       TmrTicksFromMilliseconds
   \   0000001C   ....               LDR      R1,??DataTable8_4
   \   0000001E   0860               STR      R0,[R1, #+0]
    175          }
   \   00000020   31BC               POP      {R0,R4,R5}
   \   00000022   08BC               POP      {R3}
   \   00000024   1847               BX       R3               ;; return
    176          /****************************************************************************/
    177          
    178          /* Allocate a timer.
    179          * Returns the timer id, or gTmrInvalidTimerID_c if the timer table is full.
    180          */
    181          

   \                                 In section .text, align 2, keep-with-next
    182          tmrTimerID_t TMR_AllocateTimer
    183          (
    184          void
    185          )
    186          {
   \                     TMR_AllocateTimer:
   \   00000000   10B5               PUSH     {R4,LR}
    187            uint32_t i;
    188            
    189            for (i = 0; i < NumberOfElements(maTmrTimerTable); ++i) {
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0400               MOVS     R4,R0
   \                     ??TMR_AllocateTimer_0:
   \   00000006   222C               CMP      R4,#+34
   \   00000008   0FD2               BCS      ??TMR_AllocateTimer_1
    190              if (!TMR_IsTimerAllocated(i)) {
   \   0000000A   ....               LDR      R0,??DataTable8_6
   \   0000000C   005D               LDRB     R0,[R0, R4]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   09D1               BNE      ??TMR_AllocateTimer_2
    191                TMR_SetTimerStatus(i, mTmrStatusInactive_c);
   \   00000012   8021               MOVS     R1,#+128
   \   00000014   2000               MOVS     R0,R4
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   \   0000001A   ........           BL       TMR_SetTimerStatus
    192                return i;
   \   0000001E   2000               MOVS     R0,R4
   \   00000020   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000022   000E               LSRS     R0,R0,#+24
   \   00000024   02E0               B        ??TMR_AllocateTimer_3
    193              }
    194            }
   \                     ??TMR_AllocateTimer_2:
   \   00000026   641C               ADDS     R4,R4,#+1
   \   00000028   EDE7               B        ??TMR_AllocateTimer_0
    195            
    196            return gTmrInvalidTimerID_c;
   \                     ??TMR_AllocateTimer_1:
   \   0000002A   FF20               MOVS     R0,#+255
   \                     ??TMR_AllocateTimer_3:
   \   0000002C   10BC               POP      {R4}
   \   0000002E   08BC               POP      {R3}
   \   00000030   1847               BX       R3               ;; return
    197          }                                       /* TMR_AllocateTimer() */
    198          
    199          /*****************************************************************************/
    200          
    201          /* Return true if there are no active timers; return FALSE otherwise. */

   \                                 In section .text, align 2, keep-with-next
    202          bool_t TMR_AreAllTimersOff
    203          (
    204          void
    205          )
    206          {
   \                     TMR_AreAllTimersOff:
   \   00000000   00B5               PUSH     {LR}
    207            return !numberOfActiveTimers;
   \   00000002   ....               LDR      R0,??DataTable8_7
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   01D1               BNE      ??TMR_AreAllTimersOff_0
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   00E0               B        ??TMR_AreAllTimersOff_1
   \                     ??TMR_AreAllTimersOff_0:
   \   0000000E   0020               MOVS     R0,#+0
   \                     ??TMR_AreAllTimersOff_1:
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   08BC               POP      {R3}
   \   00000016   1847               BX       R3               ;; return
    208          }                                       /* TMR_AreAllTimersOff() */
    209          
    210          /****************************************************************************/
    211          
    212          /* Free any timer. Harmless if the timer is already free. */

   \                                 In section .text, align 2, keep-with-next
    213          void TMR_FreeTimer
    214          (
    215          tmrTimerID_t timerID
    216          )
    217          {
   \                     TMR_FreeTimer:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    218            TMR_StopTimer(timerID);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       TMR_StopTimer
    219            TMR_MarkTimerFree(timerID);
   \   0000000E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000010   240E               LSRS     R4,R4,#+24
   \   00000012   ....               LDR      R0,??DataTable8_6
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0155               STRB     R1,[R0, R4]
    220          }                                       /* TMR_FreeTimer() */
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    221          
    222          /****************************************************************************/
    223          
    224          /*Call Back function when the interrupt occurs*/

   \                                 In section .text, align 2, keep-with-next
    225          void TmrCompEvCallBack(TmrNumber_t tmrNumber)
    226          {
   \                     TmrCompEvCallBack:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    227            
    228            TS_SendEvent(mTimerTaskID, mTMR_Event_c);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   ....               LDR      R0,??DataTable8_1
   \   00000008   0078               LDRB     R0,[R0, #+0]
   \   0000000A   ........           BL       TS_SendEvent
    229            
    230          }
   \   0000000E   10BC               POP      {R4}
   \   00000010   08BC               POP      {R3}
   \   00000012   1847               BX       R3               ;; return
    231          
    232          /*****************************************************************************/
    233          
    234          /* Return TRUE if the timer is active. */

   \                                 In section .text, align 2, keep-with-next
    235          bool_t TMR_IsTimerActive
    236          (
    237          tmrTimerID_t timerID
    238          )
    239          {
   \                     TMR_IsTimerActive:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    240            return TMR_GetTimerStatus(timerID) == mTmrStatusActive_c;
   \   00000004   2000               MOVS     R0,R4
   \   00000006   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   ........           BL       TMR_GetTimerStatus
   \   0000000E   2028               CMP      R0,#+32
   \   00000010   01D1               BNE      ??TMR_IsTimerActive_0
   \   00000012   0120               MOVS     R0,#+1
   \   00000014   00E0               B        ??TMR_IsTimerActive_1
   \                     ??TMR_IsTimerActive_0:
   \   00000016   0020               MOVS     R0,#+0
   \                     ??TMR_IsTimerActive_1:
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   10BC               POP      {R4}
   \   0000001E   08BC               POP      {R3}
   \   00000020   1847               BX       R3               ;; return
    241          }                                       /* TMR_IsTimerActive() */
    242          
    243          /****************************************************************************/
    244          
    245          /****************************************************************************
    246          *
    247          * Start a timer (BeeStack or application). When the timer goes off, call
    248          * the callback function in non-interrupt context.
    249          *
    250          *****************************************************************************/
    251          
    252          

   \                                 In section .text, align 2, keep-with-next
    253          void TMR_StartTimer
    254          (
    255          tmrTimerID_t timerID,                       /* IN: */
    256          tmrTimerType_t timerType,                   /* IN: */
    257          tmrTimeInMilliseconds_t timeInMilliseconds, /* IN: */
    258          void (*pfTimerCallBack)(tmrTimerID_t)       /* IN: */
    259          )
    260          {
   \                     TMR_StartTimer:
   \   00000000   F2B5               PUSH     {R1,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   1700               MOVS     R7,R2
   \   00000006   1E00               MOVS     R6,R3
    261            tmrTimerTicks32_t intervalInTicks;
    262            
    263            /* Stopping an already stopped timer is harmless. */
    264            TMR_StopTimer(timerID);
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000C   000E               LSRS     R0,R0,#+24
   \   0000000E   ........           BL       TMR_StopTimer
    265            
    266            intervalInTicks = TmrTicksFromMilliseconds(timeInMilliseconds);
   \   00000012   3800               MOVS     R0,R7
   \   00000014   ........           BL       TmrTicksFromMilliseconds
   \   00000018   0500               MOVS     R5,R0
    267            if (!intervalInTicks) {
   \   0000001A   002D               CMP      R5,#+0
   \   0000001C   01D1               BNE      ??TMR_StartTimer_0
    268              intervalInTicks = 1;
   \   0000001E   0120               MOVS     R0,#+1
   \   00000020   0500               MOVS     R5,R0
    269            }
    270            
    271            TMR_SetTimerType(timerID, timerType);
   \                     ??TMR_StartTimer_0:
   \   00000022   6846               MOV      R0,SP
   \   00000024   0178               LDRB     R1,[R0, #+0]
   \   00000026   2000               MOVS     R0,R4
   \   00000028   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002A   000E               LSRS     R0,R0,#+24
   \   0000002C   ........           BL       TMR_SetTimerType
    272            maTmrTimerTable[timerID].intervalInTicks = intervalInTicks;
   \   00000030   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000032   240E               LSRS     R4,R4,#+24
   \   00000034   0C20               MOVS     R0,#+12
   \   00000036   6043               MULS     R0,R4,R0
   \   00000038   ....               LDR      R1,??DataTable8_8
   \   0000003A   0D50               STR      R5,[R1, R0]
    273            maTmrTimerTable[timerID].remainingTicks = intervalInTicks;
   \   0000003C   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000003E   240E               LSRS     R4,R4,#+24
   \   00000040   0C20               MOVS     R0,#+12
   \   00000042   6043               MULS     R0,R4,R0
   \   00000044   ....               LDR      R1,??DataTable8_8
   \   00000046   0818               ADDS     R0,R1,R0
   \   00000048   4560               STR      R5,[R0, #+4]
    274            maTmrTimerTable[timerID].pfCallBack = pfTimerCallBack;
   \   0000004A   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000004C   240E               LSRS     R4,R4,#+24
   \   0000004E   0C20               MOVS     R0,#+12
   \   00000050   6043               MULS     R0,R4,R0
   \   00000052   ....               LDR      R1,??DataTable8_8
   \   00000054   0818               ADDS     R0,R1,R0
   \   00000056   8660               STR      R6,[R0, #+8]
    275           
    276            /* Enable timer, the timer task will do the rest of the work. */
    277            TMR_EnableTimer(timerID);
   \   00000058   2000               MOVS     R0,R4
   \   0000005A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000005C   000E               LSRS     R0,R0,#+24
   \   0000005E   ........           BL       TMR_EnableTimer
    278          }                                       /* TMR_StartTimer() */
   \   00000062   F1BC               POP      {R0,R4-R7}
   \   00000064   08BC               POP      {R3}
   \   00000066   1847               BX       R3               ;; return
    279          
    280          /* Start a low power timer. When the timer goes off, call the callback function */
    281          /* in non-interrupt context. If the timer is running when this function */
    282          /* is called, it will be stopped and restarted. */
    283          /* Start the timer with the following timer types:
    284             gTmrLowPowerMinuteTimer_c
    285             gTmrLowPowerSecondTimer_c
    286             gTmrLowPowerSingleShotMillisTimer_c
    287             gTmrLowPowerIntervalMillisTimer_c
    288          */
    289          /* The MCU can enter in low power if there are only active low power timers */

   \                                 In section .text, align 2, keep-with-next
    290          void TMR_StartLowPowerTimer
    291          (
    292          tmrTimerID_t timerId,
    293          tmrTimerType_t timerType,
    294          uint32_t timeIn,
    295          void (*pfTmrCallBack)(tmrTimerID_t)
    296          ) 
    297          {
   \                     TMR_StartLowPowerTimer:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1700               MOVS     R7,R2
   \   00000008   1E00               MOVS     R6,R3
    298          #if(gTMR_EnableLowPowerTimers_d)
    299            TMR_StartTimer(timerId, timerType | gTmrLowPowerTimer_c, timeIn, pfTmrCallBack);
   \   0000000A   3300               MOVS     R3,R6
   \   0000000C   3A00               MOVS     R2,R7
   \   0000000E   1021               MOVS     R1,#+16
   \   00000010   2143               ORRS     R1,R1,R4
   \   00000012   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000014   090E               LSRS     R1,R1,#+24
   \   00000016   2800               MOVS     R0,R5
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   ........           BL       TMR_StartTimer
    300          #else
    301          (void)timerId;
    302          (void)timerType;
    303          (void)timeIn;
    304          (void)pfTmrCallBack;
    305          #endif
    306          }
   \   00000020   F1BC               POP      {R0,R4-R7}
   \   00000022   08BC               POP      {R3}
   \   00000024   1847               BX       R3               ;; return
    307          
    308          
    309          /* Start a minute timer. */
    310          /* Note: this is a single shot timer. There are no interval minute timers. */

   \                                 In section .text, align 2, keep-with-next
    311          void TMR_StartMinuteTimer
    312          (
    313          tmrTimerID_t timerId, 
    314          tmrTimeInMinutes_t timeInMinutes, 
    315          void (*pfTmrCallBack)(tmrTimerID_t)
    316          )
    317          {
   \                     TMR_StartMinuteTimer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1400               MOVS     R4,R2
    318          TMR_StartTimer(timerId, gTmrMinuteTimer_c, TmrMinutes(timeInMinutes), pfTmrCallBack);
   \   00000008   2300               MOVS     R3,R4
   \   0000000A   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   0000000C   2D0C               LSRS     R5,R5,#+16
   \   0000000E   ....               LDR      R2,??DataTable9  ;; 0xea60
   \   00000010   6A43               MULS     R2,R5,R2
   \   00000012   0421               MOVS     R1,#+4
   \   00000014   3000               MOVS     R0,R6
   \   00000016   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000018   000E               LSRS     R0,R0,#+24
   \   0000001A   ........           BL       TMR_StartTimer
    319          }
   \   0000001E   70BC               POP      {R4-R6}
   \   00000020   08BC               POP      {R3}
   \   00000022   1847               BX       R3               ;; return
    320            
    321          /* Start a second timer. */
    322          /* Note: this is a single shot timer. There are no interval second timers. */

   \                                 In section .text, align 2, keep-with-next
    323          void TMR_StartSecondTimer
    324          (
    325          tmrTimerID_t timerId, 
    326          tmrTimeInSeconds_t timeInSeconds, 
    327          void (*pfTmrCallBack)(tmrTimerID_t)
    328          ) 
    329          {
   \                     TMR_StartSecondTimer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1400               MOVS     R4,R2
    330          TMR_StartTimer(timerId, gTmrSecondTimer_c, TmrSeconds(timeInSeconds), pfTmrCallBack);
   \   00000008   2300               MOVS     R3,R4
   \   0000000A   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   0000000C   2D0C               LSRS     R5,R5,#+16
   \   0000000E   FA22               MOVS     R2,#+250
   \   00000010   9200               LSLS     R2,R2,#+2        ;; #+1000
   \   00000012   6A43               MULS     R2,R5,R2
   \   00000014   0821               MOVS     R1,#+8
   \   00000016   3000               MOVS     R0,R6
   \   00000018   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \   0000001C   ........           BL       TMR_StartTimer
    331          }
   \   00000020   70BC               POP      {R4-R6}
   \   00000022   08BC               POP      {R3}
   \   00000024   1847               BX       R3               ;; return
    332           
    333          /****************************************************************************/
    334          

   \                                 In section .text, align 2, keep-with-next
    335          void TMR_StartIntervalTimer
    336          (
    337          tmrTimerID_t timerID,
    338          tmrTimeInMilliseconds_t timeInMilliseconds,
    339          void (*pfTimerCallBack)(tmrTimerID_t)
    340          )
    341          {
   \                     TMR_StartIntervalTimer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1400               MOVS     R4,R2
    342            TMR_StartTimer(timerID, gTmrIntervalTimer_c, timeInMilliseconds, pfTimerCallBack);
   \   00000008   2300               MOVS     R3,R4
   \   0000000A   2A00               MOVS     R2,R5
   \   0000000C   0221               MOVS     R1,#+2
   \   0000000E   3000               MOVS     R0,R6
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   ........           BL       TMR_StartTimer
    343          }
   \   00000018   70BC               POP      {R4-R6}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    344          

   \                                 In section .text, align 2, keep-with-next
    345          void TMR_StartSingleShotTimer
    346          (
    347          tmrTimerID_t timerID,
    348          tmrTimeInMilliseconds_t timeInMilliseconds,
    349          void (*pfTimerCallBack)(tmrTimerID_t)
    350          )
    351          {
   \                     TMR_StartSingleShotTimer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1400               MOVS     R4,R2
    352            TMR_StartTimer(timerID, gTmrSingleShotTimer_c, timeInMilliseconds, pfTimerCallBack);
   \   00000008   2300               MOVS     R3,R4
   \   0000000A   2A00               MOVS     R2,R5
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   3000               MOVS     R0,R6
   \   00000010   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000012   000E               LSRS     R0,R0,#+24
   \   00000014   ........           BL       TMR_StartTimer
    353          }
   \   00000018   70BC               POP      {R4-R6}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    354          
    355          /****************************************************************************/
    356          
    357          /* Stop a timer. Does not free the timer; does not call the timer's callback
    358          * function.
    359          *
    360          * Harmless if the timer is already inactive.
    361          */

   \                                 In section .text, align 2, keep-with-next
    362          void TMR_StopTimer
    363          (
    364          tmrTimerID_t timerID
    365          )
    366          {
   \                     TMR_StopTimer:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    367            tmrStatus_t status;
    368            unsigned int saveInt;
    369            saveInt = IntDisableAll();
   \   00000004   ........           BL       IntDisableAll
   \   00000008   0600               MOVS     R6,R0
    370            status = TMR_GetTimerStatus(timerID);
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000E   000E               LSRS     R0,R0,#+24
   \   00000010   ........           BL       TMR_GetTimerStatus
   \   00000014   0500               MOVS     R5,R0
    371            if (   status == mTmrStatusActive_c
    372                || status == mTmrStatusReady_c) {
   \   00000016   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000018   2D0E               LSRS     R5,R5,#+24
   \   0000001A   202D               CMP      R5,#+32
   \   0000001C   03D0               BEQ      ??TMR_StopTimer_0
   \   0000001E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000020   2D0E               LSRS     R5,R5,#+24
   \   00000022   402D               CMP      R5,#+64
   \   00000024   29D1               BNE      ??TMR_StopTimer_1
    373                  TMR_SetTimerStatus(timerID, mTmrStatusInactive_c);
   \                     ??TMR_StopTimer_0:
   \   00000026   8021               MOVS     R1,#+128
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   \   0000002E   ........           BL       TMR_SetTimerStatus
    374                  DecrementActiveTimerNumber(TMR_GetTimerType(timerID));
   \   00000032   2000               MOVS     R0,R4
   \   00000034   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000036   000E               LSRS     R0,R0,#+24
   \   00000038   ........           BL       TMR_GetTimerType
   \   0000003C   C006               LSLS     R0,R0,#+27
   \   0000003E   07D5               BPL      ??TMR_StopTimer_2
   \   00000040   ....               LDR      R0,??DataTable11
   \   00000042   0078               LDRB     R0,[R0, #+0]
   \   00000044   401E               SUBS     R0,R0,#+1
   \   00000046   ....               LDR      R1,??DataTable11
   \   00000048   0870               STRB     R0,[R1, #+0]
   \   0000004A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000004C   000E               LSRS     R0,R0,#+24
   \   0000004E   06E0               B        ??TMR_StopTimer_3
   \                     ??TMR_StopTimer_2:
   \   00000050   ....               LDR      R0,??DataTable8_7
   \   00000052   0078               LDRB     R0,[R0, #+0]
   \   00000054   401E               SUBS     R0,R0,#+1
   \   00000056   ....               LDR      R1,??DataTable8_7
   \   00000058   0870               STRB     R0,[R1, #+0]
   \   0000005A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000005C   000E               LSRS     R0,R0,#+24
    375                  /* if no sw active timers are enabled, */
    376                  /* call the TMR_Task() to countdown the ticks and stop the hw timer*/
    377              		if (!numberOfActiveTimers && !numberOfLowPowerActiveTimers) 
   \                     ??TMR_StopTimer_3:
   \   0000005E   ....               LDR      R0,??DataTable8_7
   \   00000060   0078               LDRB     R0,[R0, #+0]
   \   00000062   ....               LDR      R1,??DataTable11
   \   00000064   0978               LDRB     R1,[R1, #+0]
   \   00000066   0143               ORRS     R1,R1,R0
   \   00000068   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000006A   090E               LSRS     R1,R1,#+24
   \   0000006C   0029               CMP      R1,#+0
   \   0000006E   04D1               BNE      ??TMR_StopTimer_1
    378                     TS_SendEvent(mTimerTaskID, mTMR_Event_c);
   \   00000070   0121               MOVS     R1,#+1
   \   00000072   ....               LDR      R0,??DataTable8_1
   \   00000074   0078               LDRB     R0,[R0, #+0]
   \   00000076   ........           BL       TS_SendEvent
    379                }
    380            IntRestoreAll(saveInt);    
   \                     ??TMR_StopTimer_1:
   \   0000007A   3000               MOVS     R0,R6
   \   0000007C   ........           BL       IntRestoreAll
    381          }                                       /* TMR_StopTimer() */
   \   00000080   70BC               POP      {R4-R6}
   \   00000082   08BC               POP      {R3}
   \   00000084   1847               BX       R3               ;; return
    382          
    383          /*****************************************************************************/
    384          
    385          /*****************************************************************************
    386          * Timer task. Called by the kernel when the timer ISR posts a timer event.
    387          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    388          void TMR_Task
    389          (
    390          event_t events
    391          )
    392          {
   \                     TMR_Task:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    393            static bool_t timerHardwareIsRunning = FALSE;
    394            tmrTimerTicks16_t nextInterruptTime;
    395            pfTmrCallBack_t pfCallBack;
    396            tmrTimerTicks16_t currentTimeInTicks;
    397            tmrTimerStatus_t status;
    398            tmrTimerTicks16_t ticksSinceLastHere, ticksdiff; 
    399            uint8_t timerID;
    400            unsigned int saveInt;
    401            tmrTimerType_t timerType;
    402            (void)events;
    403            
    404            TmrReadValue(gTmrNumber_d,&currentTimeInTicks);
   \   00000004   01A9               ADD      R1,SP,#+4
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   ........           BL       TmrReadValue
    405            /* calculate difference between current and previous.  */
    406            ticksSinceLastHere = (currentTimeInTicks - previousTimeInTicks);
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   6946               MOV      R1,SP
   \   00000010   8988               LDRH     R1,[R1, #+4]
   \   00000012   ....               LDR      R2,??DataTable11_1
   \   00000014   1288               LDRH     R2,[R2, #+0]
   \   00000016   891A               SUBS     R1,R1,R2
   \   00000018   C180               STRH     R1,[R0, #+6]
    407            /* remember for next time */
    408            previousTimeInTicks = currentTimeInTicks;
   \   0000001A   ....               LDR      R0,??DataTable11_1
   \   0000001C   6946               MOV      R1,SP
   \   0000001E   8988               LDRH     R1,[R1, #+4]
   \   00000020   0180               STRH     R1,[R0, #+0]
    409            
    410            for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID) {
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   0500               MOVS     R5,R0
   \                     ??TMR_Task_0:
   \   00000026   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000028   2D0E               LSRS     R5,R5,#+24
   \   0000002A   222D               CMP      R5,#+34
   \   0000002C   6CD2               BCS      ??TMR_Task_1
    411              saveInt = IntDisableAll();
   \   0000002E   ........           BL       IntDisableAll
   \   00000032   0600               MOVS     R6,R0
    412              status = TMR_GetTimerStatus(timerID);
   \   00000034   2800               MOVS     R0,R5
   \   00000036   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000038   000E               LSRS     R0,R0,#+24
   \   0000003A   ........           BL       TMR_GetTimerStatus
   \   0000003E   6946               MOV      R1,SP
   \   00000040   8870               STRB     R0,[R1, #+2]
    413              /* If TMR_StartTimer() has been called for this timer, start it's count */
    414              /* down as of now. */
    415              if (status == mTmrStatusReady_c) {
   \   00000042   6846               MOV      R0,SP
   \   00000044   8078               LDRB     R0,[R0, #+2]
   \   00000046   4028               CMP      R0,#+64
   \   00000048   09D1               BNE      ??TMR_Task_2
    416                TMR_SetTimerStatus(timerID, mTmrStatusActive_c);
   \   0000004A   2021               MOVS     R1,#+32
   \   0000004C   2800               MOVS     R0,R5
   \   0000004E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000050   000E               LSRS     R0,R0,#+24
   \   00000052   ........           BL       TMR_SetTimerStatus
    417                IntRestoreAll(saveInt);
   \   00000056   3000               MOVS     R0,R6
   \   00000058   ........           BL       IntRestoreAll
    418                continue;
   \   0000005C   52E0               B        ??TMR_Task_3
    419              }
    420              IntRestoreAll(saveInt);
   \                     ??TMR_Task_2:
   \   0000005E   3000               MOVS     R0,R6
   \   00000060   ........           BL       IntRestoreAll
    421              
    422              /* Ignore any timer that is not active. */
    423              if (status != mTmrStatusActive_c) {
   \   00000064   6846               MOV      R0,SP
   \   00000066   8078               LDRB     R0,[R0, #+2]
   \   00000068   2028               CMP      R0,#+32
   \   0000006A   4BD1               BNE      ??TMR_Task_3
    424                continue;
    425              }
    426              
    427              /* This timer is active. Decrement it's countdown.. */
    428              if (maTmrTimerTable[timerID].remainingTicks > ticksSinceLastHere) {
   \                     ??TMR_Task_4:
   \   0000006C   6846               MOV      R0,SP
   \   0000006E   C088               LDRH     R0,[R0, #+6]
   \   00000070   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000072   2D0E               LSRS     R5,R5,#+24
   \   00000074   0C21               MOVS     R1,#+12
   \   00000076   6943               MULS     R1,R5,R1
   \   00000078   ....               LDR      R2,??DataTable12
   \   0000007A   5118               ADDS     R1,R2,R1
   \   0000007C   4968               LDR      R1,[R1, #+4]
   \   0000007E   8842               CMP      R0,R1
   \   00000080   11D2               BCS      ??TMR_Task_5
    429                maTmrTimerTable[timerID].remainingTicks -= ticksSinceLastHere;
   \   00000082   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000084   2D0E               LSRS     R5,R5,#+24
   \   00000086   0C20               MOVS     R0,#+12
   \   00000088   6843               MULS     R0,R5,R0
   \   0000008A   ....               LDR      R1,??DataTable12
   \   0000008C   0818               ADDS     R0,R1,R0
   \   0000008E   4068               LDR      R0,[R0, #+4]
   \   00000090   6946               MOV      R1,SP
   \   00000092   C988               LDRH     R1,[R1, #+6]
   \   00000094   401A               SUBS     R0,R0,R1
   \   00000096   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000098   2D0E               LSRS     R5,R5,#+24
   \   0000009A   0C21               MOVS     R1,#+12
   \   0000009C   6943               MULS     R1,R5,R1
   \   0000009E   ....               LDR      R2,??DataTable12
   \   000000A0   5118               ADDS     R1,R2,R1
   \   000000A2   4860               STR      R0,[R1, #+4]
    430                continue;
   \   000000A4   2EE0               B        ??TMR_Task_3
    431              }
    432              
    433              timerType = TMR_GetTimerType(timerID);
   \                     ??TMR_Task_5:
   \   000000A6   2800               MOVS     R0,R5
   \   000000A8   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000AA   000E               LSRS     R0,R0,#+24
   \   000000AC   ........           BL       TMR_GetTimerType
   \   000000B0   6946               MOV      R1,SP
   \   000000B2   C870               STRB     R0,[R1, #+3]
    434              /* If this is an interval timer, restart it. Otherwise, mark it as inactive. */
    435              if ( (timerType & gTmrSingleShotTimer_c) ||
    436                   (timerType & gTmrSetMinuteTimer_c) ||
    437                   (timerType & gTmrSetSecondTimer_c)  ) {
   \   000000B4   6846               MOV      R0,SP
   \   000000B6   C078               LDRB     R0,[R0, #+3]
   \   000000B8   0D21               MOVS     R1,#+13
   \   000000BA   0842               TST      R0,R1
   \   000000BC   05D0               BEQ      ??TMR_Task_6
    438                TMR_StopTimer(timerID);
   \   000000BE   2800               MOVS     R0,R5
   \   000000C0   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000C2   000E               LSRS     R0,R0,#+24
   \   000000C4   ........           BL       TMR_StopTimer
   \   000000C8   0CE0               B        ??TMR_Task_7
    439              } else {
    440                maTmrTimerTable[timerID].remainingTicks = maTmrTimerTable[timerID].intervalInTicks;
   \                     ??TMR_Task_6:
   \   000000CA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000CC   2D0E               LSRS     R5,R5,#+24
   \   000000CE   0C20               MOVS     R0,#+12
   \   000000D0   6843               MULS     R0,R5,R0
   \   000000D2   ....               LDR      R1,??DataTable12
   \   000000D4   0818               ADDS     R0,R1,R0
   \   000000D6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000D8   2D0E               LSRS     R5,R5,#+24
   \   000000DA   0C21               MOVS     R1,#+12
   \   000000DC   6943               MULS     R1,R5,R1
   \   000000DE   ....               LDR      R2,??DataTable12
   \   000000E0   5158               LDR      R1,[R2, R1]
   \   000000E2   4160               STR      R1,[R0, #+4]
    441              }
    442              /* This timer has expired. */
    443              pfCallBack = maTmrTimerTable[timerID].pfCallBack;
   \                     ??TMR_Task_7:
   \   000000E4   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000E6   2D0E               LSRS     R5,R5,#+24
   \   000000E8   0C20               MOVS     R0,#+12
   \   000000EA   6843               MULS     R0,R5,R0
   \   000000EC   ....               LDR      R1,??DataTable12
   \   000000EE   0818               ADDS     R0,R1,R0
   \   000000F0   8068               LDR      R0,[R0, #+8]
   \   000000F2   0700               MOVS     R7,R0
    444              /*Call callback if it is not NULL
    445              This is done after the timer got updated,
    446              in case the timer gets stopped or restarted in the callback*/
    447              if (pfCallBack) {
   \   000000F4   3800               MOVS     R0,R7
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   04D0               BEQ      ??TMR_Task_3
    448                pfCallBack(timerID);
   \   000000FA   2800               MOVS     R0,R5
   \   000000FC   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000FE   000E               LSRS     R0,R0,#+24
   \   00000100   ........           BL       __iar_via_R7
    449              }
    450              
    451            }  /* for (timerID = 0; timerID < ... */
   \                     ??TMR_Task_3:
   \   00000104   6D1C               ADDS     R5,R5,#+1
   \   00000106   8EE7               B        ??TMR_Task_0
    452            
    453            /* Find the shortest active timer. */
    454            nextInterruptTime = mMaxToCountDown_c;
   \                     ??TMR_Task_1:
   \   00000108   ....               LDR      R0,??DataTable12_1
   \   0000010A   0088               LDRH     R0,[R0, #+0]
   \   0000010C   0400               MOVS     R4,R0
    455            for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID) {
   \   0000010E   0020               MOVS     R0,#+0
   \   00000110   0500               MOVS     R5,R0
   \                     ??TMR_Task_8:
   \   00000112   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000114   2D0E               LSRS     R5,R5,#+24
   \   00000116   222D               CMP      R5,#+34
   \   00000118   1BD2               BCS      ??TMR_Task_9
    456              if (TMR_GetTimerStatus(timerID) == mTmrStatusActive_c) {
   \   0000011A   2800               MOVS     R0,R5
   \   0000011C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000011E   000E               LSRS     R0,R0,#+24
   \   00000120   ........           BL       TMR_GetTimerStatus
   \   00000124   2028               CMP      R0,#+32
   \   00000126   12D1               BNE      ??TMR_Task_10
    457                if (nextInterruptTime > maTmrTimerTable[timerID].remainingTicks) {
   \   00000128   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000012A   2D0E               LSRS     R5,R5,#+24
   \   0000012C   0C20               MOVS     R0,#+12
   \   0000012E   6843               MULS     R0,R5,R0
   \   00000130   ....               LDR      R1,??DataTable12
   \   00000132   0818               ADDS     R0,R1,R0
   \   00000134   4068               LDR      R0,[R0, #+4]
   \   00000136   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000138   240C               LSRS     R4,R4,#+16
   \   0000013A   A042               CMP      R0,R4
   \   0000013C   07D2               BCS      ??TMR_Task_10
    458                  nextInterruptTime = maTmrTimerTable[timerID].remainingTicks;
   \   0000013E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000140   2D0E               LSRS     R5,R5,#+24
   \   00000142   0C20               MOVS     R0,#+12
   \   00000144   6843               MULS     R0,R5,R0
   \   00000146   ....               LDR      R1,??DataTable12
   \   00000148   0818               ADDS     R0,R1,R0
   \   0000014A   4068               LDR      R0,[R0, #+4]
   \   0000014C   0400               MOVS     R4,R0
    459                }
    460              }
    461            }
   \                     ??TMR_Task_10:
   \   0000014E   6D1C               ADDS     R5,R5,#+1
   \   00000150   DFE7               B        ??TMR_Task_8
    462            
    463            /* Check to be sure that the timer is not programmed in the past */    
    464            saveInt = IntDisableAll();
   \                     ??TMR_Task_9:
   \   00000152   ........           BL       IntDisableAll
   \   00000156   0600               MOVS     R6,R0
    465            TmrReadValue(gTmrNumber_d,&ticksdiff);
   \   00000158   6946               MOV      R1,SP
   \   0000015A   0020               MOVS     R0,#+0
   \   0000015C   ........           BL       TmrReadValue
    466            /* Number of ticks to be here */
    467            ticksdiff = (uint16_t)(ticksdiff - currentTimeInTicks); 
   \   00000160   6846               MOV      R0,SP
   \   00000162   0088               LDRH     R0,[R0, #+0]
   \   00000164   6946               MOV      R1,SP
   \   00000166   8988               LDRH     R1,[R1, #+4]
   \   00000168   401A               SUBS     R0,R0,R1
   \   0000016A   6946               MOV      R1,SP
   \   0000016C   0880               STRH     R0,[R1, #+0]
    468             /* Next ticks to count already expired?? */
    469            if(ticksdiff >= nextInterruptTime)
   \   0000016E   6846               MOV      R0,SP
   \   00000170   0088               LDRH     R0,[R0, #+0]
   \   00000172   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   00000174   240C               LSRS     R4,R4,#+16
   \   00000176   A042               CMP      R0,R4
   \   00000178   06D3               BCC      ??TMR_Task_11
    470            {  
    471              /* Is assumed that a task has to be executed in 4ms...
    472                 so if the ticks already expired enter in TMR_Task() after 4ms*/
    473              nextInterruptTime = ticksdiff + mTicksFor4ms;
   \   0000017A   6846               MOV      R0,SP
   \   0000017C   0088               LDRH     R0,[R0, #+0]
   \   0000017E   ....               LDR      R1,??DataTable17
   \   00000180   0968               LDR      R1,[R1, #+0]
   \   00000182   4018               ADDS     R0,R0,R1
   \   00000184   0400               MOVS     R4,R0
   \   00000186   0EE0               B        ??TMR_Task_12
    474            } 
    475            else 
    476            {
    477              /* Time reference is 4ms...
    478                 so be sure that won't be loaded in Cmp Reg. less that 4ms in ticks 
    479              */
    480               if((nextInterruptTime - ticksdiff) < mTicksFor4ms) 
   \                     ??TMR_Task_11:
   \   00000188   2404               LSLS     R4,R4,#+16       ;; ZeroExtS R4,R4,#+16,#+16
   \   0000018A   240C               LSRS     R4,R4,#+16
   \   0000018C   6846               MOV      R0,SP
   \   0000018E   0088               LDRH     R0,[R0, #+0]
   \   00000190   201A               SUBS     R0,R4,R0
   \   00000192   ....               LDR      R1,??DataTable17
   \   00000194   0968               LDR      R1,[R1, #+0]
   \   00000196   8842               CMP      R0,R1
   \   00000198   05D2               BCS      ??TMR_Task_12
    481               {
    482                 nextInterruptTime = ticksdiff + mTicksFor4ms;
   \   0000019A   6846               MOV      R0,SP
   \   0000019C   0088               LDRH     R0,[R0, #+0]
   \   0000019E   ....               LDR      R1,??DataTable17
   \   000001A0   0968               LDR      R1,[R1, #+0]
   \   000001A2   4018               ADDS     R0,R0,R1
   \   000001A4   0400               MOVS     R4,R0
    483               }
    484            
    485            }
    486            /* Update the compare register */
    487            nextInterruptTime += currentTimeInTicks;
   \                     ??TMR_Task_12:
   \   000001A6   6846               MOV      R0,SP
   \   000001A8   8088               LDRH     R0,[R0, #+4]
   \   000001AA   2418               ADDS     R4,R4,R0
    488            SetComp1Val(gTmrNumber_d, nextInterruptTime);
   \   000001AC   ....               LDR      R0,??DataTable18  ;; 0x80007000
   \   000001AE   0480               STRH     R4,[R0, #+0]
    489            IntRestoreAll(saveInt);
   \   000001B0   3000               MOVS     R0,R6
   \   000001B2   ........           BL       IntRestoreAll
    490            
    491            if (!numberOfActiveTimers && !numberOfLowPowerActiveTimers)
   \   000001B6   ....               LDR      R0,??DataTable11_2
   \   000001B8   0078               LDRB     R0,[R0, #+0]
   \   000001BA   ....               LDR      R1,??DataTable11
   \   000001BC   0978               LDRB     R1,[R1, #+0]
   \   000001BE   0143               ORRS     R1,R1,R0
   \   000001C0   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001C2   090E               LSRS     R1,R1,#+24
   \   000001C4   0029               CMP      R1,#+0
   \   000001C6   07D1               BNE      ??TMR_Task_13
    492            {
    493              TmrStopTimerHardware();
   \   000001C8   0021               MOVS     R1,#+0
   \   000001CA   0020               MOVS     R0,#+0
   \   000001CC   ........           BL       TmrSetMode
    494              timerHardwareIsRunning = FALSE;
   \   000001D0   ....               LDR      R0,??DataTable18_1
   \   000001D2   0021               MOVS     R1,#+0
   \   000001D4   0170               STRB     R1,[R0, #+0]
   \   000001D6   0AE0               B        ??TMR_Task_14
    495            } 
    496            else 
    497              if (!timerHardwareIsRunning) 
   \                     ??TMR_Task_13:
   \   000001D8   ....               LDR      R0,??DataTable18_1
   \   000001DA   0078               LDRB     R0,[R0, #+0]
   \   000001DC   0028               CMP      R0,#+0
   \   000001DE   06D1               BNE      ??TMR_Task_14
    498              {
    499                TmrStartTimerHardware();
   \   000001E0   0121               MOVS     R1,#+1
   \   000001E2   0020               MOVS     R0,#+0
   \   000001E4   ........           BL       TmrSetMode
    500                timerHardwareIsRunning = TRUE;
   \   000001E8   ....               LDR      R0,??DataTable18_1
   \   000001EA   0121               MOVS     R1,#+1
   \   000001EC   0170               STRB     R1,[R0, #+0]
    501              }
    502          }                                       /* TMR_Task() */
   \                     ??TMR_Task_14:
   \   000001EE   F7BC               POP      {R0-R2,R4-R7}
   \   000001F0   08BC               POP      {R3}
   \   000001F2   1847               BX       R3               ;; return

   \                                 In section .bss, align 1
   \                     ??timerHardwareIsRunning:
   \   00000000                      DS8 1
    503          
    504          /*****************************************************************************
    505          ******************************************************************************/
    506          
    507          /* Enable or disable the timer tmrID
    508             If enable = TRUE timer is active
    509             Else timer is inactive 
    510          */

   \                                 In section .text, align 2, keep-with-next
    511          void TMR_EnableTimer(tmrTimerID_t tmrID)
    512          {    
   \                     TMR_EnableTimer:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    513            unsigned int saveInt;
    514            saveInt = IntDisableAll();
   \   00000004   ........           BL       IntDisableAll
   \   00000008   0500               MOVS     R5,R0
    515            if (TMR_GetTimerStatus(tmrID) == mTmrStatusInactive_c)
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000E   000E               LSRS     R0,R0,#+24
   \   00000010   ........           BL       TMR_GetTimerStatus
   \   00000014   8028               CMP      R0,#+128
   \   00000016   20D1               BNE      ??TMR_EnableTimer_0
    516            {      
    517              IncrementActiveTimerNumber(TMR_GetTimerType(tmrID));    
   \   00000018   2000               MOVS     R0,R4
   \   0000001A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001C   000E               LSRS     R0,R0,#+24
   \   0000001E   ........           BL       TMR_GetTimerType
   \   00000022   C006               LSLS     R0,R0,#+27
   \   00000024   07D5               BPL      ??TMR_EnableTimer_1
   \   00000026   ....               LDR      R0,??DataTable11
   \   00000028   0078               LDRB     R0,[R0, #+0]
   \   0000002A   401C               ADDS     R0,R0,#+1
   \   0000002C   ....               LDR      R1,??DataTable11
   \   0000002E   0870               STRB     R0,[R1, #+0]
   \   00000030   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000032   000E               LSRS     R0,R0,#+24
   \   00000034   06E0               B        ??TMR_EnableTimer_2
   \                     ??TMR_EnableTimer_1:
   \   00000036   ....               LDR      R0,??DataTable11_2
   \   00000038   0078               LDRB     R0,[R0, #+0]
   \   0000003A   401C               ADDS     R0,R0,#+1
   \   0000003C   ....               LDR      R1,??DataTable11_2
   \   0000003E   0870               STRB     R0,[R1, #+0]
   \   00000040   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000042   000E               LSRS     R0,R0,#+24
    518              TMR_SetTimerStatus(tmrID, mTmrStatusReady_c);
   \                     ??TMR_EnableTimer_2:
   \   00000044   4021               MOVS     R1,#+64
   \   00000046   2000               MOVS     R0,R4
   \   00000048   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000004A   000E               LSRS     R0,R0,#+24
   \   0000004C   ........           BL       TMR_SetTimerStatus
    519              TS_SendEvent(mTimerTaskID, mTMR_Event_c);
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   ....               LDR      R0,??DataTable18_2
   \   00000054   0078               LDRB     R0,[R0, #+0]
   \   00000056   ........           BL       TS_SendEvent
    520            }  
    521           IntRestoreAll(saveInt);
   \                     ??TMR_EnableTimer_0:
   \   0000005A   2800               MOVS     R0,R5
   \   0000005C   ........           BL       IntRestoreAll
    522          }
   \   00000060   31BC               POP      {R0,R4,R5}
   \   00000062   08BC               POP      {R3}
   \   00000064   1847               BX       R3               ;; return
    523          
    524          
    525          /*****************************************************************************/
    526          
    527          /*
    528          This function is called by Low Power module; Also this function stops the 
    529          harware timer.
    530          Return: time in millisecond that wasn't counted before entering in sleep  
    531          */

   \                                 In section .text, align 2, keep-with-next
    532          uint16_t TMR_NotCountedTicksBeforeSleep(void)
    533          {
   \                     TMR_NotCountedTicksBeforeSleep:
   \   00000000   80B5               PUSH     {R7,LR}
    534          #if (gTMR_EnableLowPowerTimers_d)  
    535            uint16_t currentTimeInTicks;
    536            
    537            if (!numberOfLowPowerActiveTimers)
   \   00000002   ....               LDR      R0,??DataTable11
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   01D1               BNE      ??TMR_NotCountedTicksBeforeSleep_0
    538              return 0;
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0EE0               B        ??TMR_NotCountedTicksBeforeSleep_1
    539          
    540            TmrReadValue(gTmrNumber_d,&currentTimeInTicks);
   \                     ??TMR_NotCountedTicksBeforeSleep_0:
   \   0000000E   6946               MOV      R1,SP
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   ........           BL       TmrReadValue
    541            TmrStopTimerHardware();
   \   00000016   0021               MOVS     R1,#+0
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   ........           BL       TmrSetMode
    542          
    543           /* The hw timer is stopped but keep timerHardwareIsRunning = TRUE...*/ 
    544           /* The Lpm timers are considered as being in running mode, so that  */
    545           /* not to start the hw timer if a TMR event occurs (this shouldn't happen) */ 
    546               
    547            return  (uint16_t)(currentTimeInTicks - previousTimeInTicks);
   \   0000001E   6846               MOV      R0,SP
   \   00000020   0088               LDRH     R0,[R0, #+0]
   \   00000022   ....               LDR      R1,??DataTable18_3
   \   00000024   0988               LDRH     R1,[R1, #+0]
   \   00000026   401A               SUBS     R0,R0,R1
   \   00000028   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   0000002A   000C               LSRS     R0,R0,#+16
   \                     ??TMR_NotCountedTicksBeforeSleep_1:
   \   0000002C   0ABC               POP      {R1,R3}
   \   0000002E   1847               BX       R3               ;; return
    548          #else  
    549             return 0;
    550          #endif /* #if (gTMR_EnableLowPowerTimers_d) */   
    551          } 
    552          
    553          /*****************************************************************************/
    554          
    555                
    556          /* This function is called by the Low Power Module */
    557          /* each time the MCU wakes up */ 
    558          /* The function make an approximate sync. the active low power timers. */                              

   \                                 In section .text, align 2, keep-with-next
    559          void TMR_SyncLpmTimers(uint32_t sleepDurationTmrTicks)
    560          {
   \                     TMR_SyncLpmTimers:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    561          #if (gTMR_EnableLowPowerTimers_d) 
    562           index_t  timerID;
    563           tmrTimerType_t timerType;
    564          
    565           /* Check if there are low power active timer */
    566           if (!numberOfLowPowerActiveTimers)
   \   00000004   ....               LDR      R0,??DataTable18_4
   \   00000006   0078               LDRB     R0,[R0, #+0]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   44D0               BEQ      ??TMR_SyncLpmTimers_0
    567              return;          
    568          
    569           /* For each timer, detect the timer type and count down the spent duration in sleep */  
    570           for (timerID = 0; timerID < NumberOfElements(maTmrTimerTable); ++timerID) 
   \                     ??TMR_SyncLpmTimers_1:
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   0500               MOVS     R5,R0
   \                     ??TMR_SyncLpmTimers_2:
   \   00000010   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000012   2D0E               LSRS     R5,R5,#+24
   \   00000014   222D               CMP      R5,#+34
   \   00000016   31D2               BCS      ??TMR_SyncLpmTimers_3
    571           {
    572          
    573            /* Detect the timer type and count down the spent duration in sleep */
    574            timerType = TMR_GetTimerType(timerID);
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000001C   000E               LSRS     R0,R0,#+24
   \   0000001E   ........           BL       TMR_GetTimerType
   \   00000022   0600               MOVS     R6,R0
    575            
    576            /* Sync. only the low power timers that are active */
    577            if ( (TMR_GetTimerStatus(timerID) == mTmrStatusActive_c)
    578                  && (IsLowPowerTimer(timerType)) ) 
   \   00000024   2800               MOVS     R0,R5
   \   00000026   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000028   000E               LSRS     R0,R0,#+24
   \   0000002A   ........           BL       TMR_GetTimerStatus
   \   0000002E   2028               CMP      R0,#+32
   \   00000030   22D1               BNE      ??TMR_SyncLpmTimers_4
   \   00000032   F006               LSLS     R0,R6,#+27
   \   00000034   20D5               BPL      ??TMR_SyncLpmTimers_4
    579            {
    580                     /* Timer expired when MCU was in sleep mode??? */
    581                     if( maTmrTimerTable[timerID].remainingTicks > sleepDurationTmrTicks) 
   \   00000036   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000038   2D0E               LSRS     R5,R5,#+24
   \   0000003A   0C20               MOVS     R0,#+12
   \   0000003C   6843               MULS     R0,R5,R0
   \   0000003E   ....               LDR      R1,??DataTable12
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   4068               LDR      R0,[R0, #+4]
   \   00000044   8442               CMP      R4,R0
   \   00000046   0FD2               BCS      ??TMR_SyncLpmTimers_5
    582                     {
    583                       maTmrTimerTable[timerID].remainingTicks -= sleepDurationTmrTicks;
   \   00000048   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000004A   2D0E               LSRS     R5,R5,#+24
   \   0000004C   0C20               MOVS     R0,#+12
   \   0000004E   6843               MULS     R0,R5,R0
   \   00000050   ....               LDR      R1,??DataTable12
   \   00000052   0818               ADDS     R0,R1,R0
   \   00000054   4068               LDR      R0,[R0, #+4]
   \   00000056   001B               SUBS     R0,R0,R4
   \   00000058   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000005A   2D0E               LSRS     R5,R5,#+24
   \   0000005C   0C21               MOVS     R1,#+12
   \   0000005E   6943               MULS     R1,R5,R1
   \   00000060   ....               LDR      R2,??DataTable12
   \   00000062   5118               ADDS     R1,R2,R1
   \   00000064   4860               STR      R0,[R1, #+4]
   \   00000066   07E0               B        ??TMR_SyncLpmTimers_4
    584           
    585                     } 
    586                     else 
    587                     {
    588                       maTmrTimerTable[timerID].remainingTicks = 0;           
   \                     ??TMR_SyncLpmTimers_5:
   \   00000068   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000006A   2D0E               LSRS     R5,R5,#+24
   \   0000006C   0C20               MOVS     R0,#+12
   \   0000006E   6843               MULS     R0,R5,R0
   \   00000070   ....               LDR      R1,??DataTable12
   \   00000072   0818               ADDS     R0,R1,R0
   \   00000074   0021               MOVS     R1,#+0
   \   00000076   4160               STR      R1,[R0, #+4]
    589                     }
    590                  
    591             }
    592          
    593           }/* end for (timerID = 0;.... */
   \                     ??TMR_SyncLpmTimers_4:
   \   00000078   6D1C               ADDS     R5,R5,#+1
   \   0000007A   C9E7               B        ??TMR_SyncLpmTimers_2
    594          
    595           TmrStartTimerHardware();
   \                     ??TMR_SyncLpmTimers_3:
   \   0000007C   0121               MOVS     R1,#+1
   \   0000007E   0020               MOVS     R0,#+0
   \   00000080   ........           BL       TmrSetMode
    596           TmrReadValue(gTmrNumber_d, &previousTimeInTicks);
   \   00000084   ....               LDR      R1,??DataTable18_3
   \   00000086   0020               MOVS     R0,#+0
   \   00000088   ........           BL       TmrReadValue
    597          
    598           TS_SendEvent(mTimerTaskID, mTMR_Event_c);
   \   0000008C   0121               MOVS     R1,#+1
   \   0000008E   ....               LDR      R0,??DataTable18_2
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   ........           BL       TS_SendEvent
    599          #else
    600           (void)sleepDurationTmrTicks;
    601          #endif /* #if (gTMR_EnableLowPowerTimers_d) */ 
    602          }
   \                     ??TMR_SyncLpmTimers_0:
   \   00000096   70BC               POP      {R4-R6}
   \   00000098   08BC               POP      {R3}
   \   0000009A   1847               BX       R3               ;; return
    603          
    604          
    605          
    606          /*****************************************************************************/
    607          
    608          /* Private functions
    609          ******************************************************************************
    610          *****************************************************************************/
    611          
    612          /* Configure the timer registers to work in compare mode, to count repeatedly (roll over)
    613          and register the callbacks to handle interrupts*/

   \                                 In section .text, align 2, keep-with-next
    614          bool_t TMR_SetReg(TmrNumber_t tmrNumber)
    615          {
   \                     TMR_SetReg:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
   \   00000002   0400               MOVS     R4,R0
    616            
    617            TmrConfig_t regConfig;
    618            TmrStatusCtrl_t regStatusCtrl;
    619            TmrComparatorStatusCtrl_t regComStatusCtrl;
    620            
    621            /* Register the callback executed when an interrupt occur */
    622            if(gTmrErrNoError_c != TmrSetCallbackFunction(tmrNumber, gTmrComp1Event_c, &TmrCompEvCallBack))
   \   00000004   ....               LDR      R2,??DataTable18_5
   \   00000006   0021               MOVS     R1,#+0
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000000C   000E               LSRS     R0,R0,#+24
   \   0000000E   ........           BL       TmrSetCallbackFunction
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D0               BEQ      ??TMR_SetReg_0
    623            {
    624              return FALSE;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   59E0               B        ??TMR_SetReg_1
    625            }
    626            /* Don't stat the timer yet */
    627            if (gTmrErrNoError_c != TmrStopTimerHardware()) /*set timer mode no operation*/
   \                     ??TMR_SetReg_0:
   \   0000001A   0021               MOVS     R1,#+0
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   ........           BL       TmrSetMode
   \   00000022   0028               CMP      R0,#+0
   \   00000024   01D0               BEQ      ??TMR_SetReg_2
    628            {
    629              return FALSE;
   \   00000026   0020               MOVS     R0,#+0
   \   00000028   51E0               B        ??TMR_SetReg_1
    630            }
    631            
    632            if(gTmrErrNoError_c != TmrWriteValue(tmrNumber, 0x0000))    /*clear counter*/
   \                     ??TMR_SetReg_2:
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000030   000E               LSRS     R0,R0,#+24
   \   00000032   ........           BL       TmrWriteValue
   \   00000036   0028               CMP      R0,#+0
   \   00000038   01D0               BEQ      ??TMR_SetReg_3
    633            {
    634              return FALSE;
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   47E0               B        ??TMR_SetReg_1
    635            }  
    636            
    637            regStatusCtrl.uintValue = 0x0000;
   \                     ??TMR_SetReg_3:
   \   0000003E   6846               MOV      R0,SP
   \   00000040   0021               MOVS     R1,#+0
   \   00000042   8181               STRH     R1,[R0, #+12]
    638            if (gTmrErrNoError_c != TmrSetStatusControl(tmrNumber, &regStatusCtrl))
   \   00000044   03A9               ADD      R1,SP,#+12
   \   00000046   2000               MOVS     R0,R4
   \   00000048   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   0000004A   000E               LSRS     R0,R0,#+24
   \   0000004C   ........           BL       TmrSetStatusControl
   \   00000050   0028               CMP      R0,#+0
   \   00000052   01D0               BEQ      ??TMR_SetReg_4
    639            {
    640              return FALSE;
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   3AE0               B        ??TMR_SetReg_1
    641            }  
    642            
    643            regComStatusCtrl.uintValue = 0x0000;
   \                     ??TMR_SetReg_4:
   \   00000058   6846               MOV      R0,SP
   \   0000005A   0021               MOVS     R1,#+0
   \   0000005C   0180               STRH     R1,[R0, #+0]
    644            regComStatusCtrl.bitFields.TCF1EN = TRUE; /* Enable Compare 1 interrupt */
   \   0000005E   6846               MOV      R0,SP
   \   00000060   0088               LDRH     R0,[R0, #+0]
   \   00000062   4021               MOVS     R1,#+64
   \   00000064   0143               ORRS     R1,R1,R0
   \   00000066   6846               MOV      R0,SP
   \   00000068   0180               STRH     R1,[R0, #+0]
    645            if (gTmrErrNoError_c != TmrSetCompStatusControl(tmrNumber, &regComStatusCtrl))
   \   0000006A   6946               MOV      R1,SP
   \   0000006C   2000               MOVS     R0,R4
   \   0000006E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000070   000E               LSRS     R0,R0,#+24
   \   00000072   ........           BL       TmrSetCompStatusControl
   \   00000076   0028               CMP      R0,#+0
   \   00000078   01D0               BEQ      ??TMR_SetReg_5
    646            {
    647              return FALSE;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   27E0               B        ??TMR_SetReg_1
    648            }
    649            
    650            SetComp1Val(tmrNumber, 0x0000); /*clear comparator 1 value*/ 
   \                     ??TMR_SetReg_5:
   \   0000007E   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000080   240E               LSRS     R4,R4,#+24
   \   00000082   A007               LSLS     R0,R4,#+30       ;; ZeroExtS R0,R4,#+30,#+30
   \   00000084   800F               LSRS     R0,R0,#+30
   \   00000086   4001               LSLS     R0,R0,#+5
   \   00000088   ....               LDR      R1,??DataTable18  ;; 0x80007000
   \   0000008A   0022               MOVS     R2,#+0
   \   0000008C   4252               STRH     R2,[R0, R1]
    651            regConfig.tmrOutputMode = gTmrAssert_c; 
   \   0000008E   6846               MOV      R0,SP
   \   00000090   0021               MOVS     R1,#+0
   \   00000092   0171               STRB     R1,[R0, #+4]
    652            regConfig.tmrCoInit = FALSE;  /*co-chanel counter/timers can not force a re-initialization of this counter/timer*/
   \   00000094   01A8               ADD      R0,SP,#+4
   \   00000096   0021               MOVS     R1,#+0
   \   00000098   4170               STRB     R1,[R0, #+1]
    653            regConfig.tmrCntDir = FALSE;  /*count-up*/
   \   0000009A   01A8               ADD      R0,SP,#+4
   \   0000009C   0021               MOVS     R1,#+0
   \   0000009E   8170               STRB     R1,[R0, #+2]
    654            regConfig.tmrCntLen = FALSE;  /*rol over */
   \   000000A0   01A8               ADD      R0,SP,#+4
   \   000000A2   0021               MOVS     R1,#+0
   \   000000A4   C170               STRB     R1,[R0, #+3]
    655            regConfig.tmrCntOnce = FALSE;   /*count repeatedly*/
   \   000000A6   01A8               ADD      R0,SP,#+4
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   0171               STRB     R1,[R0, #+4]
    656            regConfig.tmrSecondaryCntSrc = gTmrSecondaryCnt0Input_c;    /*secondary count source not needed*/
   \   000000AC   01A8               ADD      R0,SP,#+4
   \   000000AE   0021               MOVS     R1,#+0
   \   000000B0   4171               STRB     R1,[R0, #+5]
    657            regConfig.tmrPrimaryCntSrc = gTmrPrimaryClkDefault_c;    /*primary count source is IP BUS clock divide by 128 prescaler*/
   \   000000B2   01A8               ADD      R0,SP,#+4
   \   000000B4   0F21               MOVS     R1,#+15
   \   000000B6   8171               STRB     R1,[R0, #+6]
    658            if (gTmrErrNoError_c != TmrSetConfig(tmrNumber, &regConfig))  /*set timer configuration */
   \   000000B8   01A9               ADD      R1,SP,#+4
   \   000000BA   2000               MOVS     R0,R4
   \   000000BC   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000BE   000E               LSRS     R0,R0,#+24
   \   000000C0   ........           BL       TmrSetConfig
   \   000000C4   0028               CMP      R0,#+0
   \   000000C6   01D0               BEQ      ??TMR_SetReg_6
    659            {
    660              return FALSE;
   \   000000C8   0020               MOVS     R0,#+0
   \   000000CA   00E0               B        ??TMR_SetReg_1
    661            }
    662            
    663            return TRUE;
   \                     ??TMR_SetReg_6:
   \   000000CC   0120               MOVS     R0,#+1
   \                     ??TMR_SetReg_1:
   \   000000CE   04B0               ADD      SP,SP,#+16
   \   000000D0   10BC               POP      {R4}
   \   000000D2   08BC               POP      {R3}
   \   000000D4   1847               BX       R3               ;; return
    664          }
    665          
    666          
    667          /* Time from milliseconds in ticks*/

   \                                 In section .text, align 2, keep-with-next
    668          static tmrTimerTicks32_t TmrTicksFromMilliseconds(tmrTimeInMilliseconds_t milliseconds)
    669          {
    670            return (milliseconds * (mClkSourceKhz/gTmrPrescaler_c));
   \                     TmrTicksFromMilliseconds:
   \   00000000   ....               LDR      R1,??DataTable18_6
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   C909               LSRS     R1,R1,#+7
   \   00000006   4843               MULS     R0,R1,R0
   \   00000008   7047               BX       LR               ;; return
    671          }
    672          

   \                                 In section .text, align 2, keep-with-next
    673          static tmrStatus_t TMR_GetTimerStatus
    674          (
    675          tmrTimerID_t timerID
    676          )
    677          {
    678            return maTmrTimerStatusTable[timerID] & mTimerStatusMask_c;
   \                     TMR_GetTimerStatus:
   \   00000000   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000002   000E               LSRS     R0,R0,#+24
   \   00000004   ....               LDR      R1,??DataTable18_7
   \   00000006   095C               LDRB     R1,[R1, R0]
   \   00000008   E020               MOVS     R0,#+224
   \   0000000A   0840               ANDS     R0,R0,R1
   \   0000000C   7047               BX       LR               ;; return
    679          }
    680          

   \                                 In section .text, align 2, keep-with-next
    681          static void TMR_SetTimerStatus
    682          (
    683          tmrTimerID_t timerID, 
    684          tmrStatus_t status
    685          )
    686          {
    687            maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerStatusMask_c) | status;
   \                     TMR_SetTimerStatus:
   \   00000000   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000002   000E               LSRS     R0,R0,#+24
   \   00000004   ....               LDR      R2,??DataTable18_7
   \   00000006   125C               LDRB     R2,[R2, R0]
   \   00000008   D206               LSLS     R2,R2,#+27       ;; ZeroExtS R2,R2,#+27,#+27
   \   0000000A   D20E               LSRS     R2,R2,#+27
   \   0000000C   0A43               ORRS     R2,R2,R1
   \   0000000E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000010   000E               LSRS     R0,R0,#+24
   \   00000012   ....               LDR      R3,??DataTable18_7
   \   00000014   1A54               STRB     R2,[R3, R0]
    688          }
   \   00000016   7047               BX       LR               ;; return
    689          
    690          /*****************************************************************************/
    691          

   \                                 In section .text, align 2, keep-with-next
    692          static tmrTimerType_t TMR_GetTimerType
    693          (
    694          tmrTimerID_t timerID
    695          )
    696          {
    697            return maTmrTimerStatusTable[timerID] & mTimerType_c;
   \                     TMR_GetTimerType:
   \   00000000   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000002   000E               LSRS     R0,R0,#+24
   \   00000004   ....               LDR      R1,??DataTable18_7
   \   00000006   085C               LDRB     R0,[R1, R0]
   \   00000008   C006               LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000000A   C00E               LSRS     R0,R0,#+27
   \   0000000C   7047               BX       LR               ;; return
    698          }
    699          

   \                                 In section .text, align 2, keep-with-next
    700          static void TMR_SetTimerType
    701          (
    702          tmrTimerID_t timerID, 
    703          tmrTimerType_t type
    704          )
    705          {
    706            maTmrTimerStatusTable[timerID] = (maTmrTimerStatusTable[timerID] & ~mTimerType_c) | type;
   \                     TMR_SetTimerType:
   \   00000000   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000002   000E               LSRS     R0,R0,#+24
   \   00000004   ....               LDR      R2,??DataTable18_7
   \   00000006   125C               LDRB     R2,[R2, R0]
   \   00000008   E023               MOVS     R3,#+224
   \   0000000A   1340               ANDS     R3,R3,R2
   \   0000000C   0B43               ORRS     R3,R3,R1
   \   0000000E   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   00000010   000E               LSRS     R0,R0,#+24
   \   00000012   ....               LDR      R2,??DataTable18_7
   \   00000014   1354               STRB     R3,[R2, R0]
    707          }
   \   00000016   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     TMR_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     mTimerTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   FFFF0000           DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     mMaxToCountDown_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     mTicksFor4ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   ........           DC32     mClkSourceKhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   ........           DC32     maTmrTimerStatusTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   ........           DC32     numberOfActiveTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   ........           DC32     maTmrTimerTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   60EA0000           DC32     0xea60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   ........           DC32     numberOfLowPowerActiveTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   ........           DC32     previousTimeInTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   ........           DC32     numberOfActiveTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     maTmrTimerTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   ........           DC32     mMaxToCountDown_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     mTicksFor4ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   00700080           DC32     0x80007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   ........           DC32     ??timerHardwareIsRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   ........           DC32     mTimerTaskID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   ........           DC32     previousTimeInTicks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   ........           DC32     numberOfLowPowerActiveTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   ........           DC32     TmrCompEvCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   ........           DC32     mClkSourceKhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   ........           DC32     maTmrTimerStatusTable
    708          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     TMR_AllocateTimer                   8
     TMR_AreAllTimersOff                 4
     TMR_EnableTimer                    16
     TMR_FreeTimer                       8
     TMR_GetTimerStatus                  0
     TMR_GetTimerType                    0
     TMR_Init                            8
     TMR_IsTimerActive                   8
     TMR_NotCountedTicksBeforeSleep      8
     TMR_NotifyClkChanged               16
     TMR_SetReg                         24
     TMR_SetTimerStatus                  0
     TMR_SetTimerType                    0
     TMR_StartIntervalTimer             16
     TMR_StartLowPowerTimer             24
     TMR_StartMinuteTimer               16
     TMR_StartSecondTimer               16
     TMR_StartSingleShotTimer           16
     TMR_StartTimer                     24
     TMR_StopTimer                      16
     TMR_SyncLpmTimers                  16
     TMR_Task                           32
     TmrCompEvCallBack                   8
     TmrTicksFromMilliseconds            0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     previousTimeInTicks               2
     mMaxToCountDown_c                 2
     mTicksFor4ms                      4
     mClkSourceKhz                     4
     maTmrTimerTable                 408
     maTmrTimerStatusTable            36
     numberOfActiveTimers              1
     numberOfLowPowerActiveTimers      1
     mTimerTaskID                      1
     TMR_Init                         60
     TMR_NotifyClkChanged             38
     TMR_AllocateTimer                50
     TMR_AreAllTimersOff              24
     TMR_FreeTimer                    30
     TmrCompEvCallBack                20
     TMR_IsTimerActive                34
     TMR_StartTimer                  104
     TMR_StartLowPowerTimer           38
     TMR_StartMinuteTimer             36
     TMR_StartSecondTimer             38
     TMR_StartIntervalTimer           30
     TMR_StartSingleShotTimer         30
     TMR_StopTimer                   134
     TMR_Task                        500
     timerHardwareIsRunning            1
     TMR_EnableTimer                 102
     TMR_NotCountedTicksBeforeSleep   48
     TMR_SyncLpmTimers               156
     TMR_SetReg                      214
     TmrTicksFromMilliseconds         10
     TMR_GetTimerStatus               14
     TMR_SetTimerStatus               24
     TMR_GetTimerType                 14
     TMR_SetTimerType                 24
     ??DataTable8                      4
     ??DataTable8_1                    4
     ??DataTable8_2                    4
     ??DataTable8_3                    4
     ??DataTable8_4                    4
     ??DataTable8_5                    4
     ??DataTable8_6                    4
     ??DataTable8_7                    4
     ??DataTable8_8                    4
     ??DataTable9                      4
     ??DataTable11                     4
     ??DataTable11_1                   4
     ??DataTable11_2                   4
     ??DataTable12                     4
     ??DataTable12_1                   4
     ??DataTable17                     4
     ??DataTable18                     4
     ??DataTable18_1                   4
     ??DataTable18_2                   4
     ??DataTable18_3                   4
     ??DataTable18_4                   4
     ??DataTable18_5                   4
     ??DataTable18_6                   4
     ??DataTable18_7                   4
      Others                           2

 
   456 bytes in section .bss
     4 bytes in section .data
 1 870 bytes in section .text
 
 1 868 bytes of CODE memory (+ 2 bytes shared)
   460 bytes of DATA memory

Errors: none
Warnings: none
