###############################################################################
#                                                                             #
#                                                       22/Nov/2015  13:41:46 #
# IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Documents and Settings\Administrator\Desktop\WSN      #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Source\MApp.c                  #
#    Command line =  "C:\Documents and Settings\Administrator\Desktop\WSN     #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Source\MApp.c" -D              #
#                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D       #
#                    gZtcIncluded_d=0 -D gTargetMC1322xNCB=1 --preprocess     #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN     #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\" -lC "C:\Documents and         #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\" -lB "C:\Documents and         #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\" --diag_suppress               #
#                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\Obj\" --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little                  #
#                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program    #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "C:\Documents and Settings\Administrator\Desktop\WSN     #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\MacPhy\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Init\" -I "C:\Documents and    #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Interface\" -I "C:\Documents   #
#                    and Settings\Administrator\Desktop\WSN Project\To        #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Configure\" -I "C:\Documents   #
#                    and Settings\Administrator\Desktop\WSN Project\To        #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\UartUtil\" -I "C:\Documents    #
#                    and Settings\Administrator\Desktop\WSN Project\To        #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Application\Source\" -I "C:\Documents and  #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\TS\Interface\" -I "C:\Documents and    #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\TS\Source\" -I "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\ZTC\Interface\" -I "C:\Documents and   #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\SSM\ZTC\Source\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Interface\" -I "C:\Documents and       #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\LibInterface\" -I "C:\Documents and    #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\Display\" -I "C:\Documents and  #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\Keyboard\" -I "C:\Documents     #
#                    and Settings\Administrator\Desktop\WSN Project\To        #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\NVM\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\TMR\" -I "C:\Documents and      #
#                    Settings\Administrator\Desktop\WSN Project\To            #
#                    use\MyWirelessApp Demo Non Beacon                        #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\PLM\Source\UART\" -I "C:\Program           #
#                    Files\IAR Systems\Embedded Workbench 5.4                 #
#                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On    #
#    List file    =  C:\Documents and Settings\Administrator\Desktop\WSN      #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\List\MApp.lst                        #
#    Object file  =  C:\Documents and Settings\Administrator\Desktop\WSN      #
#                    Project\To use\MyWirelessApp Demo Non Beacon             #
#                    (Coordinator)\MyWirelessApp Demo Non Beacon              #
#                    (Coordinator)\Debug\Obj\MApp.o                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Documents and Settings\Administrator\Desktop\WSN Project\To use\MyWirelessApp Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon (Coordinator)\Application\Source\MApp.c
      1          /*****************************************************************************
      2          *  MyWirelessApp Demo Non Beacon Coordinator application.
      3          *
      4          * (c) Copyright 2008, Freescale, Inc. All rights reserved.
      5          *
      6          *
      7          * No part of this document must be reproduced in any form - including copied,
      8          * transcribed, printed or by any electronic means - without specific written
      9          * permission from Freescale Semiconductor.
     10          *
     11          *****************************************************************************/
     12          
     13          #include "MApp.h"
     14          #include "NVM_Interface.h"
     15          
     16          /************************************************************************************
     17          *************************************************************************************
     18          * Private macros
     19          *************************************************************************************
     20          ************************************************************************************/
     21          
     22          /* If there are too many pending packets to be send over the air, */
     23          /* receive mMaxKeysToReceive_c chars. */
     24          /* The chars will be send over the air when there are no pending packets*/
     25          #define mMaxKeysToReceive_c 32
     26          
     27          /************************************************************************************
     28          *************************************************************************************
     29          * Private prototypes
     30          *************************************************************************************
     31          ************************************************************************************/
     32          
     33          /* Forward declarations of helper functions */
     34          static void    UartRxCallBack(void);
     35          static uint8_t App_StartScan(uint8_t scanType);
     36          static void    App_HandleScanEdConfirm(nwkMessage_t *pMsg);
     37          static uint8_t App_StartCoordinator(void);
     38          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
     39          static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn);
     40          static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
     41          static void    App_TransmitUartData(void);
     42          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
     43          static void    App_HandleKeys(key_event_t events) ;
     44          
     45          /************************************************************************************
     46          *************************************************************************************
     47          * Private type definitions
     48          *************************************************************************************
     49          ************************************************************************************/
     50          
     51          
     52          /************************************************************************************
     53          *************************************************************************************
     54          * Private memory declarations
     55          *************************************************************************************
     56          ************************************************************************************/
     57          
     58          /* The short address and PAN ID of the coordinator*/

   \                                 In section .rodata, align 2
     59          static const uint8_t maShortAddress[2] = { (mDefaultValueOfShortAddress_c & 0xff), (mDefaultValueOfShortAddress_c >> 8)};
   \                     maShortAddress:
   \   00000000   1900               DC8 25, 0

   \                                 In section .rodata, align 2
     60          static const uint8_t maPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   \                     maPanId:
   \   00000000   0500               DC8 5, 0
     61          
     62          
     63          /* The current logical channel (frequency band) */

   \                                 In section .bss, align 1
     64          static uint8_t mLogicalChannel;
   \                     mLogicalChannel:
   \   00000000                      DS8 1
     65          
     66          /* These byte arrays stores an associated
     67             devices long and short addresses. */

   \                                 In section .bss, align 2
     68          static uint8_t maDeviceShortAddress[2];
   \                     maDeviceShortAddress:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     69          static uint8_t maDeviceLongAddress[8];
   \                     maDeviceLongAddress:
   \   00000000                      DS8 8
     70          
     71          /* Data request packet for sending UART input to the coordinator */

   \                                 In section .bss, align 4
     72          static nwkToMcpsMessage_t *mpPacket;
   \                     mpPacket:
   \   00000000                      DS8 4
     73          
     74          /* The MSDU handle is a unique data packet identifier */

   \                                 In section .bss, align 1
     75          static uint8_t mMsduHandle;
   \                     mMsduHandle:
   \   00000000                      DS8 1
     76          
     77          /* Number of pending data packets */

   \                                 In section .bss, align 1
     78          static uint8_t mcPendingPackets;
   \                     mcPendingPackets:
   \   00000000                      DS8 1
     79          
     80          /* Application input queues */

   \                                 In section .bss, align 4
     81          static anchor_t mMlmeNwkInputQueue;
   \                     mMlmeNwkInputQueue:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     82          static anchor_t mMcpsNwkInputQueue;
   \                     mMcpsNwkInputQueue:
   \   00000000                      DS8 8
     83          
     84          /************************************************************************************
     85          *************************************************************************************
     86          * Public memory declarations
     87          *************************************************************************************
     88          ************************************************************************************/
     89          
     90          /* The current state of the applications state machine */

   \                                 In section .bss, align 1
     91          uint8_t gState;
   \                     gState:
   \   00000000                      DS8 1
     92          
     93          /* This data set contains application variables to be preserved across resets */

   \                                 In section .rodata, align 4
     94          NvDataItemDescription_t const gaNvAppDataSet[] = {
   \                     gaNvAppDataSet:
   \   00000000   00000000           DC32 0H
   \   00000004   0000               DC16 0
   \   00000006   0000               DC8 0, 0
     95            {NULL, 0}       /* Required end-of-table marker. */
     96          };
     97          
     98          /************************************************************************************
     99          *************************************************************************************
    100          * Public functions
    101          *************************************************************************************
    102          ************************************************************************************/
    103          
    104          void DeepSleepWakeupStackProc(void);
    105          
    106          /*****************************************************************************
    107          * Initialization function for the App Task. This is called during
    108          * initialization and should contain any application specific initialization
    109          * (ie. hardware initialization/setup, table initialization, power up
    110          * notificaiton.
    111          *
    112          * Interface assumptions: None
    113          *
    114          * Return value: None
    115          *
    116          *****************************************************************************/
    117          

   \                                 In section .text, align 2, keep-with-next
    118          void MApp_init(void)
    119          { 
   \                     MApp_init:
   \   00000000   80B5               PUSH     {R7,LR}
    120            
    121            /* The initial application state */
    122            gState = stateInit;
   \   00000002   ....               LDR      R0,??DataTable0
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0170               STRB     R1,[R0, #+0]
    123            /* Reset number of pending packets */
    124            mcPendingPackets = 0;    
   \   00000008   ....               LDR      R0,??DataTable0_1
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   0170               STRB     R1,[R0, #+0]
    125          
    126            /* Initialize the MAC 802.15.4 extended address */
    127            Init_MacExtendedAddress();
   \   0000000E   ........           BL       Init_MacExtendedAddress
    128            /* register keyboard callback function */
    129            KBD_Init(App_HandleKeys);
   \   00000012   ....               LDR      R0,??DataTable1
   \   00000014   ........           BL       KBD_Init
    130            /* initialize LCD Module */
    131            LCD_Init();
   \   00000018   ........           BL       LCD_Init
    132            /* initialize LED Module */
    133            LED_Init();
   \   0000001C   ........           BL       LED_Init
    134            /* Initialize the UART so that we can print out status messages */
    135            UartX_SetBaud(gUartDefaultBaud_c);
   \   00000020   9620               MOVS     R0,#+150
   \   00000022   C001               LSLS     R0,R0,#+7        ;; #+19200
   \   00000024   ........           BL       Uart1_SetBaud
    136            UartX_SetRxCallBack(UartRxCallBack);
   \   00000028   ....               LDR      R0,??DataTable1_1
   \   0000002A   ........           BL       Uart1_SetRxCallBack
    137            /* Prepare input queues.*/
    138            MSG_InitQueue(&mMlmeNwkInputQueue); 
   \   0000002E   ....               LDR      R0,??DataTable1_2
   \   00000030   ........           BL       List_ClearAnchor
    139            MSG_InitQueue(&mMcpsNwkInputQueue);
   \   00000034   ....               LDR      R0,??DataTable1_3
   \   00000036   ........           BL       List_ClearAnchor
    140            /* Enable MCU interrupts */
    141            IntEnableAll();
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   ........           BL       IntRestoreAll
    142            /*signal app ready*/  
    143            Led1Flashing();
   \   00000040   0120               MOVS     R0,#+1
   \   00000042   ........           BL       LED_StartFlash
    144            Led2Flashing();
   \   00000046   0220               MOVS     R0,#+2
   \   00000048   ........           BL       LED_StartFlash
    145            Led3Flashing();
   \   0000004C   0420               MOVS     R0,#+4
   \   0000004E   ........           BL       LED_StartFlash
    146            Led4Flashing();
   \   00000052   0820               MOVS     R0,#+8
   \   00000054   ........           BL       LED_StartFlash
    147              
    148            UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
   \   00000058   0121               MOVS     R1,#+1
   \   0000005A   ....               LDR      R0,??DataTable2
   \   0000005C   ........           BL       UartUtil_Print
    149            LCD_ClearDisplay();
   \   00000060   ........           BL       LCD_ClearDisplay
    150            LCD_WriteString(1,"Press any key");
   \   00000064   ....               LDR      R1,??DataTable2_1
   \   00000066   0120               MOVS     R0,#+1
   \   00000068   ........           BL       LCD_WriteString
    151            LCD_WriteString(2,"to start.");
   \   0000006C   ....               LDR      R1,??DataTable3
   \   0000006E   0220               MOVS     R0,#+2
   \   00000070   ........           BL       LCD_WriteString
    152          }
   \   00000074   09BC               POP      {R0,R3}
   \   00000076   1847               BX       R3               ;; return
    153          
    154          /*****************************************************************************
    155          *Mac Application Task event processor.  This function is called to
    156          * process all events for the task. Events include timers, messages and any
    157          * other user defined events
    158          *
    159          * Interface assumptions: None
    160          *
    161          * Return value: None
    162          *****************************************************************************/
    163          /* The Application Task */

   \                                 In section .text, align 2, keep-with-next
    164          void AppTask(event_t events)
    165          {
   \                     AppTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    166            /* Pointer for storing the messages from MLME */
    167            void *pMsgIn;
    168            /* Stores the error/success code returned by some functions. */
    169            uint8_t ret;  
    170            pMsgIn = NULL;
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   0400               MOVS     R4,R0
    171            
    172            /* Dequeue the MLME message */
    173            if (events & gAppEvtMessageFromMLME_c)
   \   00000008   7007               LSLS     R0,R6,#+29
   \   0000000A   1DD5               BPL      ??AppTask_0
    174            {
    175              /* Get the message from MLME */
    176              pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
   \   0000000C   ....               LDR      R0,??DataTable1_2
   \   0000000E   ........           BL       List_RemoveHead
   \   00000012   0400               MOVS     R4,R0
    177              
    178              /* Any time a beacon might arrive. Always handle the beacon frame first */
    179              if (pMsgIn)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   17D0               BEQ      ??AppTask_0
    180              {               
    181                ret = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
   \   00000018   0421               MOVS     R1,#+4
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       App_WaitMsg
   \   00000020   0500               MOVS     R5,R0
    182                if(ret == errorNoError)
   \   00000022   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000024   2D0E               LSRS     R5,R5,#+24
   \   00000026   002D               CMP      R5,#+0
   \   00000028   0ED1               BNE      ??AppTask_0
    183                {
    184                  /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
    185                  /* ALSO the application can use the beacon payload.*/
    186                  MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   1030               ADDS     R0,R0,#+16
   \   0000002E   ........           BL       __aeabi_uread4
   \   00000032   ........           BL       MM_Free
   \   00000036   2100               MOVS     R1,R4
   \   00000038   1031               ADDS     R1,R1,#+16
   \   0000003A   0020               MOVS     R0,#+0
   \   0000003C   ........           BL       __aeabi_uwrite4
    187                  UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   ....               LDR      R0,??DataTable3_1
   \   00000044   ........           BL       UartUtil_Print
    188                }
    189              }
    190            }
    191            /* The application state machine */
    192            switch(gState)
   \                     ??AppTask_0:
   \   00000048   ....               LDR      R0,??DataTable3_2
   \   0000004A   0078               LDRB     R0,[R0, #+0]
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   09D0               BEQ      ??AppTask_1
   \   00000050   0228               CMP      R0,#+2
   \   00000052   2FD0               BEQ      ??AppTask_2
   \   00000054   13D3               BCC      ??AppTask_3
   \   00000056   0428               CMP      R0,#+4
   \   00000058   69D0               BEQ      ??AppTask_4
   \   0000005A   44D3               BCC      ??AppTask_5
   \   0000005C   0528               CMP      R0,#+5
   \   0000005E   00D1               BNE      .+4
   \   00000060   9BE0               B        ??AppTask_6
   \   00000062   A6E0               B        ??AppTask_7
    193            {
    194            case stateInit:    
    195              /* Print a welcome message to the UART */
    196              UartUtil_Print("MyWirelessApp Demo Non Beacon Coordinator application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
   \                     ??AppTask_1:
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   ....               LDR      R0,??DataTable3_3
   \   00000068   ........           BL       UartUtil_Print
    197              /* Goto Energy Detection state. */
    198              gState = stateScanEdStart;
   \   0000006C   ....               LDR      R0,??DataTable3_2
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   0170               STRB     R1,[R0, #+0]
    199              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   00000072   0121               MOVS     R1,#+1
   \   00000074   ....               LDR      R0,??DataTable4
   \   00000076   0078               LDRB     R0,[R0, #+0]
   \   00000078   ........           BL       TS_SendEvent
   \   0000007C   99E0               B        ??AppTask_7
    200              break;
    201              
    202            case stateScanEdStart:
    203              /* Start the Energy Detection scan, and goto wait for confirm state. */
    204              UartUtil_Print("Initiating the Energy Detection Scan\n\r", gAllowToBlock_d);
   \                     ??AppTask_3:
   \   0000007E   0121               MOVS     R1,#+1
   \   00000080   ....               LDR      R0,??DataTable3_4
   \   00000082   ........           BL       UartUtil_Print
    205              /*Print the message on the LCD also*/
    206              LCD_ClearDisplay();
   \   00000086   ........           BL       LCD_ClearDisplay
    207              LCD_WriteString(1,"Starting Energy");
   \   0000008A   ....               LDR      R1,??DataTable3_5
   \   0000008C   0120               MOVS     R0,#+1
   \   0000008E   ........           BL       LCD_WriteString
    208              LCD_WriteString(2,"Detection Scan");  
   \   00000092   ....               LDR      R1,??DataTable3_6
   \   00000094   0220               MOVS     R0,#+2
   \   00000096   ........           BL       LCD_WriteString
    209              ret = App_StartScan(gScanModeED_c);
   \   0000009A   0020               MOVS     R0,#+0
   \   0000009C   ........           BL       App_StartScan
   \   000000A0   0500               MOVS     R5,R0
    210              if(ret == errorNoError)
   \   000000A2   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000A4   2D0E               LSRS     R5,R5,#+24
   \   000000A6   002D               CMP      R5,#+0
   \   000000A8   00D0               BEQ      .+4
   \   000000AA   82E0               B        ??AppTask_7
    211              {
    212                gState = stateScanEdWaitConfirm;
   \   000000AC   ....               LDR      R0,??DataTable3_2
   \   000000AE   0221               MOVS     R1,#+2
   \   000000B0   0170               STRB     R1,[R0, #+0]
   \   000000B2   7EE0               B        ??AppTask_7
    213              }
    214              break;
    215              
    216            case stateScanEdWaitConfirm:
    217              /* Stay in this state until the MLME Scan confirm message arrives,
    218                 and has been processed. Then goto Start Coordinator state. */
    219              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_2:
   \   000000B4   7007               LSLS     R0,R6,#+29
   \   000000B6   7CD5               BPL      ??AppTask_7
    220              {
    221                if (pMsgIn)
   \   000000B8   002C               CMP      R4,#+0
   \   000000BA   7AD0               BEQ      ??AppTask_7
    222                {
    223                  ret = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
   \   000000BC   0B21               MOVS     R1,#+11
   \   000000BE   2000               MOVS     R0,R4
   \   000000C0   ........           BL       App_WaitMsg
   \   000000C4   0500               MOVS     R5,R0
    224                  if(ret == errorNoError)
   \   000000C6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000C8   2D0E               LSRS     R5,R5,#+24
   \   000000CA   002D               CMP      R5,#+0
   \   000000CC   71D1               BNE      ??AppTask_7
    225                  {
    226                    /* Process the ED scan confirm. The logical
    227                       channel is selected by this function. */
    228                    App_HandleScanEdConfirm(pMsgIn);
   \   000000CE   2000               MOVS     R0,R4
   \   000000D0   ........           BL       App_HandleScanEdConfirm
    229                    /* Go to the Start Coordinator state */
    230                    gState = stateStartCoordinator;
   \   000000D4   ....               LDR      R0,??DataTable3_2
   \   000000D6   0321               MOVS     R1,#+3
   \   000000D8   0170               STRB     R1,[R0, #+0]
    231                    TS_SendEvent(gAppTaskID_c, gAppEvtStartCoordinator_c);
   \   000000DA   1021               MOVS     R1,#+16
   \   000000DC   ....               LDR      R0,??DataTable4
   \   000000DE   0078               LDRB     R0,[R0, #+0]
   \   000000E0   ........           BL       TS_SendEvent
   \   000000E4   65E0               B        ??AppTask_7
    232                  }
    233                }      
    234              }        
    235              break;
    236              
    237          
    238            case stateStartCoordinator:
    239              if (events & gAppEvtStartCoordinator_c)
   \                     ??AppTask_5:
   \   000000E6   F006               LSLS     R0,R6,#+27
   \   000000E8   63D5               BPL      ??AppTask_7
    240              {
    241                /* Start up as a PAN Coordinator on the selected channel. */
    242                UartUtil_Print("\n\rStarting as PAN coordinator on channel 0x", gAllowToBlock_d);
   \   000000EA   0121               MOVS     R1,#+1
   \   000000EC   ....               LDR      R0,??DataTable4_1
   \   000000EE   ........           BL       UartUtil_Print
    243                UartUtil_PrintHex(&mLogicalChannel, 1, FALSE);
   \   000000F2   0022               MOVS     R2,#+0
   \   000000F4   0121               MOVS     R1,#+1
   \   000000F6   ....               LDR      R0,??DataTable4_2
   \   000000F8   ........           BL       UartUtil_PrintHex
    244                UartUtil_Print("\n\r", gAllowToBlock_d);
   \   000000FC   0121               MOVS     R1,#+1
   \   000000FE   ....               ADR      R0,??DataTable4_3  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000100   ........           BL       UartUtil_Print
    245                /*print a message on the LCD also*/
    246                LCD_ClearDisplay();
   \   00000104   ........           BL       LCD_ClearDisplay
    247                LCD_WriteString(1,"Starting");
   \   00000108   ....               LDR      R1,??DataTable4_4
   \   0000010A   0120               MOVS     R0,#+1
   \   0000010C   ........           BL       LCD_WriteString
    248                LCD_WriteString(2,"PAN coordinator");    
   \   00000110   ....               LDR      R1,??DataTable4_5
   \   00000112   0220               MOVS     R0,#+2
   \   00000114   ........           BL       LCD_WriteString
    249              
    250                ret = App_StartCoordinator();
   \   00000118   ........           BL       App_StartCoordinator
   \   0000011C   0500               MOVS     R5,R0
    251                if(ret == errorNoError)
   \   0000011E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000120   2D0E               LSRS     R5,R5,#+24
   \   00000122   002D               CMP      R5,#+0
   \   00000124   45D1               BNE      ??AppTask_7
    252                {
    253                  /* If the Start request was sent successfully to
    254                     the MLME, then goto Wait for confirm state. */
    255                  gState = stateStartCoordinatorWaitConfirm;
   \   00000126   ....               LDR      R0,??DataTable3_2
   \   00000128   0421               MOVS     R1,#+4
   \   0000012A   0170               STRB     R1,[R0, #+0]
   \   0000012C   41E0               B        ??AppTask_7
    256                }
    257              }
    258              break; 
    259          
    260            case stateStartCoordinatorWaitConfirm:
    261              /* Stay in this state until the Start confirm message
    262                     arrives, and then goto the Listen state. */
    263              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_4:
   \   0000012E   7007               LSLS     R0,R6,#+29
   \   00000130   3FD5               BPL      ??AppTask_7
    264              {
    265                if (pMsgIn)
   \   00000132   002C               CMP      R4,#+0
   \   00000134   3DD0               BEQ      ??AppTask_7
    266                {        
    267                  ret = App_WaitMsg(pMsgIn, gNwkStartCnf_c);
   \   00000136   0E21               MOVS     R1,#+14
   \   00000138   2000               MOVS     R0,R4
   \   0000013A   ........           BL       App_WaitMsg
   \   0000013E   0500               MOVS     R5,R0
    268                  if(ret == errorNoError)
   \   00000140   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000142   2D0E               LSRS     R5,R5,#+24
   \   00000144   002D               CMP      R5,#+0
   \   00000146   34D1               BNE      ??AppTask_7
    269                  {
    270                    UartUtil_Print("Started the coordinator with PAN ID 0x", gAllowToBlock_d);
   \   00000148   0121               MOVS     R1,#+1
   \   0000014A   ....               LDR      R0,??DataTable4_6
   \   0000014C   ........           BL       UartUtil_Print
    271                    UartUtil_PrintHex((uint8_t *)maPanId, 2, 0);
   \   00000150   0022               MOVS     R2,#+0
   \   00000152   0221               MOVS     R1,#+2
   \   00000154   ....               LDR      R0,??DataTable5
   \   00000156   ........           BL       UartUtil_PrintHex
    272                    UartUtil_Print(", and short address 0x", gAllowToBlock_d);
   \   0000015A   0121               MOVS     R1,#+1
   \   0000015C   ....               LDR      R0,??DataTable4_7
   \   0000015E   ........           BL       UartUtil_Print
    273                    UartUtil_PrintHex((uint8_t *)maShortAddress, 2, 0);
   \   00000162   0022               MOVS     R2,#+0
   \   00000164   0221               MOVS     R1,#+2
   \   00000166   ....               LDR      R0,??DataTable5_1
   \   00000168   ........           BL       UartUtil_PrintHex
    274                    UartUtil_Print(".\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
   \   0000016C   0121               MOVS     R1,#+1
   \   0000016E   ....               LDR      R0,??DataTable5_2
   \   00000170   ........           BL       UartUtil_Print
    275                    /*print a message on the LCD also*/
    276                    LCD_ClearDisplay();
   \   00000174   ........           BL       LCD_ClearDisplay
    277                    LCD_WriteString(1,"Ready to send");
   \   00000178   ....               LDR      R1,??DataTable5_3
   \   0000017A   0120               MOVS     R0,#+1
   \   0000017C   ........           BL       LCD_WriteString
    278                    LCD_WriteString(2,"and receive data");    
   \   00000180   ....               LDR      R1,??DataTable5_4
   \   00000182   0220               MOVS     R0,#+2
   \   00000184   ........           BL       LCD_WriteString
    279                    gState = stateListen;
   \   00000188   ....               LDR      R0,??DataTable3_2
   \   0000018A   0521               MOVS     R1,#+5
   \   0000018C   0170               STRB     R1,[R0, #+0]
    280                    TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
   \   0000018E   0121               MOVS     R1,#+1
   \   00000190   ....               LDR      R0,??DataTable4
   \   00000192   0078               LDRB     R0,[R0, #+0]
   \   00000194   ........           BL       TS_SendEvent
   \   00000198   0BE0               B        ??AppTask_7
    281                  }
    282                }
    283              }
    284              break; 
    285              
    286            case stateListen:
    287              /* Stay in this state forever. 
    288                 Transmit the data received on UART */
    289              if (events & gAppEvtMessageFromMLME_c)
   \                     ??AppTask_6:
   \   0000019A   7007               LSLS     R0,R6,#+29
   \   0000019C   05D5               BPL      ??AppTask_8
    290              {
    291                /* Get the message from MLME */
    292                if (pMsgIn)
   \   0000019E   002C               CMP      R4,#+0
   \   000001A0   03D0               BEQ      ??AppTask_8
    293                {      
    294                  /* Process it */
    295                  ret = App_HandleMlmeInput(pMsgIn);
   \   000001A2   2000               MOVS     R0,R4
   \   000001A4   ........           BL       App_HandleMlmeInput
   \   000001A8   0500               MOVS     R5,R0
    296                  /* Messages from the MLME must always be freed. */
    297                }
    298              }
    299          
    300              if (events & gAppEvtRxFromUart_c)
   \                     ??AppTask_8:
   \   000001AA   B007               LSLS     R0,R6,#+30
   \   000001AC   01D5               BPL      ??AppTask_7
    301              {      
    302                /* get byte from UART */
    303                App_TransmitUartData();
   \   000001AE   ........           BL       App_TransmitUartData
    304              }  
    305              break;
    306            }
    307            
    308            if (pMsgIn)
   \                     ??AppTask_7:
   \   000001B2   002C               CMP      R4,#+0
   \   000001B4   04D0               BEQ      ??AppTask_9
    309            {
    310              /* Messages must always be freed. */ 
    311              MSG_Free(pMsgIn);
   \   000001B6   2000               MOVS     R0,R4
   \   000001B8   ........           BL       MM_Free
   \   000001BC   0020               MOVS     R0,#+0
   \   000001BE   0400               MOVS     R4,R0
    312            }
    313            
    314            if (events & gAppEvtMessageFromMCPS_c)
   \                     ??AppTask_9:
   \   000001C0   3007               LSLS     R0,R6,#+28
   \   000001C2   0DD5               BPL      ??AppTask_10
    315            {      
    316               /* Get the message from MCPS */
    317              pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
   \   000001C4   ....               LDR      R0,??DataTable1_3
   \   000001C6   ........           BL       List_RemoveHead
   \   000001CA   0400               MOVS     R4,R0
    318              if (pMsgIn)
   \   000001CC   002C               CMP      R4,#+0
   \   000001CE   07D0               BEQ      ??AppTask_10
    319              {
    320                /* Process it */
    321                App_HandleMcpsInput(pMsgIn);
   \   000001D0   2000               MOVS     R0,R4
   \   000001D2   ........           BL       App_HandleMcpsInput
    322                /* Messages from the MCPS must always be freed. */
    323                MSG_Free(pMsgIn);
   \   000001D6   2000               MOVS     R0,R4
   \   000001D8   ........           BL       MM_Free
   \   000001DC   0020               MOVS     R0,#+0
   \   000001DE   0400               MOVS     R4,R0
    324              }
    325            }  
    326            
    327            
    328            /* Check for pending messages in the Queue */ 
    329            if(MSG_Pending(&mMcpsNwkInputQueue))
   \                     ??AppTask_10:
   \   000001E0   ....               LDR      R0,??DataTable1_3
   \   000001E2   0068               LDR      R0,[R0, #+0]
   \   000001E4   0028               CMP      R0,#+0
   \   000001E6   04D0               BEQ      ??AppTask_11
    330              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   000001E8   0821               MOVS     R1,#+8
   \   000001EA   ....               LDR      R0,??DataTable4
   \   000001EC   0078               LDRB     R0,[R0, #+0]
   \   000001EE   ........           BL       TS_SendEvent
    331            if(MSG_Pending(&mMlmeNwkInputQueue))
   \                     ??AppTask_11:
   \   000001F2   ....               LDR      R0,??DataTable1_2
   \   000001F4   0068               LDR      R0,[R0, #+0]
   \   000001F6   0028               CMP      R0,#+0
   \   000001F8   04D0               BEQ      ??AppTask_12
    332              TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
   \   000001FA   0421               MOVS     R1,#+4
   \   000001FC   ....               LDR      R0,??DataTable4
   \   000001FE   0078               LDRB     R0,[R0, #+0]
   \   00000200   ........           BL       TS_SendEvent
    333          }
   \                     ??AppTask_12:
   \   00000204   70BC               POP      {R4-R6}
   \   00000206   08BC               POP      {R3}
   \   00000208   1847               BX       R3               ;; return
    334          
    335          
    336          
    337          /************************************************************************************
    338          *************************************************************************************
    339          * Private functions
    340          *************************************************************************************
    341          ************************************************************************************/
    342          
    343          /*****************************************************************************
    344          * UartRxCallBack
    345          *
    346          * This callback is triggered when a new byte is received over the UART
    347          *
    348          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    349          static void UartRxCallBack(void) 
    350          {
   \                     UartRxCallBack:
   \   00000000   80B5               PUSH     {R7,LR}
    351            uint8_t pressedKey;
    352          	if(stateListen == gState){
   \   00000002   ....               LDR      R0,??DataTable3_2
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0528               CMP      R0,#+5
   \   00000008   05D1               BNE      ??UartRxCallBack_0
    353              TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   ....               LDR      R0,??DataTable4
   \   0000000E   0078               LDRB     R0,[R0, #+0]
   \   00000010   ........           BL       TS_SendEvent
   \   00000014   02E0               B        ??UartRxCallBack_1
    354            }else{
    355          	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
   \                     ??UartRxCallBack_0:
   \   00000016   6846               MOV      R0,SP
   \   00000018   ........           BL       Uart1_GetByteFromRxBuffer
    356            }
    357          }
   \                     ??UartRxCallBack_1:
   \   0000001C   09BC               POP      {R0,R3}
   \   0000001E   1847               BX       R3               ;; return
    358          
    359          /******************************************************************************
    360          * The App_StartScan(scanType) function will start the scan process of the
    361          * specified type in the MAC. This is accomplished by allocating a MAC message,
    362          * which is then assigned the desired scan parameters and sent to the MLME
    363          * service access point.
    364          * The function may return either of the following values:
    365          *   errorNoError:          The Scan message was sent successfully.
    366          *   errorInvalidParameter: The MLME service access point rejected the
    367          *                          message due to an invalid parameter.
    368          *   errorAllocFailed:      A message buffer could not be allocated.
    369          *
    370          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          static uint8_t App_StartScan(uint8_t scanType)
    372          {
   \                     App_StartScan:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    373            mlmeMessage_t *pMsg;
    374            mlmeScanReq_t *pScanReq;
    375          
    376            UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   ....               LDR      R0,??DataTable7
   \   00000008   ........           BL       UartUtil_Print
    377          
    378            /* Allocate a message for the MLME (We should check for NULL). */
    379            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000C   0F20               MOVS     R0,#+15
   \   0000000E   ........           BL       MM_Alloc
   \   00000012   0400               MOVS     R4,R0
    380            if(pMsg != NULL)
   \   00000014   002C               CMP      R4,#+0
   \   00000016   20D0               BEQ      ??App_StartScan_0
    381            {
    382              /* This is a MLME-SCAN.req command */
    383              pMsg->msgType = gMlmeScanReq_c;
   \   00000018   0820               MOVS     R0,#+8
   \   0000001A   2070               STRB     R0,[R4, #+0]
    384              /* Create the Scan request message data. */
    385              pScanReq = &pMsg->msgData.scanReq;
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   0500               MOVS     R5,R0
    386              /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
    387              pScanReq->scanType = scanType;
   \   00000022   2E70               STRB     R6,[R5, #+0]
    388              /* ChannelsToScan & 0xFF - LSB, always 0x00 */
    389              pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   6870               STRB     R0,[R5, #+1]
    390              /* ChannelsToScan>>8 & 0xFF  */
    391              pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
   \   00000028   8020               MOVS     R0,#+128
   \   0000002A   A870               STRB     R0,[R5, #+2]
    392              /* ChannelsToScan>>16 & 0xFF  */
    393              pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   E870               STRB     R0,[R5, #+3]
    394              /* ChannelsToScan>>24 & 0xFF - MSB */
    395              pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   2871               STRB     R0,[R5, #+4]
    396              /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
    397                 A scan duration of 3 on 16 channels approximately takes 2 secs. */
    398              pScanReq->scanDuration = 3;
   \   00000034   0320               MOVS     R0,#+3
   \   00000036   6871               STRB     R0,[R5, #+5]
    399          #ifdef gMAC2006_d
    400          	/* Don't use security */
    401          	pScanReq->securityLevel = 0;
    402          #endif //gMAC2006_d	
    403              
    404              /* Send the Scan request to the MLME. */
    405              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   00000038   2000               MOVS     R0,R4
   \   0000003A   ........           BL       NWK_MLME_SapHandler
   \   0000003E   0028               CMP      R0,#+0
   \   00000040   05D1               BNE      ??App_StartScan_1
    406              {
    407                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000042   0121               MOVS     R1,#+1
   \   00000044   ....               LDR      R0,??DataTable8
   \   00000046   ........           BL       UartUtil_Print
    408                return errorNoError;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   0AE0               B        ??App_StartScan_2
    409              }
    410              else
    411              {
    412                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_1:
   \   0000004E   0121               MOVS     R1,#+1
   \   00000050   ....               LDR      R0,??DataTable8_1
   \   00000052   ........           BL       UartUtil_Print
    413                return errorInvalidParameter;
   \   00000056   0520               MOVS     R0,#+5
   \   00000058   04E0               B        ??App_StartScan_2
    414              }
    415            }
    416            else
    417            {
    418              /* Allocation of a message buffer failed. */
    419              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_StartScan_0:
   \   0000005A   0121               MOVS     R1,#+1
   \   0000005C   ....               LDR      R0,??DataTable8_2
   \   0000005E   ........           BL       UartUtil_Print
    420              return errorAllocFailed;
   \   00000062   0420               MOVS     R0,#+4
   \                     ??App_StartScan_2:
   \   00000064   70BC               POP      {R4-R6}
   \   00000066   08BC               POP      {R3}
   \   00000068   1847               BX       R3               ;; return
    421            }
    422          }
    423          
    424          
    425          /******************************************************************************
    426          * The App_HandleScanEdConfirm(nwkMessage_t *pMsg) function will handle the
    427          * ED scan confirm message received from the MLME when the ED scan has completed.
    428          * The message contains the ED scan result list. This function will search the
    429          * list in order to select the logical channel with the least energy. The
    430          * selected channel is stored in the global variable called 'mLogicalChannel'.
    431          *
    432          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          static void App_HandleScanEdConfirm(nwkMessage_t *pMsg)
    434          {  
   \                     App_HandleScanEdConfirm:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
    435            uint8_t n, minEnergy;
    436            uint8_t *pEdList;
    437            uint8_t ChannelMask;
    438          
    439            UartUtil_Print("Received the MLME-Scan Confirm message from the MAC\n\r", gAllowToBlock_d);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ....               LDR      R0,??DataTable8_3
   \   00000006   ........           BL       UartUtil_Print
    440              
    441            /* Get a pointer to the energy detect results */
    442            pEdList = pMsg->msgData.scanCnf.resList.pEnergyDetectList;
   \   0000000A   0098               LDR      R0,[SP, #+0]
   \   0000000C   0830               ADDS     R0,R0,#+8
   \   0000000E   ........           BL       __aeabi_uread4
   \   00000012   0500               MOVS     R5,R0
    443            
    444            /* Set the minimum energy to a large value */
    445            minEnergy = 0xFF;
   \   00000014   FF20               MOVS     R0,#+255
   \   00000016   0600               MOVS     R6,R0
    446          
    447            /* Select default channel */
    448            mLogicalChannel = 11;
   \   00000018   ....               LDR      R0,??DataTable4_2
   \   0000001A   0B21               MOVS     R1,#+11
   \   0000001C   0170               STRB     R1,[R0, #+0]
    449           
    450            /* Search for the channel with least energy */
    451            for(n=0; n<16; n++)
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   0400               MOVS     R4,R0
   \                     ??App_HandleScanEdConfirm_0:
   \   00000022   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000024   240E               LSRS     R4,R4,#+24
   \   00000026   102C               CMP      R4,#+16
   \   00000028   18D2               BCS      ??App_HandleScanEdConfirm_1
    452            {
    453              ChannelMask = n + 11;
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   0B30               ADDS     R0,R0,#+11
   \   0000002E   0700               MOVS     R7,R0
    454          	if((pEdList[n] < minEnergy)&&((uint8_t)((mDefaultValueOfChannel_c>>ChannelMask) & 0x1)))
   \   00000030   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000032   240E               LSRS     R4,R4,#+24
   \   00000034   285D               LDRB     R0,[R5, R4]
   \   00000036   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   00000038   360E               LSRS     R6,R6,#+24
   \   0000003A   B042               CMP      R0,R6
   \   0000003C   0CD2               BCS      ??App_HandleScanEdConfirm_2
   \   0000003E   8020               MOVS     R0,#+128
   \   00000040   0002               LSLS     R0,R0,#+8        ;; #+32768
   \   00000042   3841               ASRS     R0,R0,R7
   \   00000044   C007               LSLS     R0,R0,#+31
   \   00000046   07D5               BPL      ??App_HandleScanEdConfirm_2
    455              {
    456                minEnergy = pEdList[n];
   \   00000048   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000004A   240E               LSRS     R4,R4,#+24
   \   0000004C   285D               LDRB     R0,[R5, R4]
   \   0000004E   0600               MOVS     R6,R0
    457                /* Channel numbering is 11 to 26 both inclusive */
    458                mLogicalChannel = n + 11; 
   \   00000050   2000               MOVS     R0,R4
   \   00000052   0B30               ADDS     R0,R0,#+11
   \   00000054   ....               LDR      R1,??DataTable4_2
   \   00000056   0870               STRB     R0,[R1, #+0]
    459              }
    460            }
   \                     ??App_HandleScanEdConfirm_2:
   \   00000058   641C               ADDS     R4,R4,#+1
   \   0000005A   E2E7               B        ??App_HandleScanEdConfirm_0
    461            
    462            /* Print out the result of the ED scan */
    463            UartUtil_Print("ED scan returned the following results:\n\r  [", gAllowToBlock_d);
   \                     ??App_HandleScanEdConfirm_1:
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   ....               LDR      R0,??DataTable8_4
   \   00000060   ........           BL       UartUtil_Print
    464            UartUtil_PrintHex(pEdList, 16, gPrtHexBigEndian_c | gPrtHexSpaces_c);
   \   00000064   0922               MOVS     R2,#+9
   \   00000066   1021               MOVS     R1,#+16
   \   00000068   2800               MOVS     R0,R5
   \   0000006A   ........           BL       UartUtil_PrintHex
    465            UartUtil_Print("]\n\r\n\r", gAllowToBlock_d);
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   ....               LDR      R0,??DataTable8_5
   \   00000072   ........           BL       UartUtil_Print
    466            
    467            /* Print out the selected logical channel */
    468            UartUtil_Print("Based on the ED scan the logical channel 0x", gAllowToBlock_d);
   \   00000076   0121               MOVS     R1,#+1
   \   00000078   ....               LDR      R0,??DataTable8_6
   \   0000007A   ........           BL       UartUtil_Print
    469            UartUtil_PrintHex(&mLogicalChannel, 1, 0);
   \   0000007E   0022               MOVS     R2,#+0
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   ....               LDR      R0,??DataTable4_2
   \   00000084   ........           BL       UartUtil_PrintHex
    470            UartUtil_Print(" was selected\n\r", gAllowToBlock_d);
   \   00000088   0121               MOVS     R1,#+1
   \   0000008A   ....               LDR      R0,??DataTable9
   \   0000008C   ........           BL       UartUtil_Print
    471            
    472            /* The list of detected energies must be freed. */
    473            MSG_Free(pEdList);
   \   00000090   2800               MOVS     R0,R5
   \   00000092   ........           BL       MM_Free
   \   00000096   0020               MOVS     R0,#+0
   \   00000098   0500               MOVS     R5,R0
    474          }
   \   0000009A   F1BC               POP      {R0,R4-R7}
   \   0000009C   08BC               POP      {R3}
   \   0000009E   1847               BX       R3               ;; return
    475          
    476          /******************************************************************************
    477          * The App_StartScan(scanType) function will start the scan process of the
    478          * specified type in the MAC. This is accomplished by allocating a MAC message,
    479          * which is then assigned the desired scan parameters and sent to the MLME
    480          * service access point. The MAC PIB attributes "macShortAddress", and 
    481          * "macAssociatePermit" are modified.
    482          *
    483          * The function may return either of the following values:
    484          *   errorNoError:          The Scan message was sent successfully.
    485          *   errorInvalidParameter: The MLME service access point rejected the
    486          *                          message due to an invalid parameter.
    487          *   errorAllocFailed:      A message buffer could not be allocated.
    488          *
    489          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    490          static uint8_t App_StartCoordinator(void)
    491          {
   \                     App_StartCoordinator:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    492            /* Message for the MLME will be allocated and attached to this pointer */
    493            mlmeMessage_t *pMsg;
    494          
    495            UartUtil_Print("Sending the MLME-Start Request message to the MAC...", gAllowToBlock_d);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   ....               LDR      R0,??DataTable8_7
   \   00000006   ........           BL       UartUtil_Print
    496            
    497            /* Allocate a message for the MLME (We should check for NULL). */
    498            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000A   0F20               MOVS     R0,#+15
   \   0000000C   ........           BL       MM_Alloc
   \   00000010   0400               MOVS     R4,R0
    499            if(pMsg != NULL)
   \   00000012   002C               CMP      R4,#+0
   \   00000014   44D0               BEQ      ??App_StartCoordinator_0
    500            {
    501              /* Pointer which is used for easy access inside the allocated message */
    502              mlmeStartReq_t *pStartReq;    
    503              /* Boolean value that will be written to the MAC PIB */
    504              uint8_t boolFlag;
    505              
    506              /* Set-up MAC PIB attributes. Please note that Set, Get,
    507                 and Reset messages are not freed by the MLME. */
    508              
    509              /* We must always set the short address to something
    510                 else than 0xFFFF before starting a PAN. */
    511              pMsg->msgType = gMlmeSetReq_c;
   \   00000016   0920               MOVS     R0,#+9
   \   00000018   2070               STRB     R0,[R4, #+0]
    512              pMsg->msgData.setReq.pibAttribute = gMPibShortAddress_c;
   \   0000001A   5320               MOVS     R0,#+83
   \   0000001C   6070               STRB     R0,[R4, #+1]
    513              pMsg->msgData.setReq.pibAttributeValue = (uint8_t *)maShortAddress;
   \   0000001E   2100               MOVS     R1,R4
   \   00000020   891C               ADDS     R1,R1,#+2
   \   00000022   ....               LDR      R0,??DataTable5_1
   \   00000024   ........           BL       __aeabi_uwrite4
    514              (void) MSG_Send(NWK_MLME, pMsg);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       NWK_MLME_SapHandler
    515              
    516              /* We must set the Association Permit flag to TRUE 
    517                 in order to allow devices to associate to us. */
    518              pMsg->msgType = gMlmeSetReq_c;
   \   0000002E   0920               MOVS     R0,#+9
   \   00000030   2070               STRB     R0,[R4, #+0]
    519              pMsg->msgData.setReq.pibAttribute = gMPibAssociationPermit_c;
   \   00000032   4120               MOVS     R0,#+65
   \   00000034   6070               STRB     R0,[R4, #+1]
    520              boolFlag = TRUE;
   \   00000036   6846               MOV      R0,SP
   \   00000038   0121               MOVS     R1,#+1
   \   0000003A   0170               STRB     R1,[R0, #+0]
    521              pMsg->msgData.setReq.pibAttributeValue = &boolFlag;
   \   0000003C   2100               MOVS     R1,R4
   \   0000003E   891C               ADDS     R1,R1,#+2
   \   00000040   6846               MOV      R0,SP
   \   00000042   ........           BL       __aeabi_uwrite4
    522              (void) MSG_Send(NWK_MLME, pMsg);
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       NWK_MLME_SapHandler
    523              
    524              /* This is a MLME-START.req command */
    525              pMsg->msgType = gMlmeStartReq_c;
   \   0000004C   0A20               MOVS     R0,#+10
   \   0000004E   2070               STRB     R0,[R4, #+0]
    526              
    527              /* Create the Start request message data. */
    528              pStartReq = &pMsg->msgData.startReq;
   \   00000050   2000               MOVS     R0,R4
   \   00000052   401C               ADDS     R0,R0,#+1
   \   00000054   0500               MOVS     R5,R0
    529              /* PAN ID - LSB, MSB. The example shows a PAN ID of 0xBEEF. */
    530              FLib_MemCpy(pStartReq->panId, (void *)maPanId, 2);
   \   00000056   0222               MOVS     R2,#+2
   \   00000058   ....               LDR      R1,??DataTable5
   \   0000005A   2800               MOVS     R0,R5
   \   0000005C   ........           BL       FLib_MemCpy
    531              /* Logical Channel - the default of 11 will be overridden */
    532              pStartReq->logicalChannel = mLogicalChannel;
   \   00000060   ....               LDR      R0,??DataTable9_1
   \   00000062   0078               LDRB     R0,[R0, #+0]
   \   00000064   A870               STRB     R0,[R5, #+2]
    533              /* Beacon Order - 0xF = turn off beacons */
    534              pStartReq->beaconOrder = 0x0F;  
   \   00000066   0F20               MOVS     R0,#+15
   \   00000068   E870               STRB     R0,[R5, #+3]
    535              /* Superframe Order - 0xF = turn off beacons */
    536              pStartReq->superFrameOrder = 0x0F;
   \   0000006A   0F20               MOVS     R0,#+15
   \   0000006C   2871               STRB     R0,[R5, #+4]
    537              /* Be a PAN coordinator */
    538              pStartReq->panCoordinator = TRUE;
   \   0000006E   0120               MOVS     R0,#+1
   \   00000070   6871               STRB     R0,[R5, #+5]
    539              /* Dont use battery life extension */
    540              pStartReq->batteryLifeExt = FALSE;
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   A871               STRB     R0,[R5, #+6]
    541              /* This is not a Realignment command */
    542              pStartReq->coordRealignment = FALSE;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   E871               STRB     R0,[R5, #+7]
    543          #ifdef gMAC2006_d
    544          	/* Don't use security */
    545          	pStartReq->coordRealignSecurityLevel = 0;
    546          	pStartReq->beaconSecurityLevel = 0;
    547          #else	
    548              /* Dont use security */
    549              pStartReq->securityEnable = FALSE;
   \   0000007A   0020               MOVS     R0,#+0
   \   0000007C   2872               STRB     R0,[R5, #+8]
    550          #endif //gMAC2006_d	
    551                
    552              /* Send the Start request to the MLME. */
    553              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       NWK_MLME_SapHandler
   \   00000084   0028               CMP      R0,#+0
   \   00000086   05D1               BNE      ??App_StartCoordinator_1
    554              {
    555                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   00000088   0121               MOVS     R1,#+1
   \   0000008A   ....               LDR      R0,??DataTable8
   \   0000008C   ........           BL       UartUtil_Print
    556                return errorNoError;
   \   00000090   0020               MOVS     R0,#+0
   \   00000092   0AE0               B        ??App_StartCoordinator_2
    557              }
    558              else
    559              {
    560                /* One or more parameters in the Start Request message were invalid. */
    561                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_StartCoordinator_1:
   \   00000094   0121               MOVS     R1,#+1
   \   00000096   ....               LDR      R0,??DataTable8_1
   \   00000098   ........           BL       UartUtil_Print
    562                return errorInvalidParameter;
   \   0000009C   0520               MOVS     R0,#+5
   \   0000009E   04E0               B        ??App_StartCoordinator_2
    563              }
    564            }
    565            else
    566            {
    567              /* Allocation of a message buffer failed. */
    568              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_StartCoordinator_0:
   \   000000A0   0121               MOVS     R1,#+1
   \   000000A2   ....               LDR      R0,??DataTable8_2
   \   000000A4   ........           BL       UartUtil_Print
    569              return errorAllocFailed;
   \   000000A8   0420               MOVS     R0,#+4
   \                     ??App_StartCoordinator_2:
   \   000000AA   32BC               POP      {R1,R4,R5}
   \   000000AC   08BC               POP      {R3}
   \   000000AE   1847               BX       R3               ;; return
    570            }
    571          }
    572          
    573          /******************************************************************************
    574          * The App_SendAssociateResponse(nwkMessage_t *pMsgIn) will create the response
    575          * message to an Associate Indication (device sends an Associate Request to its
    576          * MAC. The request is transmitted to the coordinator where it is converted into
    577          * an Associate Indication). This function will extract the devices long address,
    578          * and various other flags from the incoming indication message for building the
    579          * response message.
    580          *
    581          * The function may return either of the following values:
    582          *   errorNoError:          The Associate Response message was sent successfully.
    583          *   errorInvalidParameter: The MLME service access point rejected the
    584          *                          message due to an invalid parameter.
    585          *   errorAllocFailed:      A message buffer could not be allocated.
    586          *
    587          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    588          static uint8_t App_SendAssociateResponse(nwkMessage_t *pMsgIn)
    589          {
   \                     App_SendAssociateResponse:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    590            mlmeMessage_t *pMsg;
    591            mlmeAssociateRes_t *pAssocRes;
    592           
    593            UartUtil_Print("Sending the MLME-Associate Response message to the MAC...", gAllowToBlock_d);
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   ....               LDR      R0,??DataTable10
   \   00000008   ........           BL       UartUtil_Print
    594           
    595            /* Allocate a message for the MLME */
    596            pMsg = MSG_AllocType(mlmeMessage_t);
   \   0000000C   0F20               MOVS     R0,#+15
   \   0000000E   ........           BL       MM_Alloc
   \   00000012   0500               MOVS     R5,R0
    597            if(pMsg != NULL)
   \   00000014   002D               CMP      R5,#+0
   \   00000016   36D0               BEQ      ??App_SendAssociateResponse_0
    598            {
    599              /* This is a MLME-ASSOCIATE.res command */
    600              pMsg->msgType = gMlmeAssociateRes_c;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2870               STRB     R0,[R5, #+0]
    601              
    602              /* Create the Associate response message data. */
    603              pAssocRes = &pMsg->msgData.associateRes;
   \   0000001C   2800               MOVS     R0,R5
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   0400               MOVS     R4,R0
    604              
    605              /* Assign a short address to the device. In this example we simply
    606                 choose 0x0001. Though, all devices and coordinators in a PAN must have
    607                 different short addresses. However, if a device do not want to use 
    608                 short addresses at all in the PAN, a short address of 0xFFFE must
    609                 be assigned to it. */
    610              if(pMsgIn->msgData.associateInd.capabilityInfo & gCapInfoAllocAddr_c)
   \   00000022   F07A               LDRB     R0,[R6, #+11]
   \   00000024   0006               LSLS     R0,R0,#+24
   \   00000026   04D5               BPL      ??App_SendAssociateResponse_1
    611              {
    612                /* Assign a unique short address less than 0xfffe if the device requests so. */
    613                pAssocRes->assocShortAddress[0] = 0x01;
   \   00000028   0120               MOVS     R0,#+1
   \   0000002A   2072               STRB     R0,[R4, #+8]
    614                pAssocRes->assocShortAddress[1] = 0x00;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   6072               STRB     R0,[R4, #+9]
   \   00000030   03E0               B        ??App_SendAssociateResponse_2
    615              }
    616              else
    617              {
    618                /* A short address of 0xfffe means that the device is granted access to
    619                   the PAN (Associate successful) but that long addressing is used.*/
    620                pAssocRes->assocShortAddress[0] = 0xFE;
   \                     ??App_SendAssociateResponse_1:
   \   00000032   FE20               MOVS     R0,#+254
   \   00000034   2072               STRB     R0,[R4, #+8]
    621                pAssocRes->assocShortAddress[1] = 0xFF;
   \   00000036   FF20               MOVS     R0,#+255
   \   00000038   6072               STRB     R0,[R4, #+9]
    622              }
    623              /* Get the 64 bit address of the device requesting association. */
    624              FLib_MemCpy(pAssocRes->deviceAddress, pMsgIn->msgData.associateInd.deviceAddress, 8);
   \                     ??App_SendAssociateResponse_2:
   \   0000003A   0822               MOVS     R2,#+8
   \   0000003C   3100               MOVS     R1,R6
   \   0000003E   491C               ADDS     R1,R1,#+1
   \   00000040   2000               MOVS     R0,R4
   \   00000042   ........           BL       FLib_MemCpy
    625              /* Association granted. May also be gPanAtCapacity_c or gPanAccessDenied_c. */
    626              pAssocRes->status = gSuccess_c;
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   E072               STRB     R0,[R4, #+11]
    627              /* Do not use security */
    628          #ifdef gMAC2006_d
    629              pAssocRes->securityLevel = 0;
    630          #else
    631              pAssocRes->securityEnable = FALSE;
   \   0000004A   0020               MOVS     R0,#+0
   \   0000004C   A072               STRB     R0,[R4, #+10]
    632          #endif //gMAC2006_d    
    633              /* Save device info. */
    634              FLib_MemCpy(maDeviceShortAddress, pAssocRes->assocShortAddress, 2);
   \   0000004E   0222               MOVS     R2,#+2
   \   00000050   2100               MOVS     R1,R4
   \   00000052   0831               ADDS     R1,R1,#+8
   \   00000054   ....               LDR      R0,??DataTable12
   \   00000056   ........           BL       FLib_MemCpy
    635              FLib_MemCpy(maDeviceLongAddress,  pAssocRes->deviceAddress,     8);
   \   0000005A   0822               MOVS     R2,#+8
   \   0000005C   2100               MOVS     R1,R4
   \   0000005E   ....               LDR      R0,??DataTable12_1
   \   00000060   ........           BL       FLib_MemCpy
    636              
    637              /* Send the Associate Response to the MLME. */
    638              if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
   \   00000064   2800               MOVS     R0,R5
   \   00000066   ........           BL       NWK_MLME_SapHandler
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   05D1               BNE      ??App_SendAssociateResponse_3
    639              {
    640                UartUtil_Print("Done\n\r", gAllowToBlock_d);
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   ....               LDR      R0,??DataTable8
   \   00000072   ........           BL       UartUtil_Print
    641                return errorNoError;
   \   00000076   0020               MOVS     R0,#+0
   \   00000078   0AE0               B        ??App_SendAssociateResponse_4
    642              }
    643              else
    644              {
    645                /* One or more parameters in the message were invalid. */
    646                UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateResponse_3:
   \   0000007A   0121               MOVS     R1,#+1
   \   0000007C   ....               LDR      R0,??DataTable8_1
   \   0000007E   ........           BL       UartUtil_Print
    647                return errorInvalidParameter;
   \   00000082   0520               MOVS     R0,#+5
   \   00000084   04E0               B        ??App_SendAssociateResponse_4
    648              }
    649            }
    650            else
    651            {
    652              /* Allocation of a message buffer failed. */
    653              UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
   \                     ??App_SendAssociateResponse_0:
   \   00000086   0121               MOVS     R1,#+1
   \   00000088   ....               LDR      R0,??DataTable8_2
   \   0000008A   ........           BL       UartUtil_Print
    654              return errorAllocFailed;
   \   0000008E   0420               MOVS     R0,#+4
   \                     ??App_SendAssociateResponse_4:
   \   00000090   70BC               POP      {R4-R6}
   \   00000092   08BC               POP      {R3}
   \   00000094   1847               BX       R3               ;; return
    655            }
    656          }
    657          
    658          /******************************************************************************
    659          * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
    660          * messages from the MLME, e.g. (Dis)Associate Indication.
    661          *
    662          * The function may return either of the following values:
    663          *   errorNoError:   The message was processed.
    664          *   errorNoMessage: The message pointer is NULL.
    665          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    666          static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
    667          {
   \                     App_HandleMlmeInput:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    668            if(pMsg == NULL)
   \   00000004   002C               CMP      R4,#+0
   \   00000006   01D1               BNE      ??App_HandleMlmeInput_0
    669              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   12E0               B        ??App_HandleMlmeInput_1
    670            
    671            /* Handle the incoming message. The type determines the sort of processing.*/
    672            switch(pMsg->msgType) {
   \                     ??App_HandleMlmeInput_0:
   \   0000000C   2078               LDRB     R0,[R4, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   02D0               BEQ      ??App_HandleMlmeInput_2
   \   00000012   0C38               SUBS     R0,R0,#+12
   \   00000014   08D0               BEQ      ??App_HandleMlmeInput_3
   \   00000016   0BE0               B        ??App_HandleMlmeInput_4
    673            case gNwkAssociateInd_c:
    674              UartUtil_Print("Received an MLME-Associate Indication from the MAC\n\r", gAllowToBlock_d);
   \                     ??App_HandleMlmeInput_2:
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   ....               LDR      R0,??DataTable12_2
   \   0000001C   ........           BL       UartUtil_Print
    675              /* A device sent us an Associate Request. We must send back a response.  */
    676              return App_SendAssociateResponse(pMsg);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       App_SendAssociateResponse
   \   00000026   04E0               B        ??App_HandleMlmeInput_1
    677              
    678            case gNwkCommStatusInd_c:
    679              /* Sent by the MLME after the Association Response has been transmitted. */
    680              UartUtil_Print("Received an MLME-Comm-Status Indication from the MAC\n\r", gAllowToBlock_d);
   \                     ??App_HandleMlmeInput_3:
   \   00000028   0121               MOVS     R1,#+1
   \   0000002A   ....               LDR      R0,??DataTable12_3
   \   0000002C   ........           BL       UartUtil_Print
    681              break;
    682            }
    683            return errorNoError;
   \                     ??App_HandleMlmeInput_4:
   \   00000030   0020               MOVS     R0,#+0
   \                     ??App_HandleMlmeInput_1:
   \   00000032   10BC               POP      {R4}
   \   00000034   08BC               POP      {R3}
   \   00000036   1847               BX       R3               ;; return
    684          }
    685          
    686          /******************************************************************************
    687          * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
    688          * messages from the MCPS, e.g. Data Confirm, and Data Indication.
    689          *
    690          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    691          static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
    692          {
   \                     App_HandleMcpsInput:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    693            switch(pMsgIn->msgType)
   \   00000004   2078               LDRB     R0,[R4, #+0]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??App_HandleMcpsInput_0
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   0AD0               BEQ      ??App_HandleMcpsInput_1
   \   0000000E   14E0               B        ??App_HandleMcpsInput_2
    694            {
    695              /* The MCPS-Data confirm is sent by the MAC to the network 
    696                 or application layer when data has been sent. */
    697            case gMcpsDataCnf_c:
    698              if(mcPendingPackets)
   \                     ??App_HandleMcpsInput_0:
   \   00000010   ....               LDR      R0,??DataTable12_4
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   10D0               BEQ      ??App_HandleMcpsInput_2
    699                mcPendingPackets--;
   \   00000018   ....               LDR      R0,??DataTable12_4
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   401E               SUBS     R0,R0,#+1
   \   0000001E   ....               LDR      R1,??DataTable12_4
   \   00000020   0870               STRB     R0,[R1, #+0]
   \   00000022   0AE0               B        ??App_HandleMcpsInput_2
    700              break;
    701            
    702            case gMcpsDataInd_c:
    703              /* The MCPS-Data indication is sent by the MAC to the network 
    704                 or application layer when data has been received. We simply 
    705                 copy the received data to the UART. */
    706              UartUtil_Print("Received the data packet from MCPS\n\r", gAllowToBlock_d);
   \                     ??App_HandleMcpsInput_1:
   \   00000024   0121               MOVS     R1,#+1
   \   00000026   ....               LDR      R0,??DataTable12_5
   \   00000028   ........           BL       UartUtil_Print
    707              //UartUtil_PrintHex(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength,0);
    708              UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   1B30               ADDS     R0,R0,#+27
   \   00000030   ........           BL       __aeabi_uread4
   \   00000034   E17D               LDRB     R1,[R4, #+23]
   \   00000036   ........           BL       UartUtil_Tx
    709              break;
    710            }
    711          }
   \                     ??App_HandleMcpsInput_2:
   \   0000003A   10BC               POP      {R4}
   \   0000003C   08BC               POP      {R3}
   \   0000003E   1847               BX       R3               ;; return
    712          
    713          /******************************************************************************
    714          * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
    715          * the name implies, wait for a message, thus blocking the execution of the
    716          * state machine. Instead the function analyzes the supplied message to determine
    717          * whether or not the message is of the expected type.
    718          * The function may return either of the following values:
    719          *   errorNoError: The message was of the expected type.
    720          *   errorNoMessage: The message pointer is NULL.
    721          *   errorWrongConfirm: The message is not of the expected type.
    722          *
    723          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    724          static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
    725          {
   \                     App_WaitMsg:
   \   00000000   00B5               PUSH     {LR}
   \   00000002   0200               MOVS     R2,R0
    726            /* Do we have a message? If not, the exit with error code */
    727            if(pMsg == NULL)
   \   00000004   002A               CMP      R2,#+0
   \   00000006   01D1               BNE      ??App_WaitMsg_0
    728              return errorNoMessage;
   \   00000008   0320               MOVS     R0,#+3
   \   0000000A   07E0               B        ??App_WaitMsg_1
    729          
    730            /* Is it the expected message type? If not then exit with error code */
    731            if(pMsg->msgType != msgType)
   \                     ??App_WaitMsg_0:
   \   0000000C   1078               LDRB     R0,[R2, #+0]
   \   0000000E   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000010   090E               LSRS     R1,R1,#+24
   \   00000012   8842               CMP      R0,R1
   \   00000014   01D0               BEQ      ??App_WaitMsg_2
    732              return errorWrongConfirm;
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   00E0               B        ??App_WaitMsg_1
    733          
    734            /* Found the expected message. Return with success code */
    735            return errorNoError;
   \                     ??App_WaitMsg_2:
   \   0000001A   0020               MOVS     R0,#+0
   \                     ??App_WaitMsg_1:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   1847               BX       R3               ;; return
    736          }
    737          
    738          /******************************************************************************
    739          * The App_TransmitUartData() function will perform (single/multi buffered)
    740          * data transmissions of data received by the UART. Data could also come from
    741          * other sources such as sensors etc. This is completely determined by the
    742          * application. The constant mDefaultValueOfMaxPendingDataPackets_c determine the maximum
    743          * number of packets pending for transmission in the MAC. A global variable
    744          * is incremented each time a data packet is sent to the MCPS, and decremented
    745          * when the corresponding MCPS-Data Confirm message is received. If the counter
    746          * reaches the defined maximum no more data buffers are allocated until the
    747          * counter is decreased below the maximum number of pending packets.
    748          *
    749          * The function uses the device information, that was stored when the device,
    750          * associated to us, for building an MCPS-Data Request message. The message
    751          * is sent to the MCPS service access point in the MAC.
    752          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    753          static void App_TransmitUartData(void)
    754          {   
   \                     App_TransmitUartData:
   \   00000000   80B5               PUSH     {R7,LR}
    755            static uint8_t keysBuffer[mMaxKeysToReceive_c];
    756            static uint8_t keysReceived = 0;
    757            
    758            /* get data from UART */
    759            if( keysReceived < mMaxKeysToReceive_c) 
   \   00000002   ....               LDR      R0,??DataTable12_6
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   2028               CMP      R0,#+32
   \   00000008   0CD2               BCS      ??App_TransmitUartData_0
    760            { 
    761              if(UartX_GetByteFromRxBuffer(&keysBuffer[keysReceived])) 
   \   0000000A   ....               LDR      R0,??DataTable12_6
   \   0000000C   0078               LDRB     R0,[R0, #+0]
   \   0000000E   ....               LDR      R1,??DataTable12_7
   \   00000010   0818               ADDS     R0,R1,R0
   \   00000012   ........           BL       Uart1_GetByteFromRxBuffer
   \   00000016   0028               CMP      R0,#+0
   \   00000018   04D0               BEQ      ??App_TransmitUartData_0
    762              {
    763              keysReceived++;
   \   0000001A   ....               LDR      R0,??DataTable12_6
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   401C               ADDS     R0,R0,#+1
   \   00000020   ....               LDR      R1,??DataTable12_6
   \   00000022   0870               STRB     R0,[R1, #+0]
    764              }
    765            }
    766            /* Use multi buffering for increased TX performance. It does not really
    767               have any effect at a UART baud rate of 19200bps but serves as an
    768               example of how the throughput may be improved in a real-world 
    769               application where the data rate is of concern. */
    770            if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
   \                     ??App_TransmitUartData_0:
   \   00000024   ....               LDR      R0,??DataTable12_4
   \   00000026   0078               LDRB     R0,[R0, #+0]
   \   00000028   0228               CMP      R0,#+2
   \   0000002A   08D2               BCS      ??App_TransmitUartData_1
   \   0000002C   ....               LDR      R0,??DataTable12_8
   \   0000002E   0068               LDR      R0,[R0, #+0]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   04D1               BNE      ??App_TransmitUartData_1
    771            {
    772              /* If the maximum number of pending data buffes is below maximum limit 
    773                 and we do not have a data buffer already then allocate one. */
    774              mpPacket = MSG_AllocType(nwkToMcpsMessage_t);
   \   00000034   1E20               MOVS     R0,#+30
   \   00000036   ........           BL       MM_Alloc
   \   0000003A   ....               LDR      R1,??DataTable12_8
   \   0000003C   0860               STR      R0,[R1, #+0]
    775            }
    776          
    777            if(mpPacket != NULL)
   \                     ??App_TransmitUartData_1:
   \   0000003E   ....               LDR      R0,??DataTable12_8
   \   00000040   0068               LDR      R0,[R0, #+0]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   4FD0               BEQ      ??App_TransmitUartData_2
    778            {
    779                /* get data from UART */        
    780                mpPacket->msgData.dataReq.pMsdu = &keysBuffer[0];
   \   00000046   ....               LDR      R0,??DataTable12_8
   \   00000048   0168               LDR      R1,[R0, #+0]
   \   0000004A   1A31               ADDS     R1,R1,#+26
   \   0000004C   ....               LDR      R0,??DataTable12_7
   \   0000004E   ........           BL       __aeabi_uwrite4
    781                /* Data was available in the UART receive buffer. Now create an
    782                   MCPS-Data Request message containing the UART data. */
    783                mpPacket->msgType = gMcpsDataReq_c;
   \   00000052   ....               LDR      R0,??DataTable12_8
   \   00000054   0068               LDR      R0,[R0, #+0]
   \   00000056   0021               MOVS     R1,#+0
   \   00000058   0170               STRB     R1,[R0, #+0]
    784                /* Create the header using device information stored when creating 
    785                   the association response. In this simple example the use of short
    786                   addresses is hardcoded. In a real world application we must be
    787                   flexible, and use the address mode required by the given situation. */
    788                FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr, maDeviceShortAddress, 2);
   \   0000005A   0222               MOVS     R2,#+2
   \   0000005C   ....               LDR      R1,??DataTable12
   \   0000005E   ....               LDR      R0,??DataTable12_8
   \   00000060   0068               LDR      R0,[R0, #+0]
   \   00000062   401C               ADDS     R0,R0,#+1
   \   00000064   ........           BL       FLib_MemCpy
    789                FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, (void *)maShortAddress, 2);
   \   00000068   0222               MOVS     R2,#+2
   \   0000006A   ....               LDR      R1,??DataTable12_9
   \   0000006C   ....               LDR      R0,??DataTable12_8
   \   0000006E   0068               LDR      R0,[R0, #+0]
   \   00000070   0C30               ADDS     R0,R0,#+12
   \   00000072   ........           BL       FLib_MemCpy
    790                FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, (void *)maPanId, 2);
   \   00000076   0222               MOVS     R2,#+2
   \   00000078   ....               LDR      R1,??DataTable12_10
   \   0000007A   ....               LDR      R0,??DataTable12_8
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   0930               ADDS     R0,R0,#+9
   \   00000080   ........           BL       FLib_MemCpy
    791                FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, (void *)maPanId, 2);
   \   00000084   0222               MOVS     R2,#+2
   \   00000086   ....               LDR      R1,??DataTable12_10
   \   00000088   ....               LDR      R0,??DataTable12_8
   \   0000008A   0068               LDR      R0,[R0, #+0]
   \   0000008C   1430               ADDS     R0,R0,#+20
   \   0000008E   ........           BL       FLib_MemCpy
    792                mpPacket->msgData.dataReq.dstAddrMode = gAddrModeShort_c;
   \   00000092   ....               LDR      R0,??DataTable12_8
   \   00000094   0068               LDR      R0,[R0, #+0]
   \   00000096   0221               MOVS     R1,#+2
   \   00000098   C172               STRB     R1,[R0, #+11]
    793                mpPacket->msgData.dataReq.srcAddrMode = gAddrModeShort_c;
   \   0000009A   ....               LDR      R0,??DataTable12_8
   \   0000009C   0068               LDR      R0,[R0, #+0]
   \   0000009E   0221               MOVS     R1,#+2
   \   000000A0   8175               STRB     R1,[R0, #+22]
    794                mpPacket->msgData.dataReq.msduLength = keysReceived;
   \   000000A2   ....               LDR      R0,??DataTable12_8
   \   000000A4   0068               LDR      R0,[R0, #+0]
   \   000000A6   ....               LDR      R1,??DataTable12_6
   \   000000A8   0978               LDRB     R1,[R1, #+0]
   \   000000AA   C175               STRB     R1,[R0, #+23]
    795                /* Request MAC level acknowledgement, and 
    796                   indirect transmission of the data packet */
    797                mpPacket->msgData.dataReq.txOptions = gTxOptsAck_c | gTxOptsIndirect_c;
   \   000000AC   ....               LDR      R0,??DataTable12_8
   \   000000AE   0068               LDR      R0,[R0, #+0]
   \   000000B0   0521               MOVS     R1,#+5
   \   000000B2   4176               STRB     R1,[R0, #+25]
    798                /* Give the data packet a handle. The handle is
    799                   returned in the MCPS-Data Confirm message. */
    800                mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
   \   000000B4   ....               LDR      R0,??DataTable12_8
   \   000000B6   0068               LDR      R0,[R0, #+0]
   \   000000B8   ....               LDR      R1,??DataTable12_11
   \   000000BA   0978               LDRB     R1,[R1, #+0]
   \   000000BC   0176               STRB     R1,[R0, #+24]
   \   000000BE   ....               LDR      R0,??DataTable12_11
   \   000000C0   0078               LDRB     R0,[R0, #+0]
   \   000000C2   401C               ADDS     R0,R0,#+1
   \   000000C4   ....               LDR      R1,??DataTable12_11
   \   000000C6   0870               STRB     R0,[R1, #+0]
    801          #ifdef gMAC2006_d	  
    802          	  /* Don't use security */      
    803          	  mpPacket->msgData.dataReq.securityLevel = 0;
    804          #endif //gMAC2006_d	  
    805                /* Send the Data Request to the MCPS */
    806                (void)MSG_Send(NWK_MCPS, mpPacket);
   \   000000C8   ....               LDR      R0,??DataTable12_8
   \   000000CA   0068               LDR      R0,[R0, #+0]
   \   000000CC   ........           BL       NWK_MCPS_SapHandler
    807                /* Prepare for another data buffer */
    808                mpPacket = NULL;
   \   000000D0   ....               LDR      R0,??DataTable12_8
   \   000000D2   0021               MOVS     R1,#+0
   \   000000D4   0160               STR      R1,[R0, #+0]
    809                mcPendingPackets++;
   \   000000D6   ....               LDR      R0,??DataTable12_4
   \   000000D8   0078               LDRB     R0,[R0, #+0]
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   ....               LDR      R1,??DataTable12_4
   \   000000DE   0870               STRB     R0,[R1, #+0]
    810                /* Receive another pressed keys */
    811                keysReceived = 0;
   \   000000E0   ....               LDR      R0,??DataTable12_6
   \   000000E2   0021               MOVS     R1,#+0
   \   000000E4   0170               STRB     R1,[R0, #+0]
    812            }
    813            
    814            /* If the keysBuffer[] wasn't send over the air because there are too many pending packets, */
    815            /* try to send it later   */
    816            if (keysReceived)
   \                     ??App_TransmitUartData_2:
   \   000000E6   ....               LDR      R0,??DataTable12_6
   \   000000E8   0078               LDRB     R0,[R0, #+0]
   \   000000EA   0028               CMP      R0,#+0
   \   000000EC   04D0               BEQ      ??App_TransmitUartData_3
    817            {
    818            TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
   \   000000EE   0221               MOVS     R1,#+2
   \   000000F0   ....               LDR      R0,??DataTable12_12
   \   000000F2   0078               LDRB     R0,[R0, #+0]
   \   000000F4   ........           BL       TS_SendEvent
    819            }
    820          }
   \                     ??App_TransmitUartData_3:
   \   000000F8   09BC               POP      {R0,R3}
   \   000000FA   1847               BX       R3               ;; return

   \                                 In section .bss, align 4
   \                     ??keysBuffer:
   \   00000000                      DS8 32

   \                                 In section .bss, align 1
   \                     ??keysReceived:
   \   00000000                      DS8 1
    821          
    822          
    823          /*****************************************************************************
    824          * Handles all key events for this device.
    825          * Interface assumptions: None
    826          * Return value: None
    827          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    828          static void App_HandleKeys
    829            (
    830            key_event_t events  /*IN: Events from keyboard modul  */
    831            )
    832          {
   \                     App_HandleKeys:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    833            switch ( events ) 
   \   00000004   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000006   240E               LSRS     R4,R4,#+24
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   401E               SUBS     R0,R0,#+1
   \   0000000C   0728               CMP      R0,#+7
   \   0000000E   2ED8               BHI      ??App_HandleKeys_0
    834              { 
    835                case gKBD_EventSW1_c:
    836                case gKBD_EventSW2_c:
    837                case gKBD_EventSW3_c:
    838                case gKBD_EventSW4_c:
    839                case gKBD_EventLongSW1_c:
    840                case gKBD_EventLongSW2_c:
    841                case gKBD_EventLongSW3_c:
    842                case gKBD_EventLongSW4_c:
    843                  if(gState == stateInit)
   \                     ??App_HandleKeys_1:
   \   00000010   ....               LDR      R0,??DataTable12_13
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2AD1               BNE      ??App_HandleKeys_0
    844                    {
    845                    StopLed1Flashing();
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   ........           BL       LED_StopFlash
    846                    StopLed2Flashing();
   \   0000001E   0220               MOVS     R0,#+2
   \   00000020   ........           BL       LED_StopFlash
    847                    StopLed3Flashing();
   \   00000024   0420               MOVS     R0,#+4
   \   00000026   ........           BL       LED_StopFlash
    848                    StopLed4Flashing();
   \   0000002A   0820               MOVS     R0,#+8
   \   0000002C   ........           BL       LED_StopFlash
    849                    Led1Off();
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   1720               MOVS     R0,#+23
   \   00000034   ........           BL       Gpio_SetPinData
    850                    Led2Off();
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   1820               MOVS     R0,#+24
   \   0000003C   ........           BL       Gpio_SetPinData
    851                    Led3Off();
   \   00000040   0021               MOVS     R1,#+0
   \   00000042   1920               MOVS     R0,#+25
   \   00000044   ........           BL       Gpio_SetPinData
    852                    Led4Off();
   \   00000048   0021               MOVS     R1,#+0
   \   0000004A   2C20               MOVS     R0,#+44
   \   0000004C   ........           BL       Gpio_SetPinData
    853                    LCD_ClearDisplay();
   \   00000050   ........           BL       LCD_ClearDisplay
    854                    LCD_WriteString(1,"Application");
   \   00000054   ....               LDR      R1,??DataTable12_14
   \   00000056   0120               MOVS     R0,#+1
   \   00000058   ........           BL       LCD_WriteString
    855                    LCD_WriteString(2,"    started");     
   \   0000005C   ....               LDR      R1,??DataTable12_15
   \   0000005E   0220               MOVS     R0,#+2
   \   00000060   ........           BL       LCD_WriteString
    856                    TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   ....               LDR      R0,??DataTable12_12
   \   00000068   0078               LDRB     R0,[R0, #+0]
   \   0000006A   ........           BL       TS_SendEvent
    857                    }
    858              break;  
    859              }    
    860          }                                                      
   \                     ??App_HandleKeys_0:
   \   0000006E   10BC               POP      {R4}
   \   00000070   08BC               POP      {R3}
   \   00000072   1847               BX       R3               ;; return
    861          
    862          /*****************************************************************************
    863          * The DeepSleepWakeupStackProc(void) function is called each time the 
    864          * application exits the DeepSleep mode .
    865          * 
    866          * Return value:
    867          *     None
    868          *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    869          void DeepSleepWakeupStackProc(void){
    870            return;
   \                     DeepSleepWakeupStackProc:
   \   00000000   7047               BX       LR               ;; return
    871          }
    872          
    873          /******************************************************************************
    874          * The following functions are called by the MAC to put messages into the
    875          * Application's queue. They need to be defined even if they are not used
    876          * in order to avoid linker errors.
    877          ******************************************************************************/
    878          

   \                                 In section .text, align 2, keep-with-next
    879          uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
    880          {
   \                     MLME_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    881            /* Put the incoming MLME message in the applications input queue. */
    882            MSG_Queue(&mMlmeNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable12_16
   \   00000008   ........           BL       List_AddTail
    883            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
   \   0000000C   0421               MOVS     R1,#+4
   \   0000000E   ....               LDR      R0,??DataTable12_12
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
    884            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    885          }
    886          

   \                                 In section .text, align 2, keep-with-next
    887          uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
    888          {
   \                     MCPS_NWK_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    889            /* Put the incoming MCPS message in the applications input queue. */
    890            MSG_Queue(&mMcpsNwkInputQueue, pMsg);
   \   00000004   2100               MOVS     R1,R4
   \   00000006   ....               LDR      R0,??DataTable12_17
   \   00000008   ........           BL       List_AddTail
    891            TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
   \   0000000C   0821               MOVS     R1,#+8
   \   0000000E   ....               LDR      R0,??DataTable12_12
   \   00000010   0078               LDRB     R0,[R0, #+0]
   \   00000012   ........           BL       TS_SendEvent
    892            return gSuccess_c;
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   10BC               POP      {R4}
   \   0000001A   08BC               POP      {R3}
   \   0000001C   1847               BX       R3               ;; return
    893          }
    894          

   \                                 In section .text, align 2, keep-with-next
    895          uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
    896          {
   \                     ASP_APP_SapHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    897            /* If the message is not handled anywhere it must be freed. */
    898            MSG_Free(pMsg);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       MM_Free
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   0400               MOVS     R4,R0
    899            return gSuccess_c;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   10BC               POP      {R4}
   \   00000012   08BC               POP      {R3}
   \   00000014   1847               BX       R3               ;; return
    900          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     App_HandleKeys

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   ........           DC32     UartRxCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     `?<Constant "\\n\\rPress any switch on...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   ........           DC32     `?<Constant "Press any key">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   ........           DC32     `?<Constant "to start.">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   ........           DC32     `?<Constant "Received an MLME-Beac...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   ........           DC32     `?<Constant "MyWirelessApp Demo No...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   ........           DC32     `?<Constant "Initiating the Energy...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   ........           DC32     `?<Constant "Starting Energy">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   ........           DC32     `?<Constant "Detection Scan">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   ........           DC32     `?<Constant "\\n\\rStarting as PAN coo...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   ........           DC32     mLogicalChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0A0D0000           DC8      0x0A, 0x0D, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   ........           DC32     `?<Constant "Starting">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   ........           DC32     `?<Constant "PAN coordinator">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   ........           DC32     `?<Constant "Started the coordinat...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   ........           DC32     `?<Constant ", and short address 0x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   ........           DC32     maPanId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   ........           DC32     maShortAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   ........           DC32     `?<Constant ".\\n\\r\\n\\rReady to send an...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   ........           DC32     `?<Constant "Ready to send">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   ........           DC32     `?<Constant "and receive data">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Scan...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   ........           DC32     `?<Constant "Done\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   ........           DC32     `?<Constant "Invalid parameter!\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   ........           DC32     `?<Constant "Message allocation fa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   ........           DC32     `?<Constant "Received the MLME-Sca...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   ........           DC32     `?<Constant "ED scan returned the ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   ........           DC32     `?<Constant "]\\n\\r\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   ........           DC32     `?<Constant "Based on the ED scan ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Star...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     `?<Constant " was selected\\n\\r">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   ........           DC32     mLogicalChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     `?<Constant "Sending the MLME-Asso...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     maDeviceShortAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   ........           DC32     maDeviceLongAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   ........           DC32     `?<Constant "Received an MLME-Asso...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   ........           DC32     `?<Constant "Received an MLME-Comm...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   ........           DC32     mcPendingPackets

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   ........           DC32     `?<Constant "Received the data pac...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   ........           DC32     ??keysReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   ........           DC32     ??keysBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   ........           DC32     mpPacket

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   ........           DC32     maShortAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   ........           DC32     maPanId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   ........           DC32     mMsduHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   ........           DC32     gAppTaskID_c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   ........           DC32     gState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   ........           DC32     `?<Constant "Application">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   ........           DC32     `?<Constant "    started">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   ........           DC32     mMlmeNwkInputQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   ........           DC32     mMcpsNwkInputQueue

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rPress any switch on...">`:
   \   00000000   0A0D50726573       DC8 0AH, 0DH, 50H, 72H, 65H, 73H, 73H, 20H
   \              7320        
   \   00000008   616E79207377       DC8 61H, 6EH, 79H, 20H, 73H, 77H, 69H, 74H
   \              6974        
   \   00000010   6368206F6E20       DC8 63H, 68H, 20H, 6FH, 6EH, 20H, 62H, 6FH
   \              626F        
   \   00000018   61726420746F       DC8 61H, 72H, 64H, 20H, 74H, 6FH, 20H, 73H
   \              2073        
   \   00000020   746172742072       DC8 74H, 61H, 72H, 74H, 20H, 72H, 75H, 6EH
   \              756E        
   \   00000028   6E696E672074       DC8 6EH, 69H, 6EH, 67H, 20H, 74H, 68H, 65H
   \              6865        
   \   00000030   206170706C69       DC8 20H, 61H, 70H, 70H, 6CH, 69H, 63H, 61H
   \              6361        
   \   00000038   74696F6E2E0A       DC8 74H, 69H, 6FH, 6EH, 2EH, 0AH, 0DH, 0
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "Press any key">`:
   \   00000000   507265737320       DC8 "Press any key"
   \              616E79206B65
   \              7900        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "to start.">`:
   \   00000000   746F20737461       DC8 "to start."
   \              72742E00    
   \   0000000A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received an MLME-Beac...">`:
   \   00000000   526563656976       DC8 "Received an MLME-Beacon Notify Indication\012\015"
   \              656420616E20
   \              4D4C4D452D42
   \              6561636F6E20
   \              4E6F74696679
   \              20496E646963
   \              6174696F6E0A
   \              0D00        

   \                                 In section .rodata, align 4
   \                     `?<Constant "MyWirelessApp Demo No...">`:
   \   00000000   4D7957697265       DC8 4DH, 79H, 57H, 69H, 72H, 65H, 6CH, 65H
   \              6C65        
   \   00000008   737341707020       DC8 73H, 73H, 41H, 70H, 70H, 20H, 44H, 65H
   \              4465        
   \   00000010   6D6F204E6F6E       DC8 6DH, 6FH, 20H, 4EH, 6FH, 6EH, 20H, 42H
   \              2042        
   \   00000018   6561636F6E20       DC8 65H, 61H, 63H, 6FH, 6EH, 20H, 43H, 6FH
   \              436F        
   \   00000020   6F7264696E61       DC8 6FH, 72H, 64H, 69H, 6EH, 61H, 74H, 6FH
   \              746F        
   \   00000028   72206170706C       DC8 72H, 20H, 61H, 70H, 70H, 6CH, 69H, 63H
   \              6963        
   \   00000030   6174696F6E20       DC8 61H, 74H, 69H, 6FH, 6EH, 20H, 69H, 73H
   \              6973        
   \   00000038   20696E697469       DC8 20H, 69H, 6EH, 69H, 74H, 69H, 61H, 6CH
   \              616C        
   \   00000040   697A65642061       DC8 69H, 7AH, 65H, 64H, 20H, 61H, 6EH, 64H
   \              6E64        
   \   00000048   207265616479       DC8 20H, 72H, 65H, 61H, 64H, 79H, 2EH, 0AH
   \              2E0A        
   \   00000050   0D0A0D00           DC8 0DH, 0AH, 0DH, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Initiating the Energy...">`:
   \   00000000   496E69746961       DC8 "Initiating the Energy Detection Scan\012\015"
   \              74696E672074
   \              686520456E65
   \              726779204465
   \              74656374696F
   \              6E205363616E
   \              0A0D00      
   \   00000027   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Starting Energy">`:
   \   00000000   537461727469       DC8 "Starting Energy"
   \              6E6720456E65
   \              72677900    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Detection Scan">`:
   \   00000000   446574656374       DC8 "Detection Scan"
   \              696F6E205363
   \              616E00      
   \   0000000F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rStarting as PAN coo...">`:
   \   00000000   0A0D53746172       DC8 "\012\015Starting as PAN coordinator on channel 0x"
   \              74696E672061
   \              732050414E20
   \              636F6F726469
   \              6E61746F7220
   \              6F6E20636861
   \              6E6E656C2030
   \              7800        

   \                                 In section .rodata, align 4
   \   00000000   0A0D00             DC8 "\012\015"
   \   00000003   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Starting">`:
   \   00000000   537461727469       DC8 "Starting"
   \              6E6700      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "PAN coordinator">`:
   \   00000000   50414E20636F       DC8 "PAN coordinator"
   \              6F7264696E61
   \              746F7200    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Started the coordinat...">`:
   \   00000000   537461727465       DC8 "Started the coordinator with PAN ID 0x"
   \              642074686520
   \              636F6F726469
   \              6E61746F7220
   \              776974682050
   \              414E20494420
   \              307800      
   \   00000027   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant ", and short address 0x">`:
   \   00000000   2C20616E6420       DC8 ", and short address 0x"
   \              73686F727420
   \              616464726573
   \              7320307800  
   \   00000017   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant ".\\n\\r\\n\\rReady to send an...">`:
   \   00000000   2E0A0D0A0D52       DC8 2EH, 0AH, 0DH, 0AH, 0DH, 52H, 65H, 61H
   \              6561        
   \   00000008   647920746F20       DC8 64H, 79H, 20H, 74H, 6FH, 20H, 73H, 65H
   \              7365        
   \   00000010   6E6420616E64       DC8 6EH, 64H, 20H, 61H, 6EH, 64H, 20H, 72H
   \              2072        
   \   00000018   656365697665       DC8 65H, 63H, 65H, 69H, 76H, 65H, 20H, 64H
   \              2064        
   \   00000020   617461206F76       DC8 61H, 74H, 61H, 20H, 6FH, 76H, 65H, 72H
   \              6572        
   \   00000028   207468652055       DC8 20H, 74H, 68H, 65H, 20H, 55H, 41H, 52H
   \              4152        
   \   00000030   542E0A0D0A0D       DC8 54H, 2EH, 0AH, 0DH, 0AH, 0DH, 0
   \              00          
   \   00000037   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Ready to send">`:
   \   00000000   526561647920       DC8 "Ready to send"
   \              746F2073656E
   \              6400        
   \   0000000E   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "and receive data">`:
   \   00000000   616E64207265       DC8 "and receive data"
   \              636569766520
   \              6461746100  
   \   00000011   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Scan...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D5363616E20       DC8 2DH, 53H, 63H, 61H, 6EH, 20H, 52H, 65H
   \              5265        
   \   00000018   717565737420       DC8 71H, 75H, 65H, 73H, 74H, 20H, 6DH, 65H
   \              6D65        
   \   00000020   737361676520       DC8 73H, 73H, 61H, 67H, 65H, 20H, 74H, 6FH
   \              746F        
   \   00000028   20746865204D       DC8 20H, 74H, 68H, 65H, 20H, 4DH, 41H, 43H
   \              4143        
   \   00000030   2E2E2E00           DC8 2EH, 2EH, 2EH, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Done\\n\\r">`:
   \   00000000   446F6E650A0D       DC8 "Done\012\015"
   \              00          
   \   00000007   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Invalid parameter!\\n\\r">`:
   \   00000000   496E76616C69       DC8 "Invalid parameter!\012\015"
   \              642070617261
   \              6D6574657221
   \              0A0D00      
   \   00000015   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Message allocation fa...">`:
   \   00000000   4D6573736167       DC8 "Message allocation failed!\012\015"
   \              6520616C6C6F
   \              636174696F6E
   \              206661696C65
   \              64210A0D00  
   \   0000001D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received the MLME-Sca...">`:
   \   00000000   526563656976       DC8 52H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
   \              6564        
   \   00000008   20746865204D       DC8 20H, 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH
   \              4C4D        
   \   00000010   452D5363616E       DC8 45H, 2DH, 53H, 63H, 61H, 6EH, 20H, 43H
   \              2043        
   \   00000018   6F6E6669726D       DC8 6FH, 6EH, 66H, 69H, 72H, 6DH, 20H, 6DH
   \              206D        
   \   00000020   657373616765       DC8 65H, 73H, 73H, 61H, 67H, 65H, 20H, 66H
   \              2066        
   \   00000028   726F6D207468       DC8 72H, 6FH, 6DH, 20H, 74H, 68H, 65H, 20H
   \              6520        
   \   00000030   4D41430A0D00       DC8 4DH, 41H, 43H, 0AH, 0DH, 0
   \   00000036   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "ED scan returned the ...">`:
   \   00000000   454420736361       DC8 "ED scan returned the following results:\012\015  ["
   \              6E2072657475
   \              726E65642074
   \              686520666F6C
   \              6C6F77696E67
   \              20726573756C
   \              74733A0A0D20
   \              205B00      
   \   0000002D   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "]\\n\\r\\n\\r">`:
   \   00000000   5D0A0D0A0D00       DC8 "]\012\015\012\015"
   \   00000006   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Based on the ED scan ...">`:
   \   00000000   426173656420       DC8 "Based on the ED scan the logical channel 0x"
   \              6F6E20746865
   \              204544207363
   \              616E20746865
   \              206C6F676963
   \              616C20636861
   \              6E6E656C2030
   \              7800        

   \                                 In section .rodata, align 4
   \                     `?<Constant " was selected\\n\\r">`:
   \   00000000   207761732073       DC8 " was selected\012\015"
   \              656C65637465
   \              640A0D00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Star...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D5374617274       DC8 2DH, 53H, 74H, 61H, 72H, 74H, 20H, 52H
   \              2052        
   \   00000018   657175657374       DC8 65H, 71H, 75H, 65H, 73H, 74H, 20H, 6DH
   \              206D        
   \   00000020   657373616765       DC8 65H, 73H, 73H, 61H, 67H, 65H, 20H, 74H
   \              2074        
   \   00000028   6F2074686520       DC8 6FH, 20H, 74H, 68H, 65H, 20H, 4DH, 41H
   \              4D41        
   \   00000030   432E2E2E00         DC8 43H, 2EH, 2EH, 2EH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sending the MLME-Asso...">`:
   \   00000000   53656E64696E       DC8 53H, 65H, 6EH, 64H, 69H, 6EH, 67H, 20H
   \              6720        
   \   00000008   746865204D4C       DC8 74H, 68H, 65H, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D4173736F63       DC8 2DH, 41H, 73H, 73H, 6FH, 63H, 69H, 61H
   \              6961        
   \   00000018   746520526573       DC8 74H, 65H, 20H, 52H, 65H, 73H, 70H, 6FH
   \              706F        
   \   00000020   6E7365206D65       DC8 6EH, 73H, 65H, 20H, 6DH, 65H, 73H, 73H
   \              7373        
   \   00000028   61676520746F       DC8 61H, 67H, 65H, 20H, 74H, 6FH, 20H, 74H
   \              2074        
   \   00000030   6865204D4143       DC8 68H, 65H, 20H, 4DH, 41H, 43H, 2EH, 2EH
   \              2E2E        
   \   00000038   2E00               DC8 2EH, 0
   \   0000003A   0000               DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received an MLME-Asso...">`:
   \   00000000   526563656976       DC8 52H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
   \              6564        
   \   00000008   20616E204D4C       DC8 20H, 61H, 6EH, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D4173736F63       DC8 2DH, 41H, 73H, 73H, 6FH, 63H, 69H, 61H
   \              6961        
   \   00000018   746520496E64       DC8 74H, 65H, 20H, 49H, 6EH, 64H, 69H, 63H
   \              6963        
   \   00000020   6174696F6E20       DC8 61H, 74H, 69H, 6FH, 6EH, 20H, 66H, 72H
   \              6672        
   \   00000028   6F6D20746865       DC8 6FH, 6DH, 20H, 74H, 68H, 65H, 20H, 4DH
   \              204D        
   \   00000030   41430A0D00         DC8 41H, 43H, 0AH, 0DH, 0
   \   00000035   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received an MLME-Comm...">`:
   \   00000000   526563656976       DC8 52H, 65H, 63H, 65H, 69H, 76H, 65H, 64H
   \              6564        
   \   00000008   20616E204D4C       DC8 20H, 61H, 6EH, 20H, 4DH, 4CH, 4DH, 45H
   \              4D45        
   \   00000010   2D436F6D6D2D       DC8 2DH, 43H, 6FH, 6DH, 6DH, 2DH, 53H, 74H
   \              5374        
   \   00000018   617475732049       DC8 61H, 74H, 75H, 73H, 20H, 49H, 6EH, 64H
   \              6E64        
   \   00000020   69636174696F       DC8 69H, 63H, 61H, 74H, 69H, 6FH, 6EH, 20H
   \              6E20        
   \   00000028   66726F6D2074       DC8 66H, 72H, 6FH, 6DH, 20H, 74H, 68H, 65H
   \              6865        
   \   00000030   204D41430A0D       DC8 20H, 4DH, 41H, 43H, 0AH, 0DH, 0
   \              00          
   \   00000037   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Received the data pac...">`:
   \   00000000   526563656976       DC8 "Received the data packet from MCPS\012\015"
   \              656420746865
   \              206461746120
   \              7061636B6574
   \              2066726F6D20
   \              4D4350530A0D
   \              00          
   \   00000025   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Application">`:
   \   00000000   4170706C6963       DC8 "Application"
   \              6174696F6E00

   \                                 In section .rodata, align 4
   \                     `?<Constant "    started">`:
   \   00000000   202020207374       DC8 "    started"
   \              617274656400
    901          
    902          /******************************************************************************/

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     ASP_APP_SapHandler             8
     AppTask                       16
     App_HandleKeys                 8
     App_HandleMcpsInput            8
     App_HandleMlmeInput            8
     App_HandleScanEdConfirm       24
     App_SendAssociateResponse     16
     App_StartCoordinator          16
     App_StartScan                 16
     App_TransmitUartData           8
     App_WaitMsg                    4
     DeepSleepWakeupStackProc       0
     MApp_init                      8
     MCPS_NWK_SapHandler            8
     MLME_NWK_SapHandler            8
     UartRxCallBack                 8


   Section sizes:

     Function/Label                             Bytes
     --------------                             -----
     maShortAddress                                2
     maPanId                                       2
     mLogicalChannel                               1
     maDeviceShortAddress                          2
     maDeviceLongAddress                           8
     mpPacket                                      4
     mMsduHandle                                   1
     mcPendingPackets                              1
     mMlmeNwkInputQueue                            8
     mMcpsNwkInputQueue                            8
     gState                                        1
     gaNvAppDataSet                                8
     MApp_init                                   120
     AppTask                                     522
     UartRxCallBack                               32
     App_StartScan                               106
     App_HandleScanEdConfirm                     160
     App_StartCoordinator                        176
     App_SendAssociateResponse                   150
     App_HandleMlmeInput                          56
     App_HandleMcpsInput                          64
     App_WaitMsg                                  32
     App_TransmitUartData                        252
     keysBuffer                                   32
     keysReceived                                  1
     App_HandleKeys                              116
     DeepSleepWakeupStackProc                      2
     MLME_NWK_SapHandler                          30
     MCPS_NWK_SapHandler                          30
     ASP_APP_SapHandler                           22
     ??DataTable0                                  4
     ??DataTable0_1                                4
     ??DataTable1                                  4
     ??DataTable1_1                                4
     ??DataTable1_2                                4
     ??DataTable1_3                                4
     ??DataTable2                                  4
     ??DataTable2_1                                4
     ??DataTable3                                  4
     ??DataTable3_1                                4
     ??DataTable3_2                                4
     ??DataTable3_3                                4
     ??DataTable3_4                                4
     ??DataTable3_5                                4
     ??DataTable3_6                                4
     ??DataTable4                                  4
     ??DataTable4_1                                4
     ??DataTable4_2                                4
     ??DataTable4_3                                4
     ??DataTable4_4                                4
     ??DataTable4_5                                4
     ??DataTable4_6                                4
     ??DataTable4_7                                4
     ??DataTable5                                  4
     ??DataTable5_1                                4
     ??DataTable5_2                                4
     ??DataTable5_3                                4
     ??DataTable5_4                                4
     ??DataTable7                                  4
     ??DataTable8                                  4
     ??DataTable8_1                                4
     ??DataTable8_2                                4
     ??DataTable8_3                                4
     ??DataTable8_4                                4
     ??DataTable8_5                                4
     ??DataTable8_6                                4
     ??DataTable8_7                                4
     ??DataTable9                                  4
     ??DataTable9_1                                4
     ??DataTable10                                 4
     ??DataTable12                                 4
     ??DataTable12_1                               4
     ??DataTable12_2                               4
     ??DataTable12_3                               4
     ??DataTable12_4                               4
     ??DataTable12_5                               4
     ??DataTable12_6                               4
     ??DataTable12_7                               4
     ??DataTable12_8                               4
     ??DataTable12_9                               4
     ??DataTable12_10                              4
     ??DataTable12_11                              4
     ??DataTable12_12                              4
     ??DataTable12_13                              4
     ??DataTable12_14                              4
     ??DataTable12_15                              4
     ??DataTable12_16                              4
     ??DataTable12_17                              4
     ?<Constant "\n\rPress any switch on...">     64
     ?<Constant "Press any key">                  16
     ?<Constant "to start.">                      12
     ?<Constant "Received an MLME-Beac...">       44
     ?<Constant "MyWirelessApp Demo No...">       84
     ?<Constant "Initiating the Energy...">       40
     ?<Constant "Starting Energy">                16
     ?<Constant "Detection Scan">                 16
     ?<Constant "\n\rStarting as PAN coo...">     44
     ?<Constant "\n\r">                            4
     ?<Constant "Starting">                       12
     ?<Constant "PAN coordinator">                16
     ?<Constant "Started the coordinat...">       40
     ?<Constant ", and short address 0x">         24
     ?<Constant ".\n\r\n\rReady to send an...">   56
     ?<Constant "Ready to send">                  16
     ?<Constant "and receive data">               20
     ?<Constant "Sending the MLME-Scan...">       52
     ?<Constant "Done\n\r">                        8
     ?<Constant "Invalid parameter!\n\r">         24
     ?<Constant "Message allocation fa...">       32
     ?<Constant "Received the MLME-Sca...">       56
     ?<Constant "ED scan returned the ...">       48
     ?<Constant "]\n\r\n\r">                       8
     ?<Constant "Based on the ED scan ...">       44
     ?<Constant " was selected\n\r">              16
     ?<Constant "Sending the MLME-Star...">       56
     ?<Constant "Sending the MLME-Asso...">       60
     ?<Constant "Received an MLME-Asso...">       56
     ?<Constant "Received an MLME-Comm...">       56
     ?<Constant "Received the data pac...">       40
     ?<Constant "Application">                    12
     ?<Constant "    started">                    12

 
    67 bytes in section .bss
 1 116 bytes in section .rodata
 2 102 bytes in section .text
 
 2 102 bytes of CODE  memory
 1 116 bytes of CONST memory
    67 bytes of DATA  memory

Errors: none
Warnings: none
