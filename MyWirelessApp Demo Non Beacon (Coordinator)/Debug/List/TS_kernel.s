///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      15/Oct/2012  16:29:14 /
// IAR ANSI C/C++ Compiler V5.50.7.22081/W32 EVALUATION for ARM               /
// Copyright (C) 1999-2010 IAR Systems AB.                                    /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  C:\Documents and Settings\Administrator\My              /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\SSM\TS\Source\TS_kernel.c                 /
//    Command line =  "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\SSM\TS\Source\TS_kernel.c" -D             /
//                    gMacStandAlone_d=1 -D gSAPMessagesEnableLlc_d=0 -D      /
//                    gZtcIncluded_d=0 -D gTargetMC1322xNCB=1 --preprocess    /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Debug\List\" -lC "C:\Documents and        /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\List\" -lB "C:\Documents and        /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\List\" --diag_suppress              /
//                    Pe014,Pe001,Pe991,Pa039,Pe520 -o "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Debug\Obj\" --no_cse --no_unroll          /
//                    --no_inline --no_code_motion --no_tbaa --no_clustering  /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=ARM7TDMI-S --fpu=None --dlib_config "C:\Program   /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\DLib_Config_Normal.h" -I             /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\MacPhy\Interface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Application\Init\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\Application\Interface\" -I "C:\Documents  /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\Application\Configure\" -I         /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Application\UartUtil\" -I "C:\Documents   /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\Application\Source\" -I            /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\SSM\TS\Interface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\TS\Source\" -I "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\ZTC\Interface\" -I "C:\Documents and  /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\SSM\ZTC\Source\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Interface\" -I "C:\Documents and      /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\LibInterface\" -I "C:\Documents and   /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\Display\" -I "C:\Documents     /
//                    and Settings\Administrator\My Documents\MyWirelessApp   /
//                    Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non    /
//                    Beacon (Coordinator)\PLM\Source\Keyboard\" -I           /
//                    "C:\Documents and Settings\Administrator\My             /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\PLM\Source\NVM\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\TMR\" -I "C:\Documents and     /
//                    Settings\Administrator\My Documents\MyWirelessApp Demo  /
//                    Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon  /
//                    (Coordinator)\PLM\Source\UART\" -I "C:\Program          /
//                    Files\IAR Systems\Embedded Workbench 5.4                /
//                    Evaluation\arm\INC\" --interwork --cpu_mode thumb -On   /
//    List file    =  C:\Documents and Settings\Administrator\My              /
//                    Documents\MyWirelessApp Demo Non Beacon                 /
//                    (Coordinator)\MyWirelessApp Demo Non Beacon             /
//                    (Coordinator)\Debug\List\TS_kernel.s                    /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME TS_kernel

        EXTERN FLib_MemCpy
        EXTERN FLib_MemInPlaceCpy
        EXTERN FLib_MemSet
        EXTERN IdleTask
        EXTERN IntDisableAll
        EXTERN IntRestoreAll

        PUBLIC TS_ClearEvent
        PUBLIC TS_CreateTask
        PUBLIC TS_DestroyTask
        PUBLIC TS_Init
        PUBLIC TS_PendingEvents
        PUBLIC TS_Scheduler
        PUBLIC TS_SendEvent
        PUBWEAK __iar_via_R1
        PUBLIC gIdleTaskID
        PUBLIC maTsTaskIDsByPriority
        PUBLIC maTsTaskTable

// C:\Documents and Settings\Administrator\My Documents\MyWirelessApp Demo Non Beacon (Coordinator)\MyWirelessApp Demo Non Beacon (Coordinator)\SSM\TS\Source\TS_kernel.c
//    1 /*****************************************************************************
//    2 * Kernel / task handling implementation.
//    3 *
//    4 * (c) Copyright 2006, Freescale, Inc. All rights reserved.
//    5 *
//    6 *
//    7 * No part of this document must be reproduced in any form - including copied,
//    8 * transcribed, printed or by any electronic means - without specific written
//    9 * permission from Freescale Semiconductor Danmark A/S.
//   10 *
//   11 *
//   12 *****************************************************************************/
//   13 
//   14 #include "FunctionLib.h"
//   15 #include "EmbeddedTypes.h"
//   16 #include "TS_Interface.h"
//   17 #include "TS_Kernel.h"
//   18 #include "Interrupt.h"
//   19 
//   20 
//   21 /*****************************************************************************
//   22 ******************************************************************************
//   23 * Private macros
//   24 ******************************************************************************
//   25 *****************************************************************************/
//   26 
//   27 /* Number of elements in an array. */
//   28 #ifndef NumberOfElements
//   29 #define NumberOfElements(array)     ((sizeof(array) / (sizeof(array[0]))))
//   30 #endif
//   31 
//   32 
//   33 /*****************************************************************************
//   34 ******************************************************************************
//   35 * Private type declarations
//   36 ******************************************************************************
//   37 *****************************************************************************/
//   38 
//   39 /* If priority == g_InvalidTaskPriority_c, this entry is not in use. */
//   40 typedef struct tsTaskTableEntry_tag {
//   41   event_t events;
//   42   tsTaskPriority_t priority;
//   43   pfTsTaskEventHandler_t pfTaskEventHandler;
//   44 } tsTaskTableEntry_t;
//   45 
//   46 
//   47 /*****************************************************************************
//   48 ******************************************************************************
//   49 * Private memory definitions
//   50 ******************************************************************************
//   51 *****************************************************************************/
//   52 
//   53 /* List of task descriptors. */

        SECTION `.bss`:DATA:NOROOT(2)
//   54 tsTaskTableEntry_t maTsTaskTable[gTsMaxTasks_c];
maTsTaskTable:
        DS8 112
//   55 
//   56 /* List of task ids (== indexes into maTsTaskTable[]), sorted by task */
//   57 /* priority, with the highest priority tasks at lower index positions */
//   58 /* in this table. */

        SECTION `.bss`:DATA:NOROOT(2)
//   59 tsTaskID_t maTsTaskIDsByPriority[NumberOfElements(maTsTaskTable)];
maTsTaskIDsByPriority:
        DS8 16
//   60 
//   61 #if (gTsDebug_d == TRUE)
//   62 static uint16_t TsNonIdleLoopCounter = 0;
//   63 static uint16_t TsNonIdleLoopCounterMax = 0;
//   64 static uint32_t TsMainLoopCounter = 0;
//   65 #endif  /* gTsDebug_d */
//   66 
//   67 /*****************************************************************************
//   68 ******************************************************************************
//   69 * Private prototypes
//   70 ******************************************************************************
//   71 *****************************************************************************/
//   72 
//   73 /*****************************************************************************
//   74 ******************************************************************************
//   75 * Public memory definitions
//   76 ******************************************************************************
//   77 *****************************************************************************/
//   78 

        SECTION `.bss`:DATA:NOROOT(0)
//   79 tsTaskID_t gIdleTaskID;
gIdleTaskID:
        DS8 1
//   80 
//   81 /*****************************************************************************
//   82 ******************************************************************************
//   83 * Public functions
//   84 ******************************************************************************
//   85 *****************************************************************************/
//   86 
//   87 /* Remove events from a task's event flags. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   88 void TS_ClearEvent
//   89   (
//   90   tsTaskID_t taskID,
//   91   event_t events
//   92   )
//   93 {
TS_ClearEvent:
        PUSH     {R4-R6,LR}
        MOVS     R5,R0
        MOVS     R4,R1
//   94   uint8_t ret;
//   95   
//   96   ret = IntDisableAll();
        BL       IntDisableAll
        MOVS     R6,R0
//   97   maTsTaskTable[taskID].events &= ~events;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        LDRH     R0,[R1, R0]
        BICS     R0,R0,R4
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R1,#+8
        MULS     R1,R5,R1
        LDR      R2,??DataTable6
        STRH     R0,[R2, R1]
//   98   IntRestoreAll(ret);
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MOVS     R0,R6
        BL       IntRestoreAll
//   99 }
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
//  100 
//  101 /****************************************************************************/
//  102 
//  103 /* Add a task to the task table.
//  104  * Return the task ID, or gTsInvalidTaskID_c if the task table is full.
//  105  *
//  106  * taskPriority == 0 is reserved for the idle task, and must never be specified
//  107  * for any other task. TS_CreateTask() does not check for this.
//  108  *
//  109  * Note that TS_CreateTask() does not prevent a given event handler function
//  110  * pointer from being added more than once to the task table.
//  111  *
//  112  * Note that if TS_CreateTask() is called with a taskPriority that is the
//  113  * same as the priority of a task that is already in the task table, the
//  114  * two tasks will end up in adjacent slots in the table. Which one is
//  115  * called first by the scheduler is not specified.
//  116  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  117 tsTaskID_t TS_CreateTask
//  118   (
//  119   tsTaskPriority_t taskPriority,
//  120   pfTsTaskEventHandler_t pfTaskEventHandler
//  121   )
//  122 {
TS_CreateTask:
        PUSH     {R3-R7,LR}
        MOVS     R6,R0
        MOVS     R7,R1
//  123   index_t i;
//  124   index_t freeSlot;
//  125   index_t sizeofTaskId = sizeof(maTsTaskIDsByPriority[0]);
        MOV      R0,SP
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
//  126 
//  127   /* Try to find a free slot in the task table. */
//  128   for (i = 0, freeSlot = gTsInvalidTaskID_c;
        MOVS     R0,#+0
        MOVS     R4,R0
        MOVS     R0,#+255
        MOVS     R5,R0
//  129        (i < NumberOfElements(maTsTaskTable));
??TS_CreateTask_0:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+14
        BCS      ??TS_CreateTask_1
//  130        ++i) {
//  131     if (maTsTaskTable[i].priority == gTsInvalidTaskPriority_c) {
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+8
        MULS     R0,R4,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+2]
        CMP      R0,#+255
        BNE      ??TS_CreateTask_2
//  132       freeSlot = i;
        MOVS     R5,R4
//  133       break;
        B        ??TS_CreateTask_1
//  134     }
//  135   }                                     /* for (i = 0, freeSlot = 0xFF; ... */
??TS_CreateTask_2:
        ADDS     R4,R4,#+1
        B        ??TS_CreateTask_0
//  136 
//  137   if (freeSlot == gTsInvalidTaskID_c) {
??TS_CreateTask_1:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+255
        BNE      ??TS_CreateTask_3
//  138     return gTsInvalidTaskID_c;
        MOVS     R0,#+255
        B        ??TS_CreateTask_4
//  139   }
//  140 
//  141   maTsTaskTable[freeSlot].events = 0;
??TS_CreateTask_3:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        MOVS     R2,#+0
        STRH     R2,[R1, R0]
//  142   maTsTaskTable[freeSlot].pfTaskEventHandler = pfTaskEventHandler;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        STR      R7,[R0, #+4]
//  143   maTsTaskTable[freeSlot].priority = taskPriority;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        STRB     R6,[R0, #+2]
//  144 
//  145   /* maTsTaskIDsByPriority is maintained in sorted order, so 1) find the */
//  146   /* place where this new task should go; 2) move everything up; and 3) add */
//  147   /* the new task. */
//  148   for (i = 0; i < NumberOfElements(maTsTaskIDsByPriority); i++) {
        MOVS     R0,#+0
        MOVS     R4,R0
??TS_CreateTask_5:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+14
        BCS      ??TS_CreateTask_6
//  149     /* If the end of the table is reached, just add the new task. */
//  150     if (maTsTaskIDsByPriority[i] == gTsInvalidTaskPriority_c) {
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        LDRB     R0,[R0, R4]
        CMP      R0,#+255
        BEQ      ??TS_CreateTask_6
//  151       break;
//  152     }
//  153 
//  154     /* If all tasks from this point on have lower priorities than the task */
//  155     /* being added, move the rest up and insert the new one. */
//  156     if (maTsTaskTable[maTsTaskIDsByPriority[i]].priority < taskPriority) {
??TS_CreateTask_7:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        LDRB     R0,[R0, R4]
        MOVS     R1,#+8
        MULS     R0,R1,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+2]
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        CMP      R0,R6
        BCS      ??TS_CreateTask_8
//  157       FLib_MemInPlaceCpy(&maTsTaskIDsByPriority[i + 1],
//  158                          &maTsTaskIDsByPriority[i],
//  159                          (NumberOfElements(maTsTaskIDsByPriority) - i - 1) * sizeofTaskId);
        MOVS     R0,#+13
        SUBS     R2,R0,R4
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        MULS     R2,R0,R2
        LSLS     R2,R2,#+24       ;; ZeroExtS R2,R2,#+24,#+24
        LSRS     R2,R2,#+24
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        ADDS     R1,R0,R4
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        ADDS     R0,R0,R4
        ADDS     R0,R0,#+1
        BL       FLib_MemInPlaceCpy
//  160       break;
        B        ??TS_CreateTask_6
//  161     }
//  162   }                                     /* for (i = 0; ... */
??TS_CreateTask_8:
        ADDS     R4,R4,#+1
        B        ??TS_CreateTask_5
//  163   maTsTaskIDsByPriority[i] = freeSlot;
??TS_CreateTask_6:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        STRB     R5,[R0, R4]
//  164 
//  165   return freeSlot;
        MOVS     R0,R5
        LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
        LSRS     R0,R0,#+24
??TS_CreateTask_4:
        POP      {R1,R4-R7}
        POP      {R3}
        BX       R3               ;; return
//  166 }                                       /* TS_CreateTask() */
//  167 
//  168 /****************************************************************************/
//  169 
//  170 /* Remove a task from the task table. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  171 void TS_DestroyTask
//  172   (
//  173   tsTaskID_t taskID
//  174   )
//  175 {
TS_DestroyTask:
        PUSH     {R4-R6,LR}
        MOVS     R5,R0
//  176   index_t i;
//  177   index_t sizeofTaskId = sizeof(maTsTaskIDsByPriority[0]);
        MOVS     R0,#+1
        MOVS     R6,R0
//  178 
//  179   if (maTsTaskTable[taskID].priority == gTsInvalidTaskPriority_c) {
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+2]
        CMP      R0,#+255
        BEQ      ??TS_DestroyTask_0
//  180     return;
//  181   }
//  182 
//  183   /* Mark this slot in the task descriptor table as unused. */
//  184   maTsTaskTable[taskID].priority = gTsInvalidTaskPriority_c;
??TS_DestroyTask_1:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        ADDS     R0,R1,R0
        MOVS     R1,#+255
        STRB     R1,[R0, #+2]
//  185 
//  186   /* Remove this task's ID from the priority table. Find it's position */
//  187   /* in the table, and shift everything else down. */
//  188   for (i = 0; i < NumberOfElements(maTsTaskIDsByPriority); i++) {
        MOVS     R0,#+0
        MOVS     R4,R0
??TS_DestroyTask_2:
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        CMP      R4,#+14
        BCS      ??TS_DestroyTask_3
//  189     if (maTsTaskIDsByPriority[i] == taskID) {
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        LDRB     R0,[R0, R4]
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R0,R5
        BNE      ??TS_DestroyTask_4
//  190 
//  191       FLib_MemCpy(&maTsTaskIDsByPriority[i],
//  192                   &maTsTaskIDsByPriority[i + 1],
//  193                   (NumberOfElements(maTsTaskIDsByPriority) - i - 1) * sizeofTaskId);
        MOVS     R0,#+13
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        SUBS     R2,R0,R4
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MULS     R2,R6,R2
        LSLS     R2,R2,#+16       ;; ZeroExtS R2,R2,#+16,#+16
        LSRS     R2,R2,#+16
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        ADDS     R1,R0,R4
        ADDS     R1,R1,#+1
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        LDR      R0,??DataTable6_1
        ADDS     R0,R0,R4
        BL       FLib_MemCpy
//  194 
//  195       /* Note that exactly one entry was removed. */
//  196       maTsTaskIDsByPriority[NumberOfElements(maTsTaskIDsByPriority) - 1] = gTsInvalidTaskID_c;
        LDR      R0,??DataTable6_1
        MOVS     R1,#+255
        STRB     R1,[R0, #+13]
//  197       break;
        B        ??TS_DestroyTask_3
//  198     }
//  199   }
??TS_DestroyTask_4:
        ADDS     R4,R4,#+1
        B        ??TS_DestroyTask_2
//  200 
//  201   return;
??TS_DestroyTask_3:
??TS_DestroyTask_0:
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
//  202 }                                       /* TS_DestroyTask() */
//  203 
//  204 /****************************************************************************/
//  205 
//  206 /* Initialize the task scheduler. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  207 void TS_Init(void) {
TS_Init:
        PUSH     {R7,LR}
//  208   FLib_MemSet(maTsTaskTable, gTsInvalidTaskPriority_c, sizeof(maTsTaskTable));
        MOVS     R2,#+112
        MOVS     R1,#+255
        LDR      R0,??DataTable6
        BL       FLib_MemSet
//  209   FLib_MemSet(maTsTaskIDsByPriority, gTsInvalidTaskID_c, sizeof(maTsTaskIDsByPriority));
        MOVS     R2,#+14
        MOVS     R1,#+255
        LDR      R0,??DataTable6_1
        BL       FLib_MemSet
//  210 
//  211   gIdleTaskID = TS_CreateTask(gTsIdleTaskPriority_c, IdleTask);
        LDR      R1,??DataTable6_2
        MOVS     R0,#+0
        BL       TS_CreateTask
        LDR      R1,??DataTable6_3
        STRB     R0,[R1, #+0]
//  212 }                                       /* TS_Init() */
        POP      {R0,R3}
        BX       R3               ;; return
//  213 
//  214 /****************************************************************************/
//  215 
//  216 /* Returns true if there are any pending events for any task. */
//  217 /* This function must not disable/enable interrupts. If it did, an */
//  218 /* an interrupt could be delayed until just after the task table scan, */
//  219 /* which might invalidate the result of the scan. The caller should */
//  220 /* consider whether or not to dis/enable interrupts before calling. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  221 bool_t TS_PendingEvents(void) {
TS_PendingEvents:
        PUSH     {LR}
//  222   index_t i;
//  223 
//  224   for (i = 0; i < NumberOfElements(maTsTaskTable); i++) {
        MOVS     R0,#+0
        MOVS     R1,R0
??TS_PendingEvents_0:
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+14
        BCS      ??TS_PendingEvents_1
//  225     if (( maTsTaskTable[i].priority != gTsInvalidTaskPriority_c)
//  226         && maTsTaskTable[i].events) {
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        MOVS     R0,#+8
        MULS     R0,R1,R0
        LDR      R2,??DataTable6
        ADDS     R0,R2,R0
        LDRB     R0,[R0, #+2]
        CMP      R0,#+255
        BEQ      ??TS_PendingEvents_2
        LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
        LSRS     R1,R1,#+24
        MOVS     R0,#+8
        MULS     R0,R1,R0
        LDR      R2,??DataTable6
        LDRH     R0,[R2, R0]
        CMP      R0,#+0
        BEQ      ??TS_PendingEvents_2
//  227       return TRUE;
        MOVS     R0,#+1
        B        ??TS_PendingEvents_3
//  228     }
//  229   }
??TS_PendingEvents_2:
        ADDS     R1,R1,#+1
        B        ??TS_PendingEvents_0
//  230 
//  231   return FALSE;
??TS_PendingEvents_1:
        MOVS     R0,#+0
??TS_PendingEvents_3:
        POP      {R3}
        BX       R3               ;; return
//  232 }
//  233 
//  234 /****************************************************************************/
//  235 
//  236 /* Send events to a task. */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  237 void TS_SendEvent
//  238   (
//  239   tsTaskID_t taskID,
//  240   event_t events
//  241   )
//  242 {
TS_SendEvent:
        PUSH     {R4-R6,LR}
        MOVS     R5,R0
        MOVS     R4,R1
//  243   uint8_t ret;  
//  244   ret = IntDisableAll();
        BL       IntDisableAll
        MOVS     R6,R0
//  245   maTsTaskTable[taskID].events |= events;
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R0,#+8
        MULS     R0,R5,R0
        LDR      R1,??DataTable6
        LDRH     R0,[R1, R0]
        ORRS     R0,R0,R4
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        MOVS     R1,#+8
        MULS     R1,R5,R1
        LDR      R2,??DataTable6
        STRH     R0,[R2, R1]
//  246   IntRestoreAll(ret);
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MOVS     R0,R6
        BL       IntRestoreAll
//  247 }                                       /* TS_SendEvent() */
        POP      {R4-R6}
        POP      {R3}
        BX       R3               ;; return
//  248 
//  249 /****************************************************************************/
//  250 
//  251 /* BeeStack's main task loop. Never returns. This function is the center of
//  252  * the task system.
//  253  */

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  254 void TS_Scheduler(void) {
TS_Scheduler:
        PUSH     {R3-R7,LR}
//  255   index_t activeTask;
//  256   uint8_t ret;
//  257   event_t events;
//  258   index_t i;
//  259   index_t taskID;
//  260 
//  261   /* maTsTaskIDsByPriority[] is maintained in task priority order. If there */
//  262   /* are fewer than the maximum number of tasks, the first gInvalidTaskID_c */
//  263   /* marks the end of the table. */
//  264   for (;;) {
//  265     /* Look for the highest priority task that has an event flag set. */
//  266     activeTask = gTsIdleTaskID_c;
??TS_Scheduler_0:
        MOVS     R0,#+0
        MOVS     R4,R0
//  267     for (i = 0; i < NumberOfElements(maTsTaskIDsByPriority); ++i) {
        MOVS     R0,#+0
        MOVS     R5,R0
??TS_Scheduler_1:
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        CMP      R5,#+14
        BCS      ??TS_Scheduler_2
//  268       taskID = maTsTaskIDsByPriority[i];
        LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
        LSRS     R5,R5,#+24
        LDR      R0,??DataTable6_1
        LDRB     R0,[R0, R5]
        MOVS     R6,R0
//  269       if (taskID == gTsInvalidTaskID_c) {
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        CMP      R6,#+255
        BEQ      ??TS_Scheduler_2
//  270         break;
//  271       }
//  272 
//  273       if (maTsTaskTable[taskID].events) {
??TS_Scheduler_3:
        LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
        LSRS     R6,R6,#+24
        MOVS     R0,#+8
        MULS     R0,R6,R0
        LDR      R1,??DataTable6
        LDRH     R0,[R1, R0]
        CMP      R0,#+0
        BEQ      ??TS_Scheduler_4
//  274         activeTask = taskID;
        MOVS     R4,R6
//  275         break;
        B        ??TS_Scheduler_2
//  276       }
//  277     }
??TS_Scheduler_4:
        ADDS     R5,R5,#+1
        B        ??TS_Scheduler_1
//  278 
//  279 #if (gTsDebug_d == TRUE)
//  280     /* Record the maximum number of times this loop executes without */
//  281     /* a call to the idle task. */
//  282     ++TsMainLoopCounter;
//  283     if (activeTask == gTsIdleTaskID_c) {
//  284       if (TsNonIdleLoopCounterMax < TsNonIdleLoopCounter) {
//  285         TsNonIdleLoopCounterMax = TsNonIdleLoopCounter;
//  286       }
//  287       TsNonIdleLoopCounter = 0;
//  288     } else {
//  289       ++TsNonIdleLoopCounter;
//  290     }
//  291 #endif /* gTsDebug_d */
//  292 
//  293     /* If there are no outstanding events, call the idle task. */
//  294   ret = IntDisableAll();
??TS_Scheduler_2:
        BL       IntDisableAll
        MOV      R1,SP
        STRB     R0,[R1, #+0]
//  295     events = maTsTaskTable[activeTask].events;
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+8
        MULS     R0,R4,R0
        LDR      R1,??DataTable6
        LDRH     R0,[R1, R0]
        MOVS     R7,R0
//  296     maTsTaskTable[activeTask].events = 0;
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R0,#+8
        MULS     R0,R4,R0
        LDR      R1,??DataTable6
        MOVS     R2,#+0
        STRH     R2,[R1, R0]
//  297     IntRestoreAll(ret);
        MOV      R0,SP
        LDRB     R0,[R0, #+0]
        BL       IntRestoreAll
//  298 
//  299     (*maTsTaskTable[activeTask].pfTaskEventHandler)(events);
        MOVS     R0,R7
        LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
        LSRS     R0,R0,#+16
        LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
        LSRS     R4,R4,#+24
        MOVS     R1,#+8
        MULS     R1,R4,R1
        LDR      R2,??DataTable6
        ADDS     R1,R2,R1
        LDR      R1,[R1, #+4]
        BL       __iar_via_R1
        B        ??TS_Scheduler_0
//  300   }                                     /* for (;;) */
//  301 }                                       /* TS_Scheduler() */

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable6:
        DC32     maTsTaskTable

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable6_1:
        DC32     maTsTaskIDsByPriority

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable6_2:
        DC32     IdleTask

        SECTION `.text`:CODE:NOROOT(2)
        DATA
??DataTable6_3:
        DC32     gIdleTaskID

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
__iar_via_R1:
        BX       R1

        END
// 
// 129 bytes in section .bss
// 704 bytes in section .text
// 
// 702 bytes of CODE memory (+ 2 bytes shared)
// 129 bytes of DATA memory
//
//Errors: none
//Warnings: none
